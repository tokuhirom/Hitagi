# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Bundle/LWP.pm"} = <<'BUNDLE_LWP';
  package Bundle::LWP;
  
  $VERSION = "5.835";
  
  1;
  
  __END__
  
  =head1 NAME
  
  Bundle::LWP - install all libwww-perl related modules
  
  =head1 SYNOPSIS
  
   perl -MCPAN -e 'install Bundle::LWP'
  
  =head1 CONTENTS
  
  MIME::Base64       - Used in authentication headers
  
  Digest::MD5        - Needed to do Digest authentication
  
  URI 1.10           - There are URIs everywhere
  
  Net::FTP 2.58      - If you want ftp://-support
  
  HTML::Tagset       - Needed by HTML::Parser
  
  HTML::Parser       - Needed by HTML::HeadParser
  
  HTML::HeadParser   - To get the correct $res->base
  
  LWP                - The reason why you need the modules above
  
  =head1 DESCRIPTION
  
  This bundle defines all prerequisite modules for libwww-perl.  Bundles
  have special meaning for the CPAN module.  When you install the bundle
  module all modules mentioned in L</CONTENTS> will be installed
  instead.
  
  =head1 SEE ALSO
  
  L<CPAN/Bundles>
BUNDLE_LWP

$fatpacked{"Class/Accessor.pm"} = <<'CLASS_ACCESSOR';
  package Class::Accessor;
  require 5.00502;
  use strict;
  $Class::Accessor::VERSION = '0.34';
  
  sub new {
      my($proto, $fields) = @_;
      my($class) = ref $proto || $proto;
  
      $fields = {} unless defined $fields;
  
      # make a copy of $fields.
      bless {%$fields}, $class;
  }
  
  sub mk_accessors {
      my($self, @fields) = @_;
  
      $self->_mk_accessors('rw', @fields);
  }
  
  if (eval { require Sub::Name }) {
      Sub::Name->import;
  }
  
  {
      no strict 'refs';
  
      sub import {
          my ($class, @what) = @_;
          my $caller = caller;
          for (@what) {
              if (/^(?:antlers|moose-?like)$/i) {
                  *{"${caller}::has"} = sub {
                      my ($f, %args) = @_;
                      $caller->_mk_accessors(($args{is}||"rw"), $f);
                  };
                  *{"${caller}::extends"} = sub {
                      @{"${caller}::ISA"} = @_;
                      unless (grep $_->can("_mk_accessors"), @_) {
                          push @{"${caller}::ISA"}, $class;
                      }
                  };
                  # we'll use their @ISA as a default, in case it happens to be
                  # set already
                  &{"${caller}::extends"}(@{"${caller}::ISA"});
              }
          }
      }
  
      sub follow_best_practice {
          my($self) = @_;
          my $class = ref $self || $self;
          *{"${class}::accessor_name_for"}  = \&best_practice_accessor_name_for;
          *{"${class}::mutator_name_for"}  = \&best_practice_mutator_name_for;
      }
  
      sub _mk_accessors {
          my($self, $access, @fields) = @_;
          my $class = ref $self || $self;
          my $ra = $access eq 'rw' || $access eq 'ro';
          my $wa = $access eq 'rw' || $access eq 'wo';
  
          foreach my $field (@fields) {
              my $accessor_name = $self->accessor_name_for($field);
              my $mutator_name = $self->mutator_name_for($field);
              if( $accessor_name eq 'DESTROY' or $mutator_name eq 'DESTROY' ) {
                  $self->_carp("Having a data accessor named DESTROY  in '$class' is unwise.");
              }
              if ($accessor_name eq $mutator_name) {
                  my $accessor;
                  if ($ra && $wa) {
                      $accessor = $self->make_accessor($field);
                  } elsif ($ra) {
                      $accessor = $self->make_ro_accessor($field);
                  } else {
                      $accessor = $self->make_wo_accessor($field);
                  }
                  my $fullname = "${class}::$accessor_name";
                  my $subnamed = 0;
                  unless (defined &{$fullname}) {
                      subname($fullname, $accessor) if defined &subname;
                      $subnamed = 1;
                      *{$fullname} = $accessor;
                  }
                  if ($accessor_name eq $field) {
                      # the old behaviour
                      my $alias = "${class}::_${field}_accessor";
                      subname($alias, $accessor) if defined &subname and not $subnamed;
                      *{$alias} = $accessor unless defined &{$alias};
                  }
              } else {
                  my $fullaccname = "${class}::$accessor_name";
                  my $fullmutname = "${class}::$mutator_name";
                  if ($ra and not defined &{$fullaccname}) {
                      my $accessor = $self->make_ro_accessor($field);
                      subname($fullaccname, $accessor) if defined &subname;
                      *{$fullaccname} = $accessor;
                  }
                  if ($wa and not defined &{$fullmutname}) {
                      my $mutator = $self->make_wo_accessor($field);
                      subname($fullmutname, $mutator) if defined &subname;
                      *{$fullmutname} = $mutator;
                  }
              }
          }
      }
  
  }
  
  sub mk_ro_accessors {
      my($self, @fields) = @_;
  
      $self->_mk_accessors('ro', @fields);
  }
  
  sub mk_wo_accessors {
      my($self, @fields) = @_;
  
      $self->_mk_accessors('wo', @fields);
  }
  
  sub best_practice_accessor_name_for {
      my ($class, $field) = @_;
      return "get_$field";
  }
  
  sub best_practice_mutator_name_for {
      my ($class, $field) = @_;
      return "set_$field";
  }
  
  sub accessor_name_for {
      my ($class, $field) = @_;
      return $field;
  }
  
  sub mutator_name_for {
      my ($class, $field) = @_;
      return $field;
  }
  
  sub set {
      my($self, $key) = splice(@_, 0, 2);
  
      if(@_ == 1) {
          $self->{$key} = $_[0];
      }
      elsif(@_ > 1) {
          $self->{$key} = [@_];
      }
      else {
          $self->_croak("Wrong number of arguments received");
      }
  }
  
  sub get {
      my $self = shift;
  
      if(@_ == 1) {
          return $self->{$_[0]};
      }
      elsif( @_ > 1 ) {
          return @{$self}{@_};
      }
      else {
          $self->_croak("Wrong number of arguments received");
      }
  }
  
  sub make_accessor {
      my ($class, $field) = @_;
  
      return sub {
          my $self = shift;
  
          if(@_) {
              return $self->set($field, @_);
          } else {
              return $self->get($field);
          }
      };
  }
  
  sub make_ro_accessor {
      my($class, $field) = @_;
  
      return sub {
          my $self = shift;
  
          if (@_) {
              my $caller = caller;
              $self->_croak("'$caller' cannot alter the value of '$field' on objects of class '$class'");
          }
          else {
              return $self->get($field);
          }
      };
  }
  
  sub make_wo_accessor {
      my($class, $field) = @_;
  
      return sub {
          my $self = shift;
  
          unless (@_) {
              my $caller = caller;
              $self->_croak("'$caller' cannot access the value of '$field' on objects of class '$class'");
          }
          else {
              return $self->set($field, @_);
          }
      };
  }
  
  
  use Carp ();
  
  sub _carp {
      my ($self, $msg) = @_;
      Carp::carp($msg || $self);
      return;
  }
  
  sub _croak {
      my ($self, $msg) = @_;
      Carp::croak($msg || $self);
      return;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
    Class::Accessor - Automated accessor generation
  
  =head1 SYNOPSIS
  
    package Foo;
    use base qw(Class::Accessor);
    Foo->follow_best_practice;
    Foo->mk_accessors(qw(name role salary));
  
    # or if you prefer a Moose-like interface...
   
    package Foo;
    use Class::Accessor "antlers";
    has name => ( is => "rw", isa => "Str" );
    has role => ( is => "rw", isa => "Str" );
    has salary => ( is => "rw", isa => "Num" );
  
    # Meanwhile, in a nearby piece of code!
    # Class::Accessor provides new().
    my $mp = Foo->new({ name => "Marty", role => "JAPH" });
  
    my $job = $mp->role;  # gets $mp->{role}
    $mp->salary(400000);  # sets $mp->{salary} = 400000 # I wish
    
    # like my @info = @{$mp}{qw(name role)}
    my @info = $mp->get(qw(name role));
    
    # $mp->{salary} = 400000
    $mp->set('salary', 400000);
  
  
  =head1 DESCRIPTION
  
  This module automagically generates accessors/mutators for your class.
  
  Most of the time, writing accessors is an exercise in cutting and
  pasting.  You usually wind up with a series of methods like this:
  
      sub name {
          my $self = shift;
          if(@_) {
              $self->{name} = $_[0];
          }
          return $self->{name};
      }
  
      sub salary {
          my $self = shift;
          if(@_) {
              $self->{salary} = $_[0];
          }
          return $self->{salary};
      }
  
    # etc...
  
  One for each piece of data in your object.  While some will be unique,
  doing value checks and special storage tricks, most will simply be
  exercises in repetition.  Not only is it Bad Style to have a bunch of
  repetitious code, but it's also simply not lazy, which is the real
  tragedy.
  
  If you make your module a subclass of Class::Accessor and declare your
  accessor fields with mk_accessors() then you'll find yourself with a
  set of automatically generated accessors which can even be
  customized!
  
  The basic set up is very simple:
  
      package Foo;
      use base qw(Class::Accessor);
      Foo->mk_accessors( qw(far bar car) );
  
  Done.  Foo now has simple far(), bar() and car() accessors
  defined.
  
  Alternatively, if you want to follow Damian's I<best practice> guidelines 
  you can use:
  
      package Foo;
      use base qw(Class::Accessor);
      Foo->follow_best_practice;
      Foo->mk_accessors( qw(far bar car) );
  
  B<Note:> you must call C<follow_best_practice> before calling C<mk_accessors>.
  
  =head2 Moose-like
  
  By popular demand we now have a simple Moose-like interface.  You can now do:
  
      package Foo;
      use Class::Accessor "antlers";
      has far => ( is => "rw" );
      has bar => ( is => "rw" );
      has car => ( is => "rw" );
  
  Currently only the C<is> attribute is supported.
  
  =head1 CONSTRUCTOR
  
  Class::Accessor provides a basic constructor, C<new>.  It generates a
  hash-based object and can be called as either a class method or an
  object method.  
  
  =head2 new
  
      my $obj = Foo->new;
      my $obj = $other_obj->new;
  
      my $obj = Foo->new(\%fields);
      my $obj = $other_obj->new(\%fields);
  
  It takes an optional %fields hash which is used to initialize the
  object (handy if you use read-only accessors).  The fields of the hash
  correspond to the names of your accessors, so...
  
      package Foo;
      use base qw(Class::Accessor);
      Foo->mk_accessors('foo');
  
      my $obj = Foo->new({ foo => 42 });
      print $obj->foo;    # 42
  
  however %fields can contain anything, new() will shove them all into
  your object.
  
  =head1 MAKING ACCESSORS
  
  =head2 follow_best_practice
  
  In Damian's Perl Best Practices book he recommends separate get and set methods
  with the prefix set_ and get_ to make it explicit what you intend to do.  If you
  want to create those accessor methods instead of the default ones, call:
  
      __PACKAGE__->follow_best_practice
  
  B<before> you call any of the accessor-making methods.
  
  =head2 accessor_name_for / mutator_name_for
  
  You may have your own crazy ideas for the names of the accessors, so you can
  make those happen by overriding C<accessor_name_for> and C<mutator_name_for> in
  your subclass.  (I copied that idea from Class::DBI.)
  
  =head2 mk_accessors
  
      __PACKAGE__->mk_accessors(@fields);
  
  This creates accessor/mutator methods for each named field given in
  @fields.  Foreach field in @fields it will generate two accessors.
  One called "field()" and the other called "_field_accessor()".  For
  example:
  
      # Generates foo(), _foo_accessor(), bar() and _bar_accessor().
      __PACKAGE__->mk_accessors(qw(foo bar));
  
  See L<CAVEATS AND TRICKS/"Overriding autogenerated accessors">
  for details.
  
  =head2 mk_ro_accessors
  
    __PACKAGE__->mk_ro_accessors(@read_only_fields);
  
  Same as mk_accessors() except it will generate read-only accessors
  (ie. true accessors).  If you attempt to set a value with these
  accessors it will throw an exception.  It only uses get() and not
  set().
  
      package Foo;
      use base qw(Class::Accessor);
      Foo->mk_ro_accessors(qw(foo bar));
  
      # Let's assume we have an object $foo of class Foo...
      print $foo->foo;  # ok, prints whatever the value of $foo->{foo} is
      $foo->foo(42);    # BOOM!  Naughty you.
  
  
  =head2 mk_wo_accessors
  
    __PACKAGE__->mk_wo_accessors(@write_only_fields);
  
  Same as mk_accessors() except it will generate write-only accessors
  (ie. mutators).  If you attempt to read a value with these accessors
  it will throw an exception.  It only uses set() and not get().
  
  B<NOTE> I'm not entirely sure why this is useful, but I'm sure someone
  will need it.  If you've found a use, let me know.  Right now it's here
  for orthoginality and because it's easy to implement.
  
      package Foo;
      use base qw(Class::Accessor);
      Foo->mk_wo_accessors(qw(foo bar));
  
      # Let's assume we have an object $foo of class Foo...
      $foo->foo(42);      # OK.  Sets $self->{foo} = 42
      print $foo->foo;    # BOOM!  Can't read from this accessor.
  
  =head1 Moose!
  
  If you prefer a Moose-like interface to create accessors, you can use C<has> by
  importing this module like this:
  
    use Class::Accessor "antlers";
  
  or
  
    use Class::Accessor "moose-like";
  
  Then you can declare accessors like this:
  
    has alpha => ( is => "rw", isa => "Str" );
    has beta  => ( is => "ro", isa => "Str" );
    has gamma => ( is => "wo", isa => "Str" );
  
  Currently only the C<is> attribute is supported.  And our C<is> also supports
  the "wo" value to make a write-only accessor.
  
  If you are using the Moose-like interface then you should use the C<extends>
  rather than tweaking your C<@ISA> directly.  Basically, replace
  
    @ISA = qw/Foo Bar/;
  
  with
  
    extends(qw/Foo Bar/);
  
  =head1 DETAILS
  
  An accessor generated by Class::Accessor looks something like
  this:
  
      # Your foo may vary.
      sub foo {
          my($self) = shift;
          if(@_) {    # set
              return $self->set('foo', @_);
          }
          else {
              return $self->get('foo');
          }
      }
  
  Very simple.  All it does is determine if you're wanting to set a
  value or get a value and calls the appropriate method.
  Class::Accessor provides default get() and set() methods which
  your class can override.  They're detailed later.
  
  =head2 Modifying the behavior of the accessor
  
  Rather than actually modifying the accessor itself, it is much more
  sensible to simply override the two key methods which the accessor
  calls.  Namely set() and get().
  
  If you -really- want to, you can override make_accessor().
  
  =head2 set
  
      $obj->set($key, $value);
      $obj->set($key, @values);
  
  set() defines how generally one stores data in the object.
  
  override this method to change how data is stored by your accessors.
  
  =head2 get
  
      $value  = $obj->get($key);
      @values = $obj->get(@keys);
  
  get() defines how data is retreived from your objects.
  
  override this method to change how it is retreived.
  
  =head2 make_accessor
  
      $accessor = __PACKAGE__->make_accessor($field);
  
  Generates a subroutine reference which acts as an accessor for the given
  $field.  It calls get() and set().
  
  If you wish to change the behavior of your accessors, try overriding
  get() and set() before you start mucking with make_accessor().
  
  =head2 make_ro_accessor
  
      $read_only_accessor = __PACKAGE__->make_ro_accessor($field);
  
  Generates a subroutine refrence which acts as a read-only accessor for
  the given $field.  It only calls get().
  
  Override get() to change the behavior of your accessors.
  
  =head2 make_wo_accessor
  
      $read_only_accessor = __PACKAGE__->make_wo_accessor($field);
  
  Generates a subroutine refrence which acts as a write-only accessor
  (mutator) for the given $field.  It only calls set().
  
  Override set() to change the behavior of your accessors.
  
  =head1 EXCEPTIONS
  
  If something goes wrong Class::Accessor will warn or die by calling Carp::carp
  or Carp::croak.  If you don't like this you can override _carp() and _croak() in
  your subclass and do whatever else you want.
  
  =head1 EFFICIENCY
  
  Class::Accessor does not employ an autoloader, thus it is much faster
  than you'd think.  Its generated methods incur no special penalty over
  ones you'd write yourself.
  
    accessors:
                Rate  Basic   Fast Faster Direct
    Basic   367589/s     --   -51%   -55%   -89%
    Fast    747964/s   103%     --    -9%   -77%
    Faster  819199/s   123%    10%     --   -75%
    Direct 3245887/s   783%   334%   296%     --
  
    mutators:
                Rate    Acc   Fast Faster Direct
    Acc     265564/s     --   -54%   -63%   -91%
    Fast    573439/s   116%     --   -21%   -80%
    Faster  724710/s   173%    26%     --   -75%
    Direct 2860979/s   977%   399%   295%     --
  
  Class::Accessor::Fast is faster than methods written by an average programmer
  (where "average" is based on Schwern's example code).
  
  Class::Accessor is slower than average, but more flexible.
  
  Class::Accessor::Faster is even faster than Class::Accessor::Fast.  It uses an
  array internally, not a hash.  This could be a good or bad feature depending on
  your point of view.
  
  Direct hash access is, of course, much faster than all of these, but it
  provides no encapsulation.
  
  Of course, it's not as simple as saying "Class::Accessor is slower than
  average".  These are benchmarks for a simple accessor.  If your accessors do
  any sort of complicated work (such as talking to a database or writing to a
  file) the time spent doing that work will quickly swamp the time spend just
  calling the accessor.  In that case, Class::Accessor and the ones you write
  will be roughly the same speed.
  
  
  =head1 EXAMPLES
  
  Here's an example of generating an accessor for every public field of
  your class.
  
      package Altoids;
      
      use base qw(Class::Accessor Class::Fields);
      use fields qw(curiously strong mints);
      Altoids->mk_accessors( Altoids->show_fields('Public') );
  
      sub new {
          my $proto = shift;
          my $class = ref $proto || $proto;
          return fields::new($class);
      }
  
      my Altoids $tin = Altoids->new;
  
      $tin->curiously('Curiouser and curiouser');
      print $tin->{curiously};    # prints 'Curiouser and curiouser'
  
      
      # Subclassing works, too.
      package Mint::Snuff;
      use base qw(Altoids);
  
      my Mint::Snuff $pouch = Mint::Snuff->new;
      $pouch->strong('Blow your head off!');
      print $pouch->{strong};     # prints 'Blow your head off!'
  
  
  Here's a simple example of altering the behavior of your accessors.
  
      package Foo;
      use base qw(Class::Accessor);
      Foo->mk_accessors(qw(this that up down));
  
      sub get {
          my $self = shift;
  
          # Note every time someone gets some data.
          print STDERR "Getting @_\n";
  
          $self->SUPER::get(@_);
      }
  
      sub set {
          my ($self, $key) = splice(@_, 0, 2);
  
          # Note every time someone sets some data.
          print STDERR "Setting $key to @_\n";
  
          $self->SUPER::set($key, @_);
      }
  
  
  =head1 CAVEATS AND TRICKS
  
  Class::Accessor has to do some internal wackiness to get its
  job done quickly and efficiently.  Because of this, there's a few
  tricks and traps one must know about.
  
  Hey, nothing's perfect.
  
  =head2 Don't make a field called DESTROY
  
  This is bad.  Since DESTROY is a magical method it would be bad for us
  to define an accessor using that name.  Class::Accessor will
  carp if you try to use it with a field named "DESTROY".
  
  =head2 Overriding autogenerated accessors
  
  You may want to override the autogenerated accessor with your own, yet
  have your custom accessor call the default one.  For instance, maybe
  you want to have an accessor which checks its input.  Normally, one
  would expect this to work:
  
      package Foo;
      use base qw(Class::Accessor);
      Foo->mk_accessors(qw(email this that whatever));
  
      # Only accept addresses which look valid.
      sub email {
          my($self) = shift;
          my($email) = @_;
  
          if( @_ ) {  # Setting
              require Email::Valid;
              unless( Email::Valid->address($email) ) {
                  carp("$email doesn't look like a valid address.");
                  return;
              }
          }
  
          return $self->SUPER::email(@_);
      }
  
  There's a subtle problem in the last example, and it's in this line:
  
      return $self->SUPER::email(@_);
  
  If we look at how Foo was defined, it called mk_accessors() which
  stuck email() right into Foo's namespace.  There *is* no
  SUPER::email() to delegate to!  Two ways around this... first is to
  make a "pure" base class for Foo.  This pure class will generate the
  accessors and provide the necessary super class for Foo to use:
  
      package Pure::Organic::Foo;
      use base qw(Class::Accessor);
      Pure::Organic::Foo->mk_accessors(qw(email this that whatever));
  
      package Foo;
      use base qw(Pure::Organic::Foo);
  
  And now Foo::email() can override the generated
  Pure::Organic::Foo::email() and use it as SUPER::email().
  
  This is probably the most obvious solution to everyone but me.
  Instead, what first made sense to me was for mk_accessors() to define
  an alias of email(), _email_accessor().  Using this solution,
  Foo::email() would be written with:
  
      return $self->_email_accessor(@_);
  
  instead of the expected SUPER::email().
  
  
  =head1 AUTHORS
  
  Copyright 2009 Marty Pauley <marty+perl@kasei.com>
  
  This program is free software; you can redistribute it and/or modify it under
  the same terms as Perl itself.  That means either (a) the GNU General Public
  License or (b) the Artistic License.
  
  =head2 ORIGINAL AUTHOR
  
  Michael G Schwern <schwern@pobox.com>
  
  =head2 THANKS
  
  Liz and RUZ for performance tweaks.
  
  Tels, for his big feature request/bug report.
  
  Various presenters at YAPC::Asia 2009 for criticising the non-Moose interface.
  
  =head1 SEE ALSO
  
  See L<Class::Accessor::Fast> and L<Class::Accessor::Faster> if speed is more
  important than flexibility.
  
  These are some modules which do similar things in different ways
  L<Class::Struct>, L<Class::Methodmaker>, L<Class::Generate>,
  L<Class::Class>, L<Class::Contract>, L<Moose>, L<Mouse>
  
  See L<Class::DBI> for an example of this module in use.
  
  =cut
CLASS_ACCESSOR

$fatpacked{"Class/Accessor/Fast.pm"} = <<'CLASS_ACCESSOR_FAST';
  package Class::Accessor::Fast;
  use base 'Class::Accessor';
  use strict;
  $Class::Accessor::Fast::VERSION = '0.34';
  
  sub make_accessor {
      my($class, $field) = @_;
  
      return sub {
          return $_[0]->{$field} if scalar(@_) == 1;
          return $_[0]->{$field}  = scalar(@_) == 2 ? $_[1] : [@_[1..$#_]];
      };
  }
  
  
  sub make_ro_accessor {
      my($class, $field) = @_;
  
      return sub {
          return $_[0]->{$field} if @_ == 1;
          my $caller = caller;
          $_[0]->_croak("'$caller' cannot alter the value of '$field' on objects of class '$class'");
      };
  }
  
  
  sub make_wo_accessor {
      my($class, $field) = @_;
  
      return sub {
          if (@_ == 1) {
              my $caller = caller;
              $_[0]->_croak("'$caller' cannot access the value of '$field' on objects of class '$class'");
          }
          else {
              return $_[0]->{$field} = $_[1] if @_ == 2;
              return (shift)->{$field} = \@_;
          }
      };
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  Class::Accessor::Fast - Faster, but less expandable, accessors
  
  =head1 SYNOPSIS
  
    package Foo;
    use base qw(Class::Accessor::Fast);
  
    # The rest is the same as Class::Accessor but without set() and get().
  
  =head1 DESCRIPTION
  
  This is a faster but less expandable version of Class::Accessor.
  Class::Accessor's generated accessors require two method calls to accompish
  their task (one for the accessor, another for get() or set()).
  Class::Accessor::Fast eliminates calling set()/get() and does the access itself,
  resulting in a somewhat faster accessor.
  
  The downside is that you can't easily alter the behavior of your
  accessors, nor can your subclasses.  Of course, should you need this
  later, you can always swap out Class::Accessor::Fast for
  Class::Accessor.
  
  Read the documentation for Class::Accessor for more info.
  
  =head1 EFFICIENCY
  
  L<Class::Accessor/EFFICIENCY> for an efficiency comparison.
  
  =head1 AUTHORS
  
  Copyright 2007 Marty Pauley <marty+perl@kasei.com>
  
  This program is free software; you can redistribute it and/or modify it under
  the same terms as Perl itself.  That means either (a) the GNU General Public
  License or (b) the Artistic License.
  
  =head2 ORIGINAL AUTHOR
  
  Michael G Schwern <schwern@pobox.com>
  
  =head1 SEE ALSO
  
  L<Class::Accessor>
  
  =cut
CLASS_ACCESSOR_FAST

$fatpacked{"Class/Accessor/Faster.pm"} = <<'CLASS_ACCESSOR_FASTER';
  package Class::Accessor::Faster;
  use base 'Class::Accessor';
  use strict;
  $Class::Accessor::Faster::VERSION = '0.34';
  
  my %slot;
  sub _slot {
      my($class, $field) = @_;
      my $n = $slot{$class}->{$field};
      return $n if defined $n;
      $n = keys %{$slot{$class}};
      $slot{$class}->{$field} = $n;
      return $n;
  }
  
  sub new {
      my($proto, $fields) = @_;
      my($class) = ref $proto || $proto;
      my $self = bless [], $class;
  
      $fields = {} unless defined $fields;
      for my $k (keys %$fields) {
          my $n = $class->_slot($k);
          $self->[$n] = $fields->{$k};
      }
      return $self;
  }
  
  sub make_accessor {
      my($class, $field) = @_;
      my $n = $class->_slot($field);
      return sub {
          return $_[0]->[$n] if scalar(@_) == 1;
          return $_[0]->[$n]  = scalar(@_) == 2 ? $_[1] : [@_[1..$#_]];
      };
  }
  
  sub make_ro_accessor {
      my($class, $field) = @_;
      my $n = $class->_slot($field);
      return sub {
          return $_[0]->[$n] if @_ == 1;
          my $caller = caller;
          $_[0]->_croak("'$caller' cannot alter the value of '$field' on objects of class '$class'");
      };
  }
  
  sub make_wo_accessor {
      my($class, $field) = @_;
      my $n = $class->_slot($field);
      return sub {
          if (@_ == 1) {
              my $caller = caller;
              $_[0]->_croak("'$caller' cannot access the value of '$field' on objects of class '$class'");
          } else {
              return $_[0]->[$n] = $_[1] if @_ == 2;
              return (shift)->[$n] = \@_;
          }
      };
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Class::Accessor::Faster - Even faster, but less expandable, accessors
  
  =head1 SYNOPSIS
  
    package Foo;
    use base qw(Class::Accessor::Faster);
  
  =head1 DESCRIPTION
  
  This is a faster but less expandable version of Class::Accessor::Fast.
  
  Class::Accessor's generated accessors require two method calls to accompish
  their task (one for the accessor, another for get() or set()).
  
  Class::Accessor::Fast eliminates calling set()/get() and does the access itself,
  resulting in a somewhat faster accessor.
  
  Class::Accessor::Faster uses an array reference underneath to be faster.
  
  Read the documentation for Class::Accessor for more info.
  
  =head1 AUTHORS
  
  Copyright 2007 Marty Pauley <marty+perl@kasei.com>
  
  This program is free software; you can redistribute it and/or modify it under
  the same terms as Perl itself.  That means either (a) the GNU General Public
  License or (b) the Artistic License.
  
  =head1 SEE ALSO
  
  L<Class::Accessor>
  
  =cut
CLASS_ACCESSOR_FASTER

$fatpacked{"DBIx/Skinny.pm"} = <<'DBIX_SKINNY';
  package DBIx::Skinny;
  use strict;
  use warnings;
  
  our $VERSION = '0.0711';
  
  use DBI;
  use DBIx::Skinny::Iterator;
  use DBIx::Skinny::DBD;
  use DBIx::Skinny::Row;
  use DBIx::Skinny::Profiler;
  use DBIx::Skinny::Profiler::Trace;
  use DBIx::Skinny::Transaction;
  use Digest::SHA1 ();
  use Carp ();
  use Storable ();
  
  sub import {
      my ($class, %opt) = @_;
  
      my $caller = caller;
      my $args   = $opt{setup}||+{};
  
      my $schema = "$caller\::Schema";
  
      my $dbd_type = _dbd_type($args);
      my $_attribute = +{
          check_schema    => defined $args->{check_schema} ? $args->{check_schema} : 1,
          dsn             => $args->{dsn},
          username        => $args->{username},
          password        => $args->{password},
          connect_options => $args->{connect_options},
          on_connect_do   => $args->{on_connect_do},
          dbh             => $args->{dbh}||undef,
          dbd             => $dbd_type ? DBIx::Skinny::DBD->new($dbd_type) : undef,
          schema          => $schema,
          profiler        => ( $args->{profiler} || ( $ENV{SKINNY_TRACE} ? DBIx::Skinny::Profiler::Trace->new : DBIx::Skinny::Profiler->new ) ),
          profile         => $ENV{SKINNY_PROFILE}||$ENV{SKINNY_TRACE}||0,
          klass           => $caller,
          row_class_map   => +{},
          active_transaction => 0,
      };
  
      {
          no strict 'refs';
          *{"$caller\::attribute"} = sub { ref $_[0] ? $_[0] : $_attribute };
  
          my @functions = qw/
              new
              schema profiler
              dbh dbd connect connect_info _dbd_type reconnect set_dbh setup_dbd do_on_connect
              call_schema_trigger bind_params
              do resultset search single search_by_sql search_named count
              data2itr find_or_new
                  _get_sth_iterator _mk_row_class _camelize _mk_anon_row_class _guess_table_name
              insert replace _insert_or_replace bulk_insert create update delete find_or_create find_or_insert
              update_by_sql delete_by_sql
                  _add_where
              _execute _close_sth _stack_trace
              txn_scope txn_begin txn_rollback txn_commit txn_end
          /;
          for my $func (@functions) {
              *{"$caller\::$func"} = \&$func;
          }
      }
  
      eval "use $schema"; ## no critic
      if ( $@ ) {
          # accept schema class declaration within base class.
          (my $schema_file = $schema) =~ s|::|/|g;
          die $@ if $@ && $@ !~ /Can't locate $schema_file\.pm in \@INC/;
      }
  
      strict->import;
      warnings->import;
  }
  
  sub new {
      my ($class, $connection_info) = @_;
      my $attr = $class->attribute;
  
      my %unstorable_attribute;
      for my $key ( qw/dbd profiler dbh connect_options on_connect_do / ) {
          $unstorable_attribute{$key} = delete $attr->{$key};
      }
  
      my $self = bless Storable::dclone($attr), $class;
  
      # restore.
      for my $key ( keys %unstorable_attribute ) {
          $attr->{$key} = $unstorable_attribute{$key};
      }
  
  
      if ($connection_info) {
  
          $self->attribute->{profiler} = $unstorable_attribute{profiler};
  
          if ( $connection_info->{on_connect_do} ) {
              $self->attribute->{on_connect_do} = $connection_info->{on_connect_do};
          } else {
              $self->attribute->{on_connect_do} = $unstorable_attribute{on_connect_do};
          }
  
          if ($connection_info->{dbh}) {
              $self->connect_info($connection_info);
              $self->set_dbh($connection_info->{dbh});
          } else {
              $self->connect_info($connection_info);
              $self->reconnect;
          }
  
      } else {
          for my $key ( keys %unstorable_attribute ) {
              $self->attribute->{$key} = $unstorable_attribute{$key};
          }
      }
  
      return $self;
  }
  
  my $schema_checked = 0;
  sub schema { 
      my $attribute = $_[0]->attribute;
      my $schema = $attribute->{schema};
      if ( $attribute->{check_schema} && !$schema_checked ) {
          do {
              no strict 'refs';
              unless ( defined *{"@{[ $schema ]}::schema_info"} ) {
                  die "$schema is something wrong( is it really loaded? )";
              }
          };
          $schema_checked++;
      }
      return $schema;
  }
  
  sub profiler {
      my ($class, $sql, $bind) = @_;
      my $attr = $class->attribute;
      if ($attr->{profile} && $sql) {
          $attr->{profiler}->record_query($sql, $bind);
      }
      return $attr->{profiler};
  }
  
  #--------------------------------------------------------------------------------
  # for transaction
  sub txn_scope {
      DBIx::Skinny::Transaction->new( @_ );
  }
  
  sub txn_begin {
      my $class = shift;
      return if ( ++$class->attribute->{active_transaction} > 1 );
      $class->profiler("BEGIN WORK");
      eval { $class->dbh->begin_work } or Carp::croak $@;
  }
  
  sub txn_rollback {
      my $class = shift;
      return unless $class->attribute->{active_transaction};
  
      if ( $class->attribute->{active_transaction} == 1 ) {
          $class->profiler("ROLLBACK WORK");
          eval { $class->dbh->rollback } or Carp::croak $@;
          $class->txn_end;
      }
      elsif ( $class->attribute->{active_transaction} > 1 ) {
          $class->attribute->{active_transaction}--;
          $class->attribute->{rollbacked_in_nested_transaction}++;
      }
  
  }
  
  sub txn_commit {
      my $class = shift;
      return unless $class->attribute->{active_transaction};
  
      if ( $class->attribute->{rollbacked_in_nested_transaction} ) {
          Carp::croak "tried to commit but already rollbacked in nested transaction.";
      }
      elsif ( $class->attribute->{active_transaction} > 1 ) {
          $class->attribute->{active_transaction}--;
          return;
      }
  
      $class->profiler("COMMIT WORK");
      eval { $class->dbh->commit } or Carp::croak $@;
      $class->txn_end;
  }
  
  sub txn_end {
      $_[0]->attribute->{active_transaction} = 0;
      $_[0]->attribute->{rollbacked_in_nested_transaction} = 0;
  }
  
  #--------------------------------------------------------------------------------
  # db handling
  sub connect_info {
      my ($class, $connect_info) = @_;
  
      my $attr = $class->attribute;
      $attr->{dsn} = $connect_info->{dsn};
      $attr->{username} = $connect_info->{username};
      $attr->{password} = $connect_info->{password};
      $attr->{connect_options} = $connect_info->{connect_options};
  
      $class->setup_dbd($connect_info);
  }
  
  sub connect {
      my $class = shift;
  
      $class->connect_info(@_) if scalar @_ >= 1;
  
      my $attr = $class->attribute;
      my $do_connected;
      if ( !$attr->{dbh} ) {
          $do_connected++;
      }
      $attr->{dbh} ||= DBI->connect(
          $attr->{dsn},
          $attr->{username},
          $attr->{password},
          { RaiseError => 1, PrintError => 0, AutoCommit => 1, %{ $attr->{connect_options} || {} } }
      ) or Carp::croak("Connection error: " . $DBI::errstr);
  
      if ( $do_connected && $attr->{on_connect_do} ) {
          $class->do_on_connect;
      }
  
      $attr->{dbh};
  }
  
  sub reconnect {
      my $class = shift;
      $class->attribute->{dbh} = undef;
      $class->connect(@_);
  }
  
  sub do_on_connect {
      my $class = shift;
  
      my $on_connect_do = $class->attribute->{on_connect_do};
      if (not ref($on_connect_do)) {
          $class->do($on_connect_do);
      } elsif (ref($on_connect_do) eq 'CODE') {
          $on_connect_do->($class);
      } elsif (ref($on_connect_do) eq 'ARRAY') {
          $class->do($_) for @$on_connect_do;
      } else {
          Carp::croak('Invalid on_connect_do: '.ref($on_connect_do));
      }
  }
  
  sub set_dbh {
      my ($class, $dbh) = @_;
      $class->attribute->{dbh} = $dbh;
      $class->setup_dbd({dbh => $dbh});
  }
  
  sub setup_dbd {
      my ($class, $args) = @_;
      my $dbd_type = _dbd_type($args);
      $class->attribute->{dbd} = DBIx::Skinny::DBD->new($dbd_type);
  }
  
  sub dbd {
      $_[0]->attribute->{dbd} or do {
          require Data::Dumper;
          Carp::croak("attribute dbd does not exist. does it connected? attribute: @{[ Data::Dumper::Dumper($_[0]->attribute) ]}");
      };
  }
  
  sub dbh {
      my $class = shift;
  
      my $dbh = $class->connect;
      unless ($dbh && $dbh->FETCH('Active') && $dbh->ping) {
          $dbh = $class->reconnect;
      }
      $dbh;
  }
  
  sub _dbd_type {
      my $args = shift;
      my $dbd_type;
      if ($args->{dbh}) {
          $dbd_type = $args->{dbh}->{Driver}->{Name};
      } elsif ($args->{dsn}) {
          (undef, $dbd_type,) = DBI->parse_dsn($args->{dsn}) or Carp::croak "can't parse DSN: @{[ $args->{dsn} ]}";
      }
      return $dbd_type;
  }
  
  #--------------------------------------------------------------------------------
  # schema trigger call
  sub call_schema_trigger {
      my ($class, $trigger, $schema, $table, $args) = @_;
      $schema->call_trigger($class, $table, $trigger, $args);
  }
  
  #--------------------------------------------------------------------------------
  sub do {
      my ($class, $sql) = @_;
      $class->profiler($sql);
      eval { $class->dbh->do($sql) };
      if ($@) {
          $class->_stack_trace('', $sql, '', $@);
      }
  }
  
  sub count {
      my ($class, $table, $column, $where) = @_;
  
      my $rs = $class->resultset(
          {
              from   => [$table],
          }
      );
  
      $rs->add_select("COUNT($column)" =>  'cnt');
      $class->_add_where($rs, $where);
  
      $rs->retrieve->first->cnt;
  }
  
  sub resultset {
      my ($class, $args) = @_;
      $args->{skinny} = $class;
      my $query_builder_class = $class->dbd->query_builder_class;
      $query_builder_class->new($args);
  }
  
  sub search {
      my ($class, $table, $where, $opt) = @_;
  
      my $cols = $opt->{select};
      unless ($cols) {
          my $column_info = $class->schema->schema_info->{$table};
          unless ( $column_info ) {
              Carp::croak("schema_info does not exist for table '$table'");
          }
          $cols = $column_info->{columns};
      }
      my $rs = $class->resultset(
          {
              select => $cols,
              from   => [$table],
          }
      );
  
      if ( $where ) {
          $class->_add_where($rs, $where);
      }
  
      $rs->limit(  $opt->{limit}  ) if $opt->{limit};
      $rs->offset( $opt->{offset} ) if $opt->{offset};
  
      if (my $terms = $opt->{order_by}) {
          $terms = [$terms] unless ref($terms) eq 'ARRAY';
          my @orders;
          for my $term (@{$terms}) {
              my ($col, $case);
              if (ref($term) eq 'HASH') {
                  ($col, $case) = each %$term;
              } else {
                  $col  = $term;
                  $case = 'ASC';
              }
              push @orders, { column => $col, desc => $case };
          }
          $rs->order(\@orders);
      }
  
      if (my $terms = $opt->{having}) {
          for my $col (keys %$terms) {
              $rs->add_having($col => $terms->{$col});
          }
      }
  
      $rs->retrieve;
  }
  
  sub single {
      my ($class, $table, $where, $opt) = @_;
      $opt->{limit} = 1;
      $class->search($table, $where, $opt)->first;
  }
  
  sub search_named {
      my ($class, $sql, $args, $opts, $opt_table_info) = @_;
  
      $sql = sprintf($sql, @{$opts||[]});
      my %named_bind = %{$args};
      my @bind;
      $sql =~ s{:([A-Za-z_][A-Za-z0-9_]*)}{
          Carp::croak("$1 does not exists in hash") if !exists $named_bind{$1};
          if ( ref $named_bind{$1} && ref $named_bind{$1} eq "ARRAY" ) {
              push @bind, @{ $named_bind{$1} };
              my $tmp = join ',', map { '?' } @{ $named_bind{$1} };
              "( $tmp )";
          } else {
              push @bind, $named_bind{$1};
              '?'
          }
      }ge;
  
      $class->search_by_sql($sql, \@bind, $opt_table_info);
  }
  
  sub search_by_sql {
      my ($class, $sql, $bind, $opt_table_info) = @_;
  
      my $sth = $class->_execute($sql, $bind);
      return $class->_get_sth_iterator($sql, $sth, $opt_table_info);
  }
  
  sub find_or_new {
      my ($class, $table, $args) = @_;
      my $row = $class->single($table, $args);
      unless ($row) {
          $row = $class->data2itr($table, [$args])->first;
      }
      return $row;
  }
  
  sub _get_sth_iterator {
      my ($class, $sql, $sth, $opt_table_info) = @_;
  
      return DBIx::Skinny::Iterator->new(
          skinny         => $class,
          sth            => $sth,
          row_class      => $class->_mk_row_class($sql, $opt_table_info),
          opt_table_info => $opt_table_info
      );
  }
  
  sub data2itr {
      my ($class, $table, $data) = @_;
  
      return DBIx::Skinny::Iterator->new(
          skinny         => $class,
          data           => $data,
          row_class      => $class->_mk_row_class($table.$data, $table),
          opt_table_info => $table,
      );
  }
  
  my $base_row_class;
  sub _mk_anon_row_class {
      my ($class, $key) = @_;
  
      my $row_class = 'DBIx::Skinny::Row::C';
      $row_class .= Digest::SHA1::sha1_hex($key);
  
      my $attr = $class->attribute;
      $attr->{base_row_class} ||= do {
          my $tmp_base_row_class = join '::', $attr->{klass}, 'Row';
          eval "use $tmp_base_row_class"; ## no critic
          (my $rc = $tmp_base_row_class) =~ s|::|/|g;
          die $@ if $@ && $@ !~ /Can't locate $rc\.pm in \@INC/;
  
          if ($@) {
              'DBIx::Skinny::Row';
          } else {
              $tmp_base_row_class;
          }
      };
      { no strict 'refs'; @{"$row_class\::ISA"} = ($attr->{base_row_class}); }
  
      return $row_class;
  }
  
  sub _guess_table_name {
      my ($class, $sql) = @_;
  
      if ($sql =~ /^.+from\s+([\w]+)\s*/i) {
          return $1;
      }
      return;
  }
  
  sub _mk_row_class {
      my ($class, $key, $table) = @_;
  
      $table ||= $class->_guess_table_name($key)||'';
      my $attr = $class->attribute;
      my $base_row_class = $attr->{row_class_map}->{$table}||'';
  
      if ( $base_row_class eq 'DBIx::Skinny::Row' ) {
          return $class->_mk_anon_row_class($key);
      } elsif ($base_row_class) {
          return $base_row_class;
      } elsif ($table) {
          my $tmp_base_row_class = join '::', $attr->{klass}, 'Row', _camelize($table);
          eval "use $tmp_base_row_class"; ## no critic
          (my $rc = $tmp_base_row_class) =~ s|::|/|g;
          die $@ if $@ && $@ !~ /Can't locate $rc\.pm in \@INC/;
  
          if ($@) {
              $attr->{row_class_map}->{$table} = 'DBIx::Skinny::Row';
              return $class->_mk_anon_row_class($key);
          } else {
              $attr->{row_class_map}->{$table} = $tmp_base_row_class;
              return $tmp_base_row_class;
          }
      } else {
          return $class->_mk_anon_row_class($key);
      }
  }
  
  sub _camelize {
      my $s = shift;
      join('', map{ ucfirst $_ } split(/(?<=[A-Za-z])_(?=[A-Za-z])|\b/, $s));
  }
  
  sub _quote {
      my ($label, $quote, $name_sep) = @_;
  
      return $label if $label eq '*';
      return $quote . $label . $quote if !defined $name_sep;
      return join $name_sep, map { $quote . $_ . $quote } split /\Q$name_sep\E/, $label;
  }
  
  sub bind_params {
      my($class, $table, $columns, $sth) = @_;
  
      my $schema = $class->schema;
      my $dbd    = $class->dbd;
      my $i = 1;
      for my $column (@{ $columns }) {
          my($col, $val) = @{ $column };
          my $type = $schema->column_type($table, $col);
          my $attr = $type ? $dbd->bind_param_attributes($type) : undef;
          $sth->bind_param($i++, $val, $attr);
      }
  }
  
  sub _insert_or_replace {
      my ($class, $is_replace, $table, $args) = @_;
  
      my $schema = $class->schema;
  
      # deflate
      for my $col (keys %{$args}) {
          $args->{$col} = $schema->call_deflate($col, $args->{$col});
      }
  
      my (@cols, @column_list);
      for my $col (keys %{ $args }) {
          push @cols, $col;
          push @column_list, [$col, $schema->utf8_off($col, $args->{$col})];
      }
  
      my $dbd = $class->dbd;
      my $quote = $dbd->quote;
      my $name_sep = $dbd->name_sep;
      my $sql = $is_replace ? 'REPLACE' : 'INSERT';
      $sql .= " INTO $table\n";
      $sql .= '(' . join(', ', map {_quote($_, $quote, $name_sep)} @cols) . ')' . "\n" .
              'VALUES (' . join(', ', ('?') x @cols) . ')' . "\n";
  
      my $sth = $class->_execute($sql, \@column_list, $table);
  
      my $pk = $class->schema->schema_info->{$table}->{pk};
      my $id = defined $args->{$pk} ? $args->{$pk} :
               (ref $pk) eq 'ARRAY' ? undef        : $dbd->last_insert_id($class->dbh, $sth, { table => $table });
      $class->_close_sth($sth);
  
      if ($id) {
          $args->{$pk} = $id;
      }
  
      my $row_class = $class->_mk_row_class($sql, $table);
      my $obj = $row_class->new(
          {
              row_data       => $args,
              skinny         => $class,
              opt_table_info => $table,
          }
      );
      $obj->setup;
  
      $obj;
  }
  
  *create = \*insert;
  sub insert {
      my ($class, $table, $args) = @_;
  
      my $schema = $class->schema;
      $class->call_schema_trigger('pre_insert', $schema, $table, $args);
  
      my $obj = $class->_insert_or_replace(0, $table, $args);
  
      $class->call_schema_trigger('post_insert', $schema, $table, $obj);
  
      $obj;
  }
  
  sub replace {
      my ($class, $table, $args) = @_;
  
      my $schema = $class->schema;
      $class->call_schema_trigger('pre_insert', $schema, $table, $args);
  
      my $obj = $class->_insert_or_replace(1, $table, $args);
  
      $class->call_schema_trigger('post_insert', $schema, $table, $obj);
  
      $obj;
  }
  
  sub bulk_insert {
      my ($class, $table, $args) = @_;
  
      my $code = $class->attribute->{dbd}->can('bulk_insert') or Carp::croak "dbd don't provide bulk_insert method";
      $code->($class, $table, $args);
  }
  
  sub update {
      my ($class, $table, $args, $where) = @_;
  
      my $schema = $class->schema;
      $class->call_schema_trigger('pre_update', $schema, $table, $args);
  
      # deflate
      my $values = {};
      for my $col (keys %{$args}) {
          $values->{$col} = $schema->call_deflate($col, $args->{$col});
      }
  
      my $quote = $class->dbd->quote;
      my $name_sep = $class->dbd->name_sep;
      my (@set, @column_list);
      for my $col (keys %{ $args }) {
          my $quoted_col = _quote($col, $quote, $name_sep);
          if (ref($values->{$col}) eq 'SCALAR') {
              push @set, "$quoted_col = " . ${ $values->{$col} };
          } else {
              push @set, "$quoted_col = ?";
              push @column_list, [$col, $schema->utf8_off($col, $values->{$col})];
          }
      }
  
      my $stmt = $class->resultset;
      $class->_add_where($stmt, $where);
      my @where_values = map {[$_ => $stmt->where_values->{$_}]} @{$stmt->bind_col};
      push @column_list, @where_values;
  
      my $sql = "UPDATE $table SET " . join(', ', @set) . ' ' . $stmt->as_sql_where;
  
      my $sth = $class->_execute($sql, \@column_list, $table);
      my $rows = $sth->rows;
  
      $class->_close_sth($sth);
      $class->call_schema_trigger('post_update', $schema, $table, $rows);
  
      return $rows;
  }
  
  sub update_by_sql {
      my ($class, $sql, $bind) = @_;
  
      my $sth = $class->_execute($sql, $bind);
      my $rows = $sth->rows;
      $class->_close_sth($sth);
  
      $rows;
  }
  
  sub delete {
      my ($class, $table, $where) = @_;
  
      my $schema = $class->schema;
      $class->call_schema_trigger('pre_delete', $schema, $table, $where);
  
      my $stmt = $class->resultset(
          {
              from => [$table],
          }
      );
  
      $class->_add_where($stmt, $where);
  
      my $sql = "DELETE " . $stmt->as_sql;
      my @where_values = map {[$_ => $stmt->where_values->{$_}]} @{$stmt->bind_col};
      my $sth = $class->_execute($sql, \@where_values, $table);
      my $rows = $sth->rows;
  
      $class->call_schema_trigger('post_delete', $schema, $table, $rows);
  
      $class->_close_sth($sth);
      $rows;
  }
  
  sub delete_by_sql {
      my ($class, $sql, $bind) = @_;
  
      my $sth = $class->_execute($sql, $bind);
      my $rows = $sth->rows;
  
      $class->_close_sth($sth);
  
      $rows;
  }
  
  *find_or_insert = \*find_or_create;
  sub find_or_create {
      my ($class, $table, $args) = @_;
      my $row = $class->single($table, $args);
      return $row if $row;
      $row = $class->insert($table, $args);
      my $pk = $class->schema->schema_info->{$table}->{pk};
      $class->single($table, { $pk => $row->get_column($pk) });
  }
  
  sub _add_where {
      my ($class, $stmt, $where) = @_;
      for my $col (keys %{$where}) {
          $stmt->add_where($col => $where->{$col});
      }
  }
  
  sub _execute {
      my ($class, $stmt, $args, $table) = @_;
  
  use Data::Dumper;
  
      my ($sth, $bind);
      if ($table) {
          $bind = [map {$_->[1]} @$args];
          $class->profiler($stmt, $bind);
          eval {
              $sth = $class->dbh->prepare($stmt);
              $class->bind_params($table, $args, $sth);
              $sth->execute;
          };
      } else {
          $bind = $args;
          $class->profiler($stmt, $bind);
          eval {
              $sth = $class->dbh->prepare($stmt);
              $sth->execute(@{$args});
          };
      }
  
      if ($@) {
          $class->_stack_trace($sth, $stmt, $bind, $@);
      }
      return $sth;
  }
  
  # stack trace
  sub _stack_trace {
      my ($class, $sth, $stmt, $bind, $reason) = @_;
      require Data::Dumper;
  
      if ($sth) {
          $class->_close_sth($sth);
      }
  
      $stmt =~ s/\n/\n          /gm;
      Carp::croak sprintf <<"TRACE", $reason, $stmt, Data::Dumper::Dumper($bind);
  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  @@@@@ DBIx::Skinny 's Exception @@@@@
  Reason  : %s
  SQL     : %s
  BIND    : %s
  @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
  TRACE
  }
  
  sub _close_sth {
      my ($class, $sth) = @_;
      $sth->finish;
      undef $sth;
  }
  
  1;
  
  __END__
  =head1 NAME
  
  DBIx::Skinny - simple DBI wrapper/ORMapper
  
  =head1 SYNOPSIS
  
  create your db model base class.
  
      package Your::Model;
      use DBIx::Skinny setup => {
          dsn => 'dbi:SQLite:',
          username => '',
          password => '',
      };
      1;
      
  create your db schema class.
  See DBIx::Skinny::Schema for docs on defining schema class.
  
      package Your::Model::Schema;
      use DBIx::Skinny::Schema;
      
      install_table user => schema {
          pk 'id';
          columns qw/
              id
              name
          /;
      };
      1;
      
  in your execute script.
  
      use Your::Model;
      
      # insert new record.
      my $row = Your::Model->insert('user',
          {
              id   => 1,
          }
      );
      $row->update({name => 'nekokak'});
  
      $row = Your::Model->search_by_sql(q{SELECT id, name FROM user WHERE id = ?}, [ 1 ]);
      $row->delete('user')
  
  =head1 DESCRIPTION
  
  DBIx::Skinny is simple DBI wrapper and simple O/R Mapper.
  Lightweight and Little dependence ORM.
  The Row objects is generated based on arbitrarily SQL. 
  
  =head1 METHOD
  
  =head2 new
  
  Arguments: $connection_info
  Return: DBIx::Skinny's instance object.
  
  create your skinny instance.
  It is possible to use it even by the class method.
  
  $connection_info is optional argment.
  
  When $connection_info is specified,
  new method connect new DB connection from $connection_info.
  
  When $connection_info is not specified,
  it becomes use already setup connection or it doesn't do at all.
  
  example:
  
      my $db = Your::Model->new;
  
  or
  
      # connect new database connection.
      my $db = Your::Model->new(+{
          dsn      => $dsn,
          username => $username,
          password => $password,
          connect_options => $connect_options,
      });
  
  =head2 insert
  
  Arguments: $table_name, \%row_data
  Return: DBIx::Skinny::Row's instance object.
  
  insert new record and get inserted row object.
  
  example:
  
      my $row = Your::Model->insert('user',{
          id   => 1,
          name => 'nekokak',
      });
  
  or
  
      my $db = Your::Model->new;
      my $row = $db->insert('user',{
          id   => 1,
          name => 'nekokak',
      });
  
  =head2 create
  
  insert method alias.
  
  =head2 bulk_insert
  
  Arguments: $table_name, \@row_datas
  Return: true
  
  Accepts either an arrayref of hashrefs.
  each hashref should be a structure suitable
  forsubmitting to a Your::Model->insert(...) method.
  
  insert many record by bulk.
  
  example:
  
      Your::Model->bulk_insert('user',[
          {
              id   => 1,
              name => 'nekokak',
          },
          {
              id   => 2,
              name => 'yappo',
          },
          {
              id   => 3,
              name => 'walf443',
          },
      ]);
  
  =head2 update
  
  Arguments: $table_name, \%update_row_data, \%update_condition
  Return: updated row count
  
  $update_condition is optional argment.
  
  update record.
  
  example:
  
      my $update_row_count = Your::Model->update('user',{
          name => 'nomaneko',
      },{ id => 1 });
  
  or 
  
      # see) DBIx::Skinny::Row's POD
      my $row = Your::Model->single('user',{id => 1});
      $row->update({name => 'nomaneko'});
  
  =head2 update_by_sql
  
  Arguments: $sql, \@bind_values
  Return: updated row count
  
  update record by specific sql.
  
  example:
      my $update_row_count = Your::Model->update_by_sql(
          q{UPDATE user SET name = ?},
          ['nomaneko']
      );
  
  =head2 delete
  
  Arguments: $table, \%delete_where_condition
  Return: updated row count
  
  delete record.
  
  example:
  
      my $delete_row_count = Your::Model->delete('user',{
          id => 1,
      });
  
  or
  
      # see) DBIx::Skinny::Row's POD
      my $row = Your::Model->single('user', {id => 1});
      $row->delete
  
  =head2 delete_by_sql
  
  Arguments: $sql, \@bind_values
  Return: updated row count
  
  delete record by specific sql.
  
  example:
  
      my $delete_row_count = Your::Model->delete_by_sql(
          q{DELETE FROM user WHERE id = ?},
          [1]
      });
  
  =head2 find_or_create
  
  Arguments: $table, \%values_and_search_condition
  Return: DBIx::Skinny::Row's instance object.
  
  create record if not exsists record.
  
  example:
  
      my $row = Your::Model->find_or_create('usr',{
          id   => 1,
          name => 'nekokak',
      });
  
  =head2 find_or_insert
  
  find_or_create method alias.
  
  =head2 search
  
  Arguments: $table, \%search_condition, \%search_attr
  Return: DBIx::Skinny::Iterator's instance object.
  
  simple search method.
  search method get DBIx::Skinny::Iterator's instance object.
  
  see L<DBIx::Skinny::Iterator>
  
  get iterator:
  
      my $itr = Your::Model->search('user',{id => 1},{order_by => 'id'});
  
  get rows:
  
      my @rows = Your::Model->search('user',{id => 1},{order_by => 'id'});
  
  Please refer to L<DBIx::Skinny::Manual> for the details of search method.
  
  =head2 single
  
  Arguments: $table, \%search_condition
  Return: DBIx::Skinny::Row's instance object.
  
  get one record.
  give back one case of the beginning when it is acquired plural records by single method.
  
      my $row = Your::Model->single('user',{id =>1});
  
  =head2 resultset
  
  Arguments: \%options
  Return: DBIx::Skinny::SQL's instance object.
  
  result set case:
  
      my $rs = Your::Model->resultset(
          {
              select => [qw/id name/],
              from   => [qw/user/],
          }
      );
      $rs->add_where('name' => {op => 'like', value => "%neko%"});
      $rs->limit(10);
      $rs->offset(10);
      $rs->order({ column => 'id', desc => 'DESC' });
      my $itr = $rs->retrieve;
  
  Please refer to L<DBIx::Skinny::Manual> for the details of resultset method.
  
  =head2 count
  
  get simple count
  
      my $cnt = Your::Model->count('user', 'id');
  
  =head2 search_named
  
  execute named query
  
      my $itr = Your::Model->search_named(q{SELECT * FROM user WHERE id = :id}, {id => 1});
  
  If you give ArrayRef to value, that is expanded to "(?,?,?,?)" in SQL.
  It's useful in case use IN statement.
  
      my $itr = Your::Model->search_named(q{SELECT * FROM user WHERE id IN :ids}, {id => [1, 2, 3]});
  
  =head2 search_by_sql
  
  execute your SQL
  
      my $itr = Your::Model->search_by_sql(q{
          SELECT
              id, name
          FROM
              user
          WHERE
              id = ?
      },[ 1 ]);
  
  =head2 txn_scope
  
  get transaction scope object.
  
      do {
          my $txn = Your::Model->txn_scope;
          # some process
          $txn->commit;
      }
  
  =head2 data2itr
  
      my $itr = Your::Model->data2itr('user',[
          {
              id   => 1,
              name => 'nekokak',
          },
          {
              id   => 2,
              name => 'yappo',
          },
          {
              id   => 3,
              name => 'walf43',
          },
      ]);
  
      my $row = $itr->first;
      $row->insert; # inser data.
  
  =head2 find_or_new
  
      my $row = Your::Model->find_or_new('user',{name => 'nekokak'});
  
  =head2 do
  
  execute your query.
  
  =head2 dbh
  
  get database handle.
  
  =head2 connect
  
  connect database handle.
  
  =head2 reconnect
  
  re connect database handle.
  
  =head1 BUGS AND LIMITATIONS
  
  No bugs have been reported.
  
  =head1 AUTHOR
  
  Atsushi Kobayashi  C<< <nekokak __at__ gmail.com> >>
  
  =head1 CONTRIBUTORS
  
  walf443 : Keiji Yoshimi
  
  TBONE : Terrence Brannon
  
  nekoya : Ryo Miyake
  
  oinume: Kazuhiro Oinuma
  
  fujiwara: Shunichiro Fujiwara
  
  pjam: Tomoyuki Misonou
  
  magicalhat
  
  Makamaka Hannyaharamitu
  
  =head1 SUPPORT
  
    irc: #dbix-skinny@irc.perl.org
  
    ML: http://groups.google.com/group/dbix-skinny
  
  =head1 REPOSITORY
  
    git clone git://github.com/nekokak/p5-dbix-skinny.git  
  
  =head1 LICENCE AND COPYRIGHT
  
  Copyright (c) 2009, Atsushi Kobayashi C<< <nekokak __at__ gmail.com> >>. All rights reserved.
  
  This module is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself. See L<perlartistic>.
  
DBIX_SKINNY

$fatpacked{"DBIx/Skinny/Accessor.pm"} = <<'DBIX_SKINNY_ACCESSOR';
  package DBIx::Skinny::Accessor;
  use strict;
  use warnings;
  
  sub import {
      my $caller = caller;
  
      {
          no strict 'refs';
          *{"$caller\::new"} = \&_new;
          *{"$caller\::mk_accessors"} = \&_mk_accessors;
      }
  }
  
  sub _new {
      my ($class, $args) = @_;
      $args ||= {};
      my $self = bless {%$args}, $class;
  
      if ( $class->can('init') ) {
          $self->init;
      }
  
      return $self;
  }
  
  sub _mk_accessors {
      my $caller = caller;
  
      {
          no strict 'refs';
          for my $n (@_) {
              *{"$caller\::$n"} = __m($n);
          }
      }
  }
  
  sub __m {
      my $n = shift;
      sub {
          return $_[0]->{$n} if @_ == 1;
          return $_[0]->{$n} = $_[1] if @_ == 2;
          shift->{$n} = \@_;
      };
  }
  
  'base code from Class::Accessor::Lite';
DBIX_SKINNY_ACCESSOR

$fatpacked{"DBIx/Skinny/DBD.pm"} = <<'DBIX_SKINNY_DBD';
  package DBIx::Skinny::DBD;
  use strict;
  use warnings;
  
  sub new {
      my ($class, $dbd_type) =@_;
      die "No Driver" unless $dbd_type;
  
      my $subclass = join '::', $class, $dbd_type;
      eval "use $subclass"; ## no critic
      die $@ if $@;
      bless {}, $subclass;
  }
  
  1;
  
DBIX_SKINNY_DBD

$fatpacked{"DBIx/Skinny/DBD/Base.pm"} = <<'DBIX_SKINNY_DBD_BASE';
  package DBIx::Skinny::DBD::Base;
  use strict;
  use warnings;
  use DBIx::Skinny::SQL;
  
  sub last_insert_id { $_[1]->func('last_insert_rowid') }
  
  sub sql_for_unixtime { time() }
  
  sub quote    { '`' }
  sub name_sep { '.' }
  
  sub bulk_insert {
      my ($skinny, $table, $args) = @_;
  
      my $txn; $txn = $skinny->txn_scope unless $skinny->attribute->{active_transaction} != 0;
  
          for my $arg ( @{$args} ) {
              $skinny->_insert_or_replace(0, $table, $arg);
          }
  
      $txn->commit if $txn;
  
      return 1;
  }
  
  sub query_builder_class { 'DBIx::Skinny::SQL' }
  sub bind_param_attributes {}
  
  1;
  
DBIX_SKINNY_DBD_BASE

$fatpacked{"DBIx/Skinny/DBD/Oracle.pm"} = <<'DBIX_SKINNY_DBD_ORACLE';
  package DBIx::Skinny::DBD::Oracle;
  use strict;
  use warnings;
  use base 'DBIx::Skinny::DBD::Base';
  use DBIx::Skinny::SQL::Oracle;
  
  sub last_insert_id { return }
  
  sub sql_for_unixtime {
      "(cast(SYS_EXTRACT_UTC(current_timestamp) as date) - date '1900-01-01') * 24 * 60 * 60";
  }
  
  sub quote    { '"' }
  sub name_sep { '.' }
  sub query_builder_class { 'DBIx::Skinny::SQL::Oracle' }
  
  1;
DBIX_SKINNY_DBD_ORACLE

$fatpacked{"DBIx/Skinny/DBD/Pg.pm"} = <<'DBIX_SKINNY_DBD_PG';
  package DBIx::Skinny::DBD::Pg;
  use strict;
  use warnings;
  use base 'DBIx::Skinny::DBD::Base';
  
  sub last_insert_id {
      my ($self, $dbh, $sth, $args) = @_;
      $dbh->last_insert_id(undef, undef, $args->{table}, undef);
  }
  
  sub sql_for_unixtime { "TRUNC(EXTRACT('epoch' from NOW()))" }
  
  sub quote    { '"' }
  sub name_sep { '.' }
  
  1;
  
DBIX_SKINNY_DBD_PG

$fatpacked{"DBIx/Skinny/DBD/SQLite.pm"} = <<'DBIX_SKINNY_DBD_SQLITE';
  package DBIx::Skinny::DBD::SQLite;
  use strict;
  use warnings;
  use base 'DBIx::Skinny::DBD::Base';
  
  sub bind_param_attributes {
      my($self, $data_type) = @_;
  
      if ($data_type) {
          if ($data_type =~ /blob/i || $data_type =~ /bin/i || $data_type =~ /\Abigint\Z/i) {
              return DBI::SQL_BLOB;
          }
      }
      return;
  }
  
  1;
  
DBIX_SKINNY_DBD_SQLITE

$fatpacked{"DBIx/Skinny/DBD/mysql.pm"} = <<'DBIX_SKINNY_DBD_MYSQL';
  package DBIx::Skinny::DBD::mysql;
  use strict;
  use warnings;
  use base 'DBIx::Skinny::DBD::Base';
  
  sub last_insert_id {
      $_[1]->{mysql_insertid} || $_[1]->{insertid}
  }
  
  sub sql_for_unixtime { "UNIX_TIMESTAMP()" }
  
  sub bulk_insert {
      my ($skinny, $table, $args) = @_;
  
      my (@cols, @bind);
      for my $arg (@{$args}) {
          # deflate
          for my $col (keys %{$arg}) {
              $arg->{$col} = $skinny->schema->call_deflate($col, $arg->{$col});
          }
  
          if (scalar(@cols)==0) {
              for my $col (keys %{$arg}) {
                  push @cols, $col;
              }
          }
  
          for my $col (keys %{$arg}) {
              push @bind, $skinny->schema->utf8_off($col, $arg->{$col});
          }
      }
  
      my $sql = "INSERT INTO $table\n";
      $sql .= '(' . join(', ', @cols) . ')' . "\nVALUES ";
  
      my $values = '(' . join(', ', ('?') x @cols) . ')' . "\n";
      $sql .= join(',', ($values) x (scalar(@bind) / scalar(@cols)));
  
      $skinny->_execute($sql, \@bind);
  
      return 1;
  }
  
  1;
  
DBIX_SKINNY_DBD_MYSQL

$fatpacked{"DBIx/Skinny/Iterator.pm"} = <<'DBIX_SKINNY_ITERATOR';
  package DBIx::Skinny::Iterator;
  use strict;
  use warnings;
  use Scalar::Util qw(blessed);
  
  sub new {
      my ($class, %args) = @_;
  
      my $self = bless \%args, $class;
      $self->{_use_cache} = 1;
  
      $self->reset;
  
      return wantarray ? $self->all : $self;
  }
  
  sub iterator {
      my $self = shift;
  
      my $position = $self->{_position} + 1;
      if ( $self->{_use_cache}
        && ( my $row_cache = $self->{_rows_cache}->[$position] ) ) {
          $self->{_position} = $position;
          return $row_cache;
      }
  
      my $row;
      if ($self->{sth}) {
          $row = $self->{sth}->fetchrow_hashref('NAME_lc');
          unless ( $row ) {
              $self->{skinny}->_close_sth($self->{sth});
              $self->{sth} = undef;
              return;
          }
      } elsif ($self->{data} && ref $self->{data} eq 'ARRAY') {
          $row = shift @{$self->{data}};
          unless ( $row ) {
              return;
          }
      } else {
          return;
      }
  
      return $row if Scalar::Util::blessed($row);
  
      my $obj = $self->{row_class}->new(
          {
              row_data       => $row,
              skinny         => $self->{skinny},
              opt_table_info => $self->{opt_table_info},
          }
      );
  
      unless ($self->{_setup}) {
          $obj->setup;
          $self->{_setup}=1;
      }
  
      $self->{_rows_cache}->[$position] = $obj if $self->{_use_cache};
      $self->{_position} = $position;
  
      return $obj;
  }
  
  sub first {
      my $self = shift;
      $self->reset;
      $self->next;
  }
  
  sub next { shift->iterator }
  
  sub all {
      my $self = shift;
      my @result;
      while ( my $row = $self->next ) {
          push @result, $row;
      }
      return @result;
  }
  
  sub reset {
      my $self = shift;
      $self->{_position} = 0;
      return $self;
  }
  
  sub count {
      my $self = shift;
      my @rows = $self->reset->all;
      $self->reset;
      scalar @rows;
  }
  
  sub no_cache {
      my $self = shift;
      $self->{_use_cache} = 0;
  }
  
  1;
  
  __END__
  =head1 NAME
  
  DBIx::Skinny::Iterator
  
  =head1 DESCRIPTION
  
  skinny iteration class.
  
  =head1 SYNOPSIS
  
    my $itr = Your::Model->search('user',{});
    
    $itr->count; # show row counts
    
    my $row = $itr->first; # get first row
    
    $itr->reset; # reset itarator potision
    
    my @rows = $itr->all; # get all rows
    
    # do iteration
    while (my $row = $itr->next) { }
  
    # no cache row object (save memories)
    $itr->no_cache;
    while (my $row = $itr->next) { }
    $itr->reset->first;  # Can't fetch row!
  
DBIX_SKINNY_ITERATOR

$fatpacked{"DBIx/Skinny/Mixin.pm"} = <<'DBIX_SKINNY_MIXIN';
  package DBIx::Skinny::Mixin;
  use strict;
  use warnings;
  use Carp ();
  
  sub import {
      my($class, %args) = @_;
      Carp::croak "Usage: use DBIx::Skinny::Mixin modules => ['MixinModuleName', 'MixinModuleName2', .... ]"
          unless $args{modules} && ref($args{modules}) eq 'ARRAY';
  
      my $caller = caller;
      for my $module (@{ $args{modules} }) {
          my $pkg = $module;
          $pkg = __PACKAGE__ . "::$pkg" unless $pkg =~ s/^\+//;
  
          eval "use $pkg"; ## no critic
          if ($@) {
              Carp::croak $@;
          }
  
          my $register_methods = $pkg->register_method;
          while (my($method, $code) = each %{ $register_methods }) {
              no strict 'refs';
              *{"$caller\::$method"} = $code;
          }
      }
  }
  
  1;
  
  =head1 NAME
  
  DBIx::Skinny::Mixin - mixin manager for DBIx::Skinny
  
  =head1 SYNOPSIS
  
    use DBIx::Skinny::Mixin modules => ['mixin_module_names'];
  
  =cut
  
DBIX_SKINNY_MIXIN

$fatpacked{"DBIx/Skinny/Profiler.pm"} = <<'DBIX_SKINNY_PROFILER';
  package DBIx::Skinny::Profiler;
  use strict;
  use warnings;
  use DBIx::Skinny::Accessor;
  
  mk_accessors(qw/ query_log /);
  
  sub init {
      my $self = shift;
      $self->reset;
  }
  
  sub reset {
      my $self = shift;
      $self->query_log([]);
  }
  
  sub _normalize {
      my $sql = shift;
      $sql =~ s/^\s*//;
      $sql =~ s/\s*$//;
      $sql =~ s/[\r\n]/ /g;
      $sql =~ s/\s+/ /g;
      return $sql;
  }
  
  sub record_query {
      my ($self, $sql, $bind) = @_;
  
      my $log = _normalize($sql);
      if (ref $bind eq 'ARRAY') {
          my @binds;
          push @binds, defined $_ ? $_ : 'undef' for @$bind;
          $log .= ' :binds ' . join ', ', @binds;
      }
  
      push @{ $self->query_log }, $log;
  }
  
  1;
  
DBIX_SKINNY_PROFILER

$fatpacked{"DBIx/Skinny/Profiler/Trace.pm"} = <<'DBIX_SKINNY_PROFILER_TRACE';
  package DBIx::Skinny::Profiler::Trace;
  use strict;
  use warnings;
  use IO::Handle;
   
  sub new {
      my $class = shift;
   
      my $self = bless {}, $class;
      my $env = $ENV{SKINNY_TRACE};
   
      my $fh;
      if ( $env && $env =~ /=(.+)$/ ) {
          my $fname = $1;
          open( $fh, '>>', $fname ) or die("cannot open '$fname': $!");
      }
      else {
          $fh = *STDERR;
      }
   
      autoflush $fh;
  
      $self->{fh} = $fh;
  
      $self;
  }
   
  sub record_query {
      my ( $self, $sql, $bind ) = @_;
      my $log = _normalize($sql);
   
      if ( ref $bind eq 'ARRAY' ) {
          my @binds;
          push @binds, defined $_ ? $_ : 'undef' for @$bind;
          $log .= ' :binds ' . join ', ', @binds;
      }
   
      my $fh = $self->{fh};
      print $fh $log, "\n";
  }
   
  sub _normalize { # copied from origianl DBIx::Skinny::Profiler
      my $sql = shift;
      $sql =~ s/^\s*//;
      $sql =~ s/\s*$//;
      $sql =~ s/[\r\n]/ /g;
      $sql =~ s/\s+/ /g;
      return $sql;
  }
   
  1;
DBIX_SKINNY_PROFILER_TRACE

$fatpacked{"DBIx/Skinny/Row.pm"} = <<'DBIX_SKINNY_ROW';
  package DBIx::Skinny::Row;
  use strict;
  use warnings;
  use Carp qw//;
  
  sub new {
      my ($class, $args) = @_;
      my $self = bless {%$args}, $class;
      $self->{select_columns} = [keys %{$self->{row_data}}];
      return $self;
  }
  
  sub setup {
      my $self = shift;
      my $class = ref $self;
  
      for my $alias ( @{$self->{select_columns}} ) {
          (my $col = lc $alias) =~ s/.+\.(.+)/$1/o;
          next if $class->can($col);
          no strict 'refs';
          *{"$class\::$col"} = $self->_lazy_get_data($col);
      }
  
      $self->{_get_column_cached} = {};
      $self->{_dirty_columns} = {};
  }
  
  sub _lazy_get_data {
      my ($self, $col) = @_;
  
      return sub {
          my $self = shift;
  
          unless ( $self->{_get_column_cached}->{$col} ) {
            my $data = $self->get_column($col);
            $self->{_get_column_cached}->{$col} = $self->{skinny}->schema->call_inflate($col, $data);
          }
          $self->{_get_column_cached}->{$col};
      };
  }
  
  sub get_column {
      my ($self, $col) = @_;
  
      unless ( $col ) {
          Carp::croak('please specify $col for first argument');
      }
  
      my $data = exists $self->{row_data}->{$col} ? $self->{row_data}->{$col} : Carp::croak("$col no selected column.");
  
      return $self->{skinny}->schema->utf8_on($col, $data);
  }
  
  sub get_columns {
      my $self = shift;
  
      my %data;
      for my $col ( @{$self->{select_columns}} ) {
          $data{$col} = $self->get_column($col);
      }
      return \%data;
  }
  
  sub set {
      my ($self, $args) = @_;
  
      for my $col (keys %$args) {
          $self->{row_data}->{$col} = $self->{skinny}->schema->call_deflate($col, $args->{$col});
          $self->{_get_column_cached}->{$col} = $args->{$col};
          $self->{_dirty_columns}->{$col} = 1;
      }
  }
  
  sub get_dirty_columns {
      my $self = shift;
      my %rows = map {$_ => $self->get_column($_)}
                 keys %{$self->{_dirty_columns}};
      return \%rows;
  }
  
  sub insert {
      my $self = shift;
      $self->{skinny}->find_or_create($self->{opt_table_info}, $self->get_columns);
  }
  
  sub update {
      my ($self, $args, $table) = @_;
      $table ||= $self->{opt_table_info};
      $args ||= $self->get_dirty_columns;
      my $where = $self->_update_or_delete_cond($table);
      my $result = $self->{skinny}->update($table, $args, $where);
      $self->set($args);
      return $result;
  }
  
  sub delete {
      my ($self, $table) = @_;
      $table ||= $self->{opt_table_info};
      my $where = $self->_update_or_delete_cond($table);
      $self->{skinny}->delete($table, $where);
  }
  
  sub _update_or_delete_cond {
      my ($self, $table) = @_;
  
      unless ($table) {
          Carp::croak "no table info";
      }
  
      my $schema_info = $self->{skinny}->schema->schema_info;
      unless ( $schema_info->{$table} ) {
          Carp::croak "unknown table: $table";
      }
  
      # get target table pk
      my $pk = $schema_info->{$table}->{pk};
      unless ($pk) {
          Carp::croak "$table have no pk.";
      }
  
      # multi primary keys
      if ( ref $pk eq 'ARRAY' ) {
          my %pks = map { $_ => 1 } @$pk;
  
          unless ( ( grep { exists $pks{ $_ } } @{$self->{select_columns}} ) == @$pk ) {
              Carp::croak "can't get primary columns in your query.";
          }
  
          return +{ map { $_ => $self->$_() } @$pk };
      } else {
          unless (grep { $pk eq $_ } @{$self->{select_columns}}) {
              Carp::croak "can't get primary column in your query.";
          }
  
          return +{ $pk => $self->$pk };
      }
  }
  
  1;
  
  __END__
  =head1 NAME
  
  DBIx::Skinny::Row - DBIx::Skinny's Row class
  
  =head1 METHODS
  
  =head2 get_column
  
      my $val = $row->get_column($col);
  
  get a column value from a row object.
  
  =head2 get_columns
  
      my %data = $row->get_columns;
  
  Does C<get_column>, for all column values.
  
  =head2 set
  
      $row->set({$col => $val});
  
  set columns data.
  
  =head2 get_dirty_columns
  
  returns those that have been changed.
  
  =head2 insert
  
  insert row data. call find_or_create method.
  
  =head2 update
  
  update is executed for instance record.
  
  It works by schema in which primary key exists.
  
  =head2 delete
  
  delete is executed for instance record.
  
  It works by schema in which primary key exists.
  
DBIX_SKINNY_ROW

$fatpacked{"DBIx/Skinny/SQL.pm"} = <<'DBIX_SKINNY_SQL';
  package DBIx::Skinny::SQL;
  use strict;
  use warnings;
  use DBIx::Skinny::Accessor;
  
  mk_accessors(
      qw/
          select distinct select_map select_map_reverse
          from joins where bind bind_col limit offset group order
          having where_values column_mutator index_hint
          comment
          skinny
      /
  );
  
  sub init {
      my $self = shift;
  
      for my $name (qw/ select from joins bind bind_col group order where having /) {
          unless ($self->$name && ref $self->$name eq 'ARRAY') {
              $self->$name ? $self->$name([ $self->$name ]) : $self->$name([]);
          }
      }
      for my $name (qw/ select_map select_map_reverse where_values index_hint/) {
          $self->$name( {} ) unless $self->$name && ref $self->$name eq 'HASH';
      }
  
      $self->distinct(0) unless $self->distinct;
  
      $self;
  }
  
  sub add_select {
      my $self = shift;
      my($term, $col) = @_;
      $col ||= $term;
      push @{ $self->select }, $term;
      $self->select_map->{$term} = $col;
      $self->select_map_reverse->{$col} = $term;
  }
  
  sub add_join {
      my $self = shift;
      my($table, $joins) = @_;
      push @{ $self->joins }, {
          table => $table,
          joins => ref($joins) eq 'ARRAY' ? $joins : [ $joins ],
      };
  }
  
  sub add_index_hint {
      my $self = shift;
      my($table, $hint) = @_;
      $self->index_hint->{$table} = {
          type => $hint->{type} || 'USE',
          list => ref($hint->{list}) eq 'ARRAY' ? $hint->{list} : [ $hint->{list} ],
      };
  }
  
  sub as_sql {
      my $self = shift;
      my $sql = '';
      if (@{ $self->select }) {
          $sql .= 'SELECT ';
          $sql .= 'DISTINCT ' if $self->distinct;
          $sql .= join(', ',  map {
              my $alias = $self->select_map->{$_};
              !$alias                         ? $_ :
              $alias && /(?:^|\.)\Q$alias\E$/ ? $_ : "$_ AS $alias";
          } @{ $self->select }) . "\n";
      }
  
      $sql .= 'FROM ';
  
      ## Add any explicit JOIN statements before the non-joined tables.
      if ($self->joins && @{ $self->joins }) {
          my $initial_table_written = 0;
          for my $j (@{ $self->joins }) {
              my($table, $joins) = map { $j->{$_} } qw( table joins );
              $table = $self->_add_index_hint($table); ## index hint handling
              $sql .= $table unless $initial_table_written++;
              for my $join (@{ $j->{joins} }) {
                  $sql .= ' ' .
                          uc($join->{type}) . ' JOIN ' . $join->{table} . ' ON ' .
                          $join->{condition};
              }
          }
          $sql .= ', ' if @{ $self->from };
      }
  
      if ($self->from && @{ $self->from }) {
          $sql .= join ', ', map { $self->_add_index_hint($_) } @{ $self->from };
      }
  
      $sql .= "\n";
      $sql .= $self->as_sql_where;
  
      $sql .= $self->as_aggregate('group');
      $sql .= $self->as_sql_having;
      $sql .= $self->as_aggregate('order');
  
      $sql .= $self->as_limit;
      my $comment = $self->comment;
      if ($comment && $comment =~ /([ 0-9a-zA-Z.:;()_#&,]+)/) {
          $sql .= "-- $1" if $1;
      }
      return $sql;
  }
  
  sub as_limit {
      my $self = shift;
      my $n = $self->limit or
          return '';
      die "Non-numerics in limit clause ($n)" if $n =~ /\D/;
      return sprintf "LIMIT %d%s\n", $n,
             ($self->offset ? " OFFSET " . int($self->offset) : "");
  }
  
  sub as_aggregate {
      my ($self, $set) = @_;
  
      return '' unless my $attribute = $self->$set();
  
      my $ref = ref $attribute;
  
      if ($ref eq 'ARRAY' && scalar @$attribute == 0) {
          return '';
      }
  
      my $elements = ($ref eq 'ARRAY') ? $attribute : [ $attribute ];
      return uc($set)
             . ' BY '
             . join(', ', map { $_->{column} . ($_->{desc} ? (' ' . $_->{desc}) : '') } @$elements)
             . "\n";
  }
  
  sub as_sql_where {
      my $self = shift;
      $self->where && @{ $self->where } ?
          'WHERE ' . join(' AND ', @{ $self->where }) . "\n" :
          '';
  }
  
  sub as_sql_having {
      my $self = shift;
      $self->having && @{ $self->having } ?
          'HAVING ' . join(' AND ', @{ $self->having }) . "\n" :
          '';
  }
  
  sub add_where {
      my $self = shift;
      ## xxx Need to support old range and transform behaviors.
      my($col, $val) = @_;
      # XXX; DATE_FORMAT(member.created_at,'%Y-%m') 
  #    Carp::croak("Invalid/unsafe column name $col") unless $col =~ /^[\w\.]+$/;
      my($term, $bind, $tcol) = $self->_mk_term($col, $val);
      push @{ $self->{where} }, "($term)";
      push @{ $self->{bind} }, @$bind;
      push @{ $self->{bind_col} }, $tcol;
      $self->where_values->{$tcol} = $val;
  }
  
  sub add_complex_where {
      my $self = shift;
      my ($terms) = @_;
      my ($where, $bind) = $self->_parse_array_terms($terms);
      push @{ $self->{where} }, $where;
      push @{ $self->{bind} }, @$bind;
  }
  
  sub _parse_array_terms {
      my $self = shift;
      my ($term_list) = @_;
  
      my @out;
      my $logic = 'AND';
      my @bind;
      foreach my $t ( @$term_list ) {
          if (! ref $t ) {
              $logic = $1 if uc($t) =~ m/^-?(OR|AND|OR_NOT|AND_NOT)$/;
              $logic =~ s/_/ /;
              next;
          }
          my $out;
          if (ref $t eq 'HASH') {
              # bag of terms to apply $logic with
              my @out;
              foreach my $t2 ( keys %$t ) {
                  my ($term, $bind, $col) = $self->_mk_term($t2, $t->{$t2});
                  push @{ $self->{bind_col} }, $col;
                  $self->where_values->{$col} = $t->{$t2};
                  push @out, $term;
                  push @bind, @$bind;
              }
              $out .= '(' . join(" AND ", @out) . ")";
          }
          elsif (ref $t eq 'ARRAY') {
              # another array of terms to process!
              my ($where, $bind) = $self->_parse_array_terms( $t );
              push @bind, @$bind;
              $out = '(' . $where . ')';
          }
          push @out, (@out ? ' ' . $logic . ' ' : '') . $out;
      }
      return (join("", @out), \@bind);
  }
  
  sub has_where {
      my $self = shift;
      my($col, $val) = @_;
  
      # TODO: should check if the value is same with $val?
      exists $self->where_values->{$col};
  }
  
  sub add_having {
      my $self = shift;
      my($col, $val) = @_;
  
      if (my $orig = $self->select_map_reverse->{$col}) {
          $col = $orig;
      }
  
      my($term, $bind) = $self->_mk_term($col, $val);
      push @{ $self->{having} }, "($term)";
      push @{ $self->{bind} }, @$bind;
  }
  
  sub _mk_term {
      my $self = shift;
      my($col, $val) = @_;
      my $term = '';
      my (@bind, $m);
      if (ref($val) eq 'ARRAY') {
          if (ref $val->[0] or (($val->[0] || '') eq '-and')) {
              my $logic = 'OR';
              my @values = @$val;
              if ($val->[0] eq '-and') {
                  $logic = 'AND';
                  shift @values;
              }
  
              my @terms;
              for my $v (@values) {
                  my($term, $bind) = $self->_mk_term($col, $v);
                  push @terms, "($term)";
                  push @bind, @$bind;
              }
              $term = join " $logic ", @terms;
          } else {
              $col = $m->($col) if $m = $self->column_mutator;
              $term = "$col IN (".join(',', ('?') x scalar @$val).')';
              @bind = @$val;
          }
      } elsif (ref($val) eq 'HASH') {
          my $c = $val->{column} || $col;
          $c = $m->($c) if $m = $self->column_mutator;
  
          my($op, $v) = (%{ $val });
          $op = uc($op);
          if (($op eq 'IN' || $op eq 'NOT IN') && ref($v) eq 'ARRAY') {
              $term = "$c $op (".join(',', ('?') x scalar @$v).')';
              @bind = @$v;
          } else {
              $term = "$c $op ?";
              push @bind, $v;
          }
      } elsif (ref($val) eq 'SCALAR') {
          $col = $m->($col) if $m = $self->column_mutator;
          $term = "$col $$val";
      } else {
          $col = $m->($col) if $m = $self->column_mutator;
          $term = "$col = ?";
          push @bind, $val;
      }
      ($term, \@bind, $col);
  }
  
  sub _add_index_hint {
      my $self = shift;
      my ($tbl_name) = @_;
      my $hint = $self->index_hint->{$tbl_name};
      return $tbl_name unless $hint && ref($hint) eq 'HASH';
      if ($hint->{list} && @{ $hint->{list} }) {
          return $tbl_name . ' ' . uc($hint->{type} || 'USE') . ' INDEX (' . 
                  join (',', @{ $hint->{list} }) .
                  ')';
      }
      return $tbl_name;
  }
  
  sub retrieve {
      my ($self, $table) = @_;
      $self->skinny->search_by_sql($self->as_sql, $self->bind, ($table || $self->from->[0]));
  }
  
  'base code from Data::ObjectDriver::SQL';
DBIX_SKINNY_SQL

$fatpacked{"DBIx/Skinny/SQL/Oracle.pm"} = <<'DBIX_SKINNY_SQL_ORACLE';
  package DBIx::Skinny::SQL::Oracle;
  use strict;
  use warnings;
  use base qw(DBIx::Skinny::SQL);
  
  ## Oracle doesn't have the LIMIT clause.
  sub as_limit {
      return '';
  }
  
  ## Override as_sql to emulate the LIMIT clause.
  sub as_sql {
      my $stmt   = shift;
      my $limit  = $stmt->limit;
      my $offset = $stmt->offset;
  
      if (defined $limit && defined $offset) {
          $stmt->select( @{ $stmt->select }, "ROW_NUMBER() OVER (ORDER BY 1) R" );
      }
  
      my $sql = $stmt->SUPER::as_sql(@_);
  
      if (defined $limit) {
          $sql = "SELECT * FROM ( $sql ) WHERE ";
          if (defined $offset) {
              $sql = $sql . " R BETWEEN $offset + 1 AND $limit + $offset";
          } else {
              $sql = $sql . " rownum <= $limit";
          }
      }
      return $sql;
  }
  
  'base code from Data::ObjectDriver::SQL::Oracle';
DBIX_SKINNY_SQL_ORACLE

$fatpacked{"DBIx/Skinny/Schema.pm"} = <<'DBIX_SKINNY_SCHEMA';
  package DBIx::Skinny::Schema;
  use strict;
  use warnings;
  
  BEGIN {
      if ($] <= 5.008000) {
          require Encode;
          *utf8_on = sub {
              my ($class, $col, $data) = @_;
              if ($class->is_utf8_column($col)) {
                  Encode::_utf8_on($data) unless Encode::is_utf8($data);
              }
              $data;
          };
          *utf8_off = sub {
              my ($class, $col, $data) = @_;
              if ($class->is_utf8_column($col)) {
                  Encode::_utf8_off($data) if Encode::is_utf8($data);
              }
              $data;
          };
      } else {
          require utf8;
          *utf8_on = sub {
              my ($class, $col, $data) = @_;
              if ($class->is_utf8_column($col)) {
                  utf8::decode($data) unless utf8::is_utf8($data);
              }
              $data;
          };
          *utf8_off = sub {
              my ($class, $col, $data) = @_;
              if ($class->is_utf8_column($col)) {
                  utf8::encode($data) if utf8::is_utf8($data);
              }
              $data;
          };
      }
  }
  
  sub import {
      my $caller = caller;
  
      my @functions = qw/
          install_table
            schema pk columns schema_info column_type
          install_inflate_rule
            inflate deflate call_inflate call_deflate
            callback _do_inflate
          install_common_trigger trigger call_trigger
          install_utf8_columns
            is_utf8_column utf8_on utf8_off
      /;
      no strict 'refs';
      for my $func (@functions) {
          *{"$caller\::$func"} = \&$func;
      }
  
      my $_schema_info = {};
      *{"$caller\::schema_info"} = sub { $_schema_info };
      my $_schema_inflate_rule = {};
      *{"$caller\::inflate_rules"} = sub { $_schema_inflate_rule };
      my $_schema_common_triggers = {};
      *{"$caller\::common_triggers"} = sub { $_schema_common_triggers };
      my $_utf8_columns = {};
      *{"$caller\::utf8_columns"} = sub { $_utf8_columns };
  
      strict->import;
      warnings->import;
  }
  
  sub install_table ($$) {
      my ($table, $install_code) = @_;
  
      my $class = caller;
      $class->schema_info->{_installing_table} = $table;
          $install_code->();
      delete $class->schema_info->{_installing_table};
  }
  
  sub schema (&) { shift }
  
  sub pk ($) {
      my $column = shift;
  
      my $class = caller;
      $class->schema_info->{
          $class->schema_info->{_installing_table}
      }->{pk} = $column;
  }
  
  sub columns (@) {
      my @columns = @_;
  
      my (@_columns, %_column_types);
      for my $item (@columns) {
          if (not ref $item) {
              push @_columns, $item;
          } elsif (ref $item eq 'HASH') {
              push @_columns, $item->{name};
              $_column_types{$item->{name}} = $item->{type};
          } else {
              die "columns must be 'SCALAR' or 'HASHREF'";    
          }
      }
  
      my $class = caller;
      $class->schema_info->{
          $class->schema_info->{_installing_table}
      }->{columns} = \@_columns;
  
      $class->schema_info->{
          $class->schema_info->{_installing_table}
      }->{column_types} = \%_column_types;
  }
  
  sub column_type {
      my ($class, $table, $column) = @_;
      exists $class->schema_info->{$table}->{column_types}->{$column} ? $class->schema_info->{$table}->{column_types}->{$column}
                                                                      : undef;
  }
  
  sub trigger ($$) {
      my ($trigger_name, $code) = @_;
  
      my $class = caller;
      push @{$class->schema_info->{
          $class->schema_info->{_installing_table}
      }->{trigger}->{$trigger_name}}, $code;
  }
  
  sub call_trigger {
      my ($class, $skinny, $table, $trigger_name, $args) = @_;
  
      my $common_triggers = $class->common_triggers->{$trigger_name};
      for my $code (@$common_triggers) {
          $code->($skinny, $args, $table);
      }
  
      my $triggers = $class->schema_info->{$table}->{trigger}->{$trigger_name};
      for my $code (@$triggers) {
          $code->($skinny, $args, $table);
      }
  }
  
  sub install_inflate_rule ($$) {
      my ($rule, $install_inflate_code) = @_;
  
      my $class = caller;
      $class->inflate_rules->{_installing_rule} = $rule;
          $install_inflate_code->();
      delete $class->inflate_rules->{_installing_rule};
  }
  
  sub inflate (&) {
      my $code = shift;    
  
      my $class = caller;
      $class->inflate_rules->{
          $class->inflate_rules->{_installing_rule}
      }->{inflate} = $code;
  }
  
  sub deflate (&) {
      my $code = shift;
  
      my $class = caller;
      $class->inflate_rules->{
          $class->inflate_rules->{_installing_rule}
      }->{deflate} = $code;
  }
  
  sub call_inflate {
      my $class = shift;
  
      return $class->_do_inflate('inflate', @_);
  }
  
  sub call_deflate {
      my $class = shift;
  
      return $class->_do_inflate('deflate', @_);
  }
  
  sub _do_inflate {
      my ($class, $key, $col, $data) = @_;
  
      my $inflate_rules = $class->inflate_rules;
      for my $rule (keys %{$inflate_rules}) {
          if ($col =~ /$rule/ and my $code = $inflate_rules->{$rule}->{$key}) {
              $data = $code->($data);
          }
      }
      return $data;
  }
  
  sub callback (&) { shift }
  
  sub install_common_trigger ($$) {
      my ($trigger_name, $code) = @_;
  
      my $class = caller;
      push @{$class->common_triggers->{$trigger_name}}, $code;
  }
  
  sub install_utf8_columns (@) {
      my @columns = @_;
  
      my $class = caller;
      for my $col (@columns) {
          $class->utf8_columns->{$col} = 1;
      }
  }
  
  sub is_utf8_column {
      my ($class, $col) = @_;
      return $class->utf8_columns->{$col} ? 1 : 0;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  DBIx::Skinny::Schema - Schema DSL for DBIx::Skinny
  
  =head1 SYNOPSIS
  
      package Your::Model;
      package Qudo::Driver::Skinny;
      use DBIx::Skinny setup => +{
          dsn => 'dbi:SQLite:',
          username => '',
          password => '',
      };
      1;
      
      package Your:Model::Schema:
      use DBIx::Skinny::Schema;
      
      install_utf8_columns qw/name/; # for utf8 columns
      
      # set user table schema settings
      install_table user => schema {
          pk 'id';
          columns qw/id name created_at/;
  
          trigger pre_insert => callback {
              # hook
          };
  
          trigger pre_update => callback {
              # hook
          };
      };
  
      install_inflate_rule '^name$' => callback {
          inflate {
              my $value = shift;
              # inflate hook
          };
          deflate {
              my $value = shift;
              # deflate hook
          };
      };
      
      1;
  
  
DBIX_SKINNY_SCHEMA

$fatpacked{"DBIx/Skinny/Transaction.pm"} = <<'DBIX_SKINNY_TRANSACTION';
  package DBIx::Skinny::Transaction;
  use strict;
  use warnings;
  
  sub new {
      my($class, $skinny) = @_;
      $skinny->txn_begin;
      bless [ 0, $skinny, ], $class;
  }
  
  sub rollback {
      return if $_[0]->[0];
      $_[0]->[1]->txn_rollback;
      $_[0]->[0] = 1;
  }
  
  sub commit {
      return if $_[0]->[0];
      $_[0]->[1]->txn_commit;
      $_[0]->[0] = 1;
  }
  
  sub DESTROY {
      my($dismiss, $skinny) = @{ $_[0] };
      return if $dismiss;
  
      {
          local $@;
          eval { $skinny->txn_rollback };
          my $rollback_exception = $@;
          if($rollback_exception) {
              die "Rollback failed: ${rollback_exception}";
          }
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  DBIx::Skinny::Transaction - transaction manager for DBIx::Skinny
  
  =head1 SYNOPSIS
  
    sub do_work {
        my $txn = Your::Model->txn_scope; # start transaction
  
        my $row = Your::Model->single('user', {id => 1});
        $row->set({name => 'nekokak'});
        $row->update;
  
        $txn->commit; # commit
    }
  
  =head1 SEE ALSO
  
  L<Data::Model>
  
DBIX_SKINNY_TRANSACTION

$fatpacked{"Data/Section/Simple.pm"} = <<'DATA_SECTION_SIMPLE';
  package Data::Section::Simple;
  
  use strict;
  use 5.008_001;
  our $VERSION = '0.02';
  
  use base qw(Exporter);
  our @EXPORT_OK = qw(get_data_section);
  
  sub new {
      my($class, $pkg) = @_;
      bless { package => $pkg || caller }, $class;
  }
  
  sub get_data_section {
      my $self = ref $_[0] ? shift : __PACKAGE__->new(scalar caller);
  
      if (@_) {
          return $self->get_data_section->{$_[0]};
      } else {
          my $d = do { no strict 'refs'; \*{$self->{package}."::DATA"} };
          return unless defined fileno $d;
  
          seek $d, 0, 0;
          my $content = join '', <$d>;
          $content =~ s/^.*\n__DATA__\n/\n/s; # for win32
          $content =~ s/\n__END__\n.*$/\n/s;
  
          my @data = split /^@@\s+(.+?)\s*\r?\n/m, $content;
          shift @data; # trailing whitespaces
  
          my $all = {};
          while (@data) {
              my ($name, $content) = splice @data, 0, 2;
              $all->{$name} = $content;
          }
  
          return $all;
      }
  }
  
  1;
  __END__
  
  =encoding utf-8
  
  =for stopwords
  
  =head1 NAME
  
  Data::Section::Simple - Read data from __DATA__
  
  =head1 SYNOPSIS
  
    use Data::Section::Simple qw(get_data_section);
  
    # Functional interface -- reads from caller package __DATA__
    my $all = get_data_section; # All data in hash reference
    my $foo = get_data_section('foo.html');
  
    # OO - allows reading from other packages
    my $reader = Data::Section::Simple->new($package);
    my $all = $reader->get_data_section;
  
    __DATA__
  
    @@ foo.html
    <html>
     <body>Hello</body>
    </html>
  
    @@ bar.tt
    [% IF true %]
      Foo
    [% END %]
  
  =head1 DESCRIPTION
  
  Data::Section::Simple is a simple module to extract data drom
  C<__DATA__> section of the file.
  
  =head1 LIMITATIONS
  
  As the name suggests, this module is a simpler version of the
  excellent L<Data::Section>. If you want more functionalities such as
  merging data sections or changing header patterns, use
  L<Data::Section> instead.
  
  This module does not implement caching (yet) which means in every
  C<get_data_section> or C<< get_data_section($name) >> this module
  seeks and re-reads the data section. If you want to avoid doing so for
  the better performance, you should implement caching in your own
  caller code.
  
  =head1 BUGS
  
  If you data section has literal C<__DATA__> in the data section, this
  module might be tricked by that. Although since its pattern match is
  greedy, C<__DATA__> appearing I<before> the actual data section
  (i.e. in the code) might be okay.
  
  This is by design -- in thoery you can C<tell> the DATA handle before
  reading it, but then reloading the data section of the file (handy for
  developing inline templates with PSGI web applications) would fail
  because the pos would be changed.
  
  If you don't like this design, again, use the superior
  L<Data::Section>.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa E<lt>miyagawa@bulknews.netE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2010- Tatsuhiko Miyagawa
  
  The code to read DATA section is based on Mojo::Command get_all_data:
  Copyright 2008-2010 Sebastian Riedel
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<Data::Section> L<Inline::Files>
  
  =cut
DATA_SECTION_SIMPLE

$fatpacked{"Devel/StackTrace.pm"} = <<'DEVEL_STACKTRACE';
  package Devel::StackTrace;
  
  use 5.006;
  
  use strict;
  use warnings;
  
  use File::Spec;
  use Scalar::Util qw( blessed );
  
  use overload
      '""' => \&as_string,
      fallback => 1;
  
  our $VERSION = '1.22';
  
  
  sub new
  {
      my $class = shift;
      my %p = @_;
  
      # Backwards compatibility - this parameter was renamed to no_refs
      # ages ago.
      $p{no_refs} = delete $p{no_object_refs}
          if exists $p{no_object_refs};
  
      my $self =
          bless { index  => undef,
                  frames => [],
                  raw    => [],
                  %p,
                }, $class;
  
      $self->_record_caller_data();
  
      return $self;
  }
  
  sub _record_caller_data
  {
      my $self = shift;
  
      # We exclude this method by starting one frame back.
      my $x = 1;
      while ( my @c =
              do { package DB; @DB::args = (); caller($x++) } )
      {
          my @a = @DB::args;
  
          if ( $self->{no_refs} )
          {
              @a = map { ref $_ ? $self->_ref_to_string($_) : $_ } @a;
          }
  
          push @{ $self->{raw} },
              { caller => \@c,
                args   => \@a,
              };
      }
  }
  
  sub _ref_to_string
  {
      my $self = shift;
      my $ref  = shift;
  
      return overload::AddrRef($ref)
          if blessed $ref && $ref->isa('Exception::Class::Base');
  
      return overload::AddrRef($ref) unless $self->{respect_overload};
  
      local $@;
      local $SIG{__DIE__};
  
      my $str = eval { $ref . '' };
  
      return $@ ? overload::AddrRef($ref) : $str;
  }
  
  sub _make_frames
  {
      my $self = shift;
  
      my $filter = $self->_make_frame_filter;
  
      my $raw = delete $self->{raw};
      for my $r ( @{$raw} )
      {
          next unless $filter->($r);
  
          $self->_add_frame( $r->{caller}, $r->{args} );
      }
  }
  
  my $default_filter = sub { 1 };
  sub _make_frame_filter
  {
      my $self = shift;
  
      my (@i_pack_re, %i_class);
      if ( $self->{ignore_package} )
      {
          $self->{ignore_package} =
              [ $self->{ignore_package} ] unless UNIVERSAL::isa( $self->{ignore_package}, 'ARRAY' );
  
          @i_pack_re = map { ref $_ ? $_ : qr/^\Q$_\E$/ } @{ $self->{ignore_package} };
      }
  
      my $p = __PACKAGE__;
      push @i_pack_re, qr/^\Q$p\E$/;
  
      if ( $self->{ignore_class} )
      {
          $self->{ignore_class} = [ $self->{ignore_class} ] unless ref $self->{ignore_class};
          %i_class = map {$_ => 1} @{ $self->{ignore_class} };
      }
  
      my $user_filter = $self->{frame_filter};
  
      return sub
      {
          return 0 if grep { $_[0]{caller}[0] =~ /$_/ } @i_pack_re;
          return 0 if grep { $_[0]{caller}[0]->isa($_) } keys %i_class;
  
          if ( $user_filter )
          {
              return $user_filter->( $_[0] );
          }
  
          return 1;
      };
  }
  
  sub _add_frame
  {
      my $self = shift;
      my $c    = shift;
      my $args = shift;
  
      # eval and is_require are only returned when applicable under 5.00503.
      push @$c, (undef, undef) if scalar @$c == 6;
  
      if ( $self->{no_refs} )
      {
      }
  
      push @{ $self->{frames} },
          Devel::StackTraceFrame->new( $c, $args,
                                       $self->{respect_overload}, $self->{max_arg_length} );
  }
  
  sub next_frame
  {
      my $self = shift;
  
      # reset to top if necessary.
      $self->{index} = -1 unless defined $self->{index};
  
      my @f = $self->frames();
      if ( defined $f[ $self->{index} + 1 ] )
      {
          return $f[ ++$self->{index} ];
      }
      else
      {
          $self->{index} = undef;
          return undef;
      }
  }
  
  sub prev_frame
  {
      my $self = shift;
  
      my @f = $self->frames();
  
      # reset to top if necessary.
      $self->{index} = scalar @f unless defined $self->{index};
  
      if ( defined $f[ $self->{index} - 1 ] && $self->{index} >= 1 )
      {
          return $f[ --$self->{index} ];
      }
      else
      {
          $self->{index} = undef;
          return undef;
      }
  }
  
  sub reset_pointer
  {
      my $self = shift;
  
      $self->{index} = undef;
  }
  
  sub frames
  {
      my $self = shift;
  
      $self->_make_frames() if $self->{raw};
  
      return @{ $self->{frames} };
  }
  
  sub frame
  {
      my $self = shift;
      my $i = shift;
  
      return unless defined $i;
  
      return ( $self->frames() )[$i];
  }
  
  sub frame_count
  {
      my $self = shift;
  
      return scalar ( $self->frames() );
  }
  
  sub as_string
  {
      my $self = shift;
  
      my $st = '';
      my $first = 1;
      foreach my $f ( $self->frames() )
      {
          $st .= $f->as_string($first) . "\n";
          $first = 0;
      }
  
      return $st;
  }
  
  # Hide from PAUSE
  package
      Devel::StackTraceFrame;
  
  use strict;
  use warnings;
  
  our $VERSION = $Devel::StackTrace::VERSION;
  
  # Create accessor routines
  BEGIN
  {
      no strict 'refs';
      foreach my $f ( qw( package filename line subroutine hasargs
                          wantarray evaltext is_require hints bitmask args ) )
      {
          next if $f eq 'args';
          *{$f} = sub { my $s = shift; return $s->{$f} };
      }
  }
  
  {
      my @fields =
          ( qw( package filename line subroutine hasargs wantarray
                evaltext is_require hints bitmask ) );
  
      sub new
      {
          my $proto = shift;
          my $class = ref $proto || $proto;
  
          my $self = bless {}, $class;
  
          @{ $self }{ @fields } = @{$_[0]};
  
          # fixup unix-style paths on win32
          $self->{filename} = File::Spec->canonpath( $self->{filename} );
  
          $self->{args} = $_[1];
  
          $self->{respect_overload} = $_[2];
  
          $self->{max_arg_length} = $_[3];
  
          return $self;
      }
  }
  
  sub args
  {
      my $self = shift;
  
      return @{ $self->{args} };
  }
  
  sub as_string
  {
      my $self = shift;
      my $first = shift;
  
      my $sub = $self->subroutine;
      # This code stolen straight from Carp.pm and then tweaked.  All
      # errors are probably my fault  -dave
      if ($first)
      {
          $sub = 'Trace begun';
      }
      else
      {
          # Build a string, $sub, which names the sub-routine called.
          # This may also be "require ...", "eval '...' or "eval {...}"
          if (my $eval = $self->evaltext)
          {
              if ($self->is_require)
              {
                  $sub = "require $eval";
              }
              else
              {
                  $eval =~ s/([\\\'])/\\$1/g;
                  $sub = "eval '$eval'";
              }
          }
          elsif ($sub eq '(eval)')
          {
              $sub = 'eval {...}';
          }
  
          # if there are any arguments in the sub-routine call, format
          # them according to the format variables defined earlier in
          # this file and join them onto the $sub sub-routine string
          #
          # We copy them because they're going to be modified.
          #
          if ( my @a = $self->args )
          {
              for (@a)
              {
                  # set args to the string "undef" if undefined
                  $_ = "undef", next unless defined $_;
  
                  # hack!
                  $_ = $self->Devel::StackTrace::_ref_to_string($_)
                      if ref $_;
  
                  eval
                  {
                      if ( $self->{max_arg_length}
                           && length $_ > $self->{max_arg_length} )
                      {
                          substr( $_, $self->{max_arg_length} ) = '...';
                      }
  
                      s/'/\\'/g;
  
                      # 'quote' arg unless it looks like a number
                      $_ = "'$_'" unless /^-?[\d.]+$/;
  
                      # print control/high ASCII chars as 'M-<char>' or '^<char>'
                      s/([\200-\377])/sprintf("M-%c",ord($1)&0177)/eg;
                      s/([\0-\37\177])/sprintf("^%c",ord($1)^64)/eg;
                  };
  
                  if ( my $e = $@ )
                  {
                      $_ = $e =~ /malformed utf-8/i ? '(bad utf-8)' : '?';
                  }
              }
  
              # append ('all', 'the', 'arguments') to the $sub string
              $sub .= '(' . join(', ', @a) . ')';
              $sub .= ' called';
          }
      }
  
      return "$sub at " . $self->filename . ' line ' . $self->line;
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  Devel::StackTrace - Stack trace and stack trace frame objects
  
  =head1 SYNOPSIS
  
    use Devel::StackTrace;
  
    my $trace = Devel::StackTrace->new;
  
    print $trace->as_string; # like carp
  
    # from top (most recent) of stack to bottom.
    while (my $frame = $trace->next_frame)
    {
        print "Has args\n" if $frame->hasargs;
    }
  
    # from bottom (least recent) of stack to top.
    while (my $frame = $trace->prev_frame)
    {
        print "Sub: ", $frame->subroutine, "\n";
    }
  
  =head1 DESCRIPTION
  
  The Devel::StackTrace module contains two classes, Devel::StackTrace
  and Devel::StackTraceFrame.  The goal of this object is to encapsulate
  the information that can found through using the caller() function, as
  well as providing a simple interface to this data.
  
  The Devel::StackTrace object contains a set of Devel::StackTraceFrame
  objects, one for each level of the stack.  The frames contain all the
  data available from C<caller()>.
  
  This code was created to support my L<Exception::Class::Base> class
  (part of Exception::Class) but may be useful in other contexts.
  
  =head1 'TOP' AND 'BOTTOM' OF THE STACK
  
  When describing the methods of the trace object, I use the words 'top'
  and 'bottom'.  In this context, the 'top' frame on the stack is the
  most recent frame and the 'bottom' is the least recent.
  
  Here's an example:
  
    foo();  # bottom frame is here
  
    sub foo
    {
       bar();
    }
  
    sub bar
    {
       Devel::StackTrace->new;  # top frame is here.
    }
  
  =head1 Devel::StackTrace METHODS
  
  =over 4
  
  =item * Devel::StackTrace->new(%named_params)
  
  Returns a new Devel::StackTrace object.
  
  Takes the following parameters:
  
  =over 8
  
  =item * frame_filter => $sub
  
  By default, Devel::StackTrace will include all stack frames before the
  call to its its constructor.
  
  However, you may want to filter out some frames with more granularity
  than 'ignore_package' or 'ignore_class' allow.
  
  You can provide a subroutine which is called with the raw frame data
  for each frame. This is a hash reference with two keys, "caller", and
  "args", both of which are array references. The "caller" key is the
  raw data as returned by Perl's C<caller()> function, and the "args"
  key are the subroutine arguments found in C<@DB::args>.
  
  The filter should return true if the frame should be included, or
  false if it should be skipped.
  
  =item * ignore_package => $package_name OR \@package_names
  
  Any frames where the package is one of these packages will not be on
  the stack.
  
  =item * ignore_class => $package_name OR \@package_names
  
  Any frames where the package is a subclass of one of these packages
  (or is the same package) will not be on the stack.
  
  Devel::StackTrace internally adds itself to the 'ignore_package'
  parameter, meaning that the Devel::StackTrace package is B<ALWAYS>
  ignored.  However, if you create a subclass of Devel::StackTrace it
  will not be ignored.
  
  =item * no_refs => $boolean
  
  If this parameter is true, then Devel::StackTrace will not store
  references internally when generating stacktrace frames.  This lets
  your objects go out of scope.
  
  Devel::StackTrace replaces any references with their stringified
  representation.
  
  =item * respect_overload => $boolean
  
  By default, Devel::StackTrace will call C<overload::AddrRef()> to get
  the underlying string representation of an object, instead of
  respecting the object's stringification overloading.  If you would
  prefer to see the overloaded representation of objects in stack
  traces, then set this parameter to true.
  
  =item * max_arg_length => $integer
  
  By default, Devel::StackTrace will display the entire argument for
  each subroutine call. Setting this parameter causes it to truncate the
  argument's string representation if it is longer than this number of
  characters.
  
  =back
  
  =item * $trace->next_frame
  
  Returns the next Devel::StackTraceFrame object down on the stack.  If
  it hasn't been called before it returns the first frame.  It returns
  undef when it reaches the bottom of the stack and then resets its
  pointer so the next call to C<next_frame> or C<prev_frame> will work
  properly.
  
  =item * $trace->prev_frame
  
  Returns the next Devel::StackTraceFrame object up on the stack.  If it
  hasn't been called before it returns the last frame.  It returns undef
  when it reaches the top of the stack and then resets its pointer so
  pointer so the next call to C<next_frame> or C<prev_frame> will work
  properly.
  
  =item * $trace->reset_pointer
  
  Resets the pointer so that the next call C<next_frame> or
  C<prev_frame> will start at the top or bottom of the stack, as
  appropriate.
  
  =item * $trace->frames
  
  Returns a list of Devel::StackTraceFrame objects.  The order they are
  returned is from top (most recent) to bottom.
  
  =item * $trace->frame ($index)
  
  Given an index, returns the relevant frame or undef if there is not
  frame at that index.  The index is exactly like a Perl array.  The
  first frame is 0 and negative indexes are allowed.
  
  =item * $trace->frame_count
  
  Returns the number of frames in the trace object.
  
  =item * $trace->as_string
  
  Calls as_string on each frame from top to bottom, producing output
  quite similar to the Carp module's cluck/confess methods.
  
  =back
  
  =head1 Devel::StackTraceFrame METHODS
  
  See the L<caller> documentation for more information on what these
  methods return.
  
  =over 4
  
  =item * $frame->package
  
  =item * $frame->filename
  
  =item * $frame->line
  
  =item * $frame->subroutine
  
  =item * $frame->hasargs
  
  =item * $frame->wantarray
  
  =item * $frame->evaltext
  
  Returns undef if the frame was not part of an eval.
  
  =item * $frame->is_require
  
  Returns undef if the frame was not part of a require.
  
  =item * $frame->args
  
  Returns the arguments passed to the frame.  Note that any arguments
  that are references are returned as references, not copies.
  
  =item * $frame->hints
  
  =item * $frame->bitmask
  
  =back
  
  =head1 SUPPORT
  
  Please submit bugs to the CPAN RT system at
  http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Devel%3A%3AStackTrace
  or via email at bug-devel-stacktrace@rt.cpan.org.
  
  =head1 AUTHOR
  
  Dave Rolsky, <autarch@urth.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2000-2006 David Rolsky.  All rights reserved.  This
  program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  The full text of the license can be found in the LICENSE file included
  with this module.
  
  =cut
DEVEL_STACKTRACE

$fatpacked{"Devel/StackTrace/AsHTML.pm"} = <<'DEVEL_STACKTRACE_ASHTML';
  package Devel::StackTrace::AsHTML;
  
  use strict;
  use 5.008_001;
  our $VERSION = '0.09';
  
  use Data::Dumper;
  use Devel::StackTrace;
  use Scalar::Util;
  
  no warnings 'qw';
  my %enc = qw( & &amp; > &gt; < &lt; " &quot; ' &#39; );
  
  # NOTE: because we don't know which encoding $str is in, or even if
  # $str is a wide character (decoded strings), we just leave the low
  # bits, including latin-1 range and encode everything higher as HTML
  # entities. I know this is NOT always correct, but should mostly work
  # in case $str is encoded in utf-8 bytes or wide chars. This is a
  # necessary workaround since we're rendering someone else's code which
  # we can't enforce string encodings.
  
  sub encode_html {
      my $str = shift;
      $str =~ s/([^\x00-\x21\x23-\x25\x28-\x3b\x3d\x3f-\xff])/$enc{$1} || '&#' . ord($1) . ';' /ge;
      utf8::downgrade($str);
      $str;
  }
  
  sub Devel::StackTrace::as_html {
      __PACKAGE__->render(@_);
  }
  
  sub render {
      my $class = shift;
      my $trace = shift;
      my %opt   = @_;
  
      my $msg = encode_html($trace->frame(1)->args);
      my $out = qq{<!doctype html><head><title>Error: ${msg}</title>};
  
      $opt{style} ||= \<<STYLE;
  a.toggle { color: #444 }
  body { margin: 0; padding: 0; background: #fff; color: #000; }
  h1 { margin: 0 0 .5em; padding: .25em .5em .1em 1.5em; border-bottom: thick solid #002; background: #444; color: #eee; font-size: x-large; }
  pre.message { margin: .5em 1em; }
  li.frame { font-size: small; margin-top: 3em }
  li.frame:nth-child(1) { margin-top: 0 }
  pre.context { border: 1px solid #aaa; padding: 0.2em 0; background: #fff; color: #444; font-size: medium; }
  pre .match { color: #000;background-color: #f99; font-weight: bold }
  pre.vardump { margin:0 }
  pre code strong { color: #000; background: #f88; }
  
  table.lexicals, table.arguments { border-collapse: collapse }
  table.lexicals td, table.arguments td { border: 1px solid #000; margin: 0; padding: .3em }
  table.lexicals tr:nth-child(2n) { background: #DDDDFF }
  table.arguments tr:nth-child(2n) { background: #DDFFDD }
  .lexicals, .arguments { display: none }
  .variable, .value { font-family: monospace; white-space: pre }
  td.variable { vertical-align: top }
  STYLE
  
      if (ref $opt{style}) {
          $out .= qq(<style type="text/css">${$opt{style}}</style>);
      } else {
          $out .= qq(<link rel="stylesheet" type="text/css" href=") . encode_html($opt{style}) . q(" />);
      }
  
      $out .= <<HEAD;
  <script language="JavaScript" type="text/javascript">
  function toggleThing(ref, type, hideMsg, showMsg) {
   var css = document.getElementById(type+'-'+ref).style;
   css.display = css.display == 'block' ? 'none' : 'block';
  
   var hyperlink = document.getElementById('toggle-'+ref);
   hyperlink.textContent = css.display == 'block' ? hideMsg : showMsg;
  }
  
  function toggleArguments(ref) {
   toggleThing(ref, 'arguments', 'Hide function arguments', 'Show function arguments');
  }
  
  function toggleLexicals(ref) {
   toggleThing(ref, 'lexicals', 'Hide lexical variables', 'Show lexical variables');
  }
  </script>
  </head>
  <body>
  <h1>Error trace</h1><pre class="message">$msg</pre><ol>
  HEAD
  
      $trace->next_frame; # ignore the head
      my $i = 0;
      while (my $frame = $trace->next_frame) {
          $i++;
          $out .= join(
              '',
              '<li class="frame">',
              $frame->subroutine ? encode_html("in " . $frame->subroutine) : '',
              ' at ',
              $frame->filename ? encode_html($frame->filename) : '',
              ' line ',
              $frame->line,
              q(<pre class="context"><code>),
              _build_context($frame) || '',
              q(</code></pre>),
              _build_arguments($i, [$frame->args]),
              $frame->can('lexicals') ? _build_lexicals($i, $frame->lexicals) : '',
              q(</li>),
          );
      }
      $out .= qq{</ol>};
      $out .= "</body></html>";
  
      $out;
  }
  
  my $dumper = sub {
      my $value = shift;
      $value = $$value if ref $value eq 'SCALAR' or ref $value eq 'REF';
      my $d = Data::Dumper->new([ $value ]);
      $d->Indent(1)->Terse(1)->Deparse(1);
      chomp(my $dump = $d->Dump);
      $dump;
  };
  
  sub _build_arguments {
      my($id, $args) = @_;
      my $ref = "arg-$id";
  
      return '' unless @$args;
  
      my $html = qq(<p><a class="toggle" id="toggle-$ref" href="javascript:toggleArguments('$ref')">Show function arguments</a></p><table class="arguments" id="arguments-$ref">);
  
      # Don't use while each since Dumper confuses that
      for my $idx (0 .. @$args - 1) {
          my $value = $args->[$idx];
          my $dump = $dumper->($value);
          $html .= qq{<tr>};
          $html .= qq{<td class="variable">\$_[$idx]</td>};
          $html .= qq{<td class="value">} . encode_html($dump) . qq{</td>};
          $html .= qq{</tr>};
      }
      $html .= qq(</table>);
  
      return $html;
  }
  
  sub _build_lexicals {
      my($id, $lexicals) = @_;
      my $ref = "lex-$id";
  
      return '' unless keys %$lexicals;
  
      my $html = qq(<p><a class="toggle" id="toggle-$ref" href="javascript:toggleLexicals('$ref')">Show lexical variables</a></p><table class="lexicals" id="lexicals-$ref">);
  
      # Don't use while each since Dumper confuses that
      for my $var (sort keys %$lexicals) {
          my $value = $lexicals->{$var};
          my $dump = $dumper->($value);
          $dump =~ s/^\{(.*)\}$/($1)/s if $var =~ /^\%/;
          $dump =~ s/^\[(.*)\]$/($1)/s if $var =~ /^\@/;
          $html .= qq{<tr>};
          $html .= qq{<td class="variable">} . encode_html($var)  . qq{</td>};
          $html .= qq{<td class="value">}    . encode_html($dump) . qq{</td>};
          $html .= qq{</tr>};
      }
      $html .= qq(</table>);
  
      return $html;
  }
  
  sub _build_context {
      my $frame = shift;
      my $file    = $frame->filename;
      my $linenum = $frame->line;
      my $code;
      if (-f $file) {
          my $start = $linenum - 3;
          my $end   = $linenum + 3;
          $start = $start < 1 ? 1 : $start;
          open my $fh, '<', $file
              or die "cannot open $file:$!";
          my $cur_line = 0;
          while (my $line = <$fh>) {
              ++$cur_line;
              last if $cur_line > $end;
              next if $cur_line < $start;
              $line =~ s|\t|        |g;
              my @tag = $cur_line == $linenum
                  ? (q{<strong class="match">}, '</strong>')
                      : ('', '');
              $code .= sprintf(
                  '%s%5d: %s%s', $tag[0], $cur_line, encode_html($line),
                  $tag[1],
              );
          }
          close $file;
      }
      return $code;
  }
  
  1;
  __END__
  
  =encoding utf-8
  
  =for stopwords
  
  =head1 NAME
  
  Devel::StackTrace::AsHTML - Displays stack trace in HTML
  
  =head1 SYNOPSIS
  
    use Devel::StackTrace::AsHTML;
  
    my $trace = Devel::StackTrace->new;
    my $html  = $trace->as_html;
  
  =head1 DESCRIPTION
  
  Devel::StackTrace::AsHTML adds C<as_html> method to L<Devel::StackTrace> which
  displays the stack trace in beautiful HTML, with code snippet context and
  function parameters. If you call it on an instance of
  L<Devel::StackTrace::WithLexicals>, you even get to see the lexical variables
  of each stack frame.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa E<lt>miyagawa@bulknews.netE<gt>
  
  Shawn M Moore
  
  HTML generation code is ripped off from L<CGI::ExceptionManager> written by Tokuhiro Matsuno and Kazuho Oku.
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<Devel::StackTrace> L<Devel::StackTrace::WithLexicals> L<CGI::ExceptionManager>
  
  =cut
DEVEL_STACKTRACE_ASHTML

$fatpacked{"Digest.pm"} = <<'DIGEST';
  package Digest;
  
  use strict;
  use vars qw($VERSION %MMAP $AUTOLOAD);
  
  $VERSION = "1.16";
  
  %MMAP = (
    "SHA-1"      => [["Digest::SHA", 1], "Digest::SHA1", ["Digest::SHA2", 1]],
    "SHA-224"    => [["Digest::SHA", 224]],
    "SHA-256"    => [["Digest::SHA", 256], ["Digest::SHA2", 256]],
    "SHA-384"    => [["Digest::SHA", 384], ["Digest::SHA2", 384]],
    "SHA-512"    => [["Digest::SHA", 512], ["Digest::SHA2", 512]],
    "HMAC-MD5"   => "Digest::HMAC_MD5",
    "HMAC-SHA-1" => "Digest::HMAC_SHA1",
    "CRC-16"     => [["Digest::CRC", type => "crc16"]],
    "CRC-32"     => [["Digest::CRC", type => "crc32"]],
    "CRC-CCITT"  => [["Digest::CRC", type => "crcccitt"]],
    "RIPEMD-160" => "Crypt::PIPEMD160",
  );
  
  sub new
  {
      shift;  # class ignored
      my $algorithm = shift;
      my $impl = $MMAP{$algorithm} || do {
  	$algorithm =~ s/\W+//;
  	"Digest::$algorithm";
      };
      $impl = [$impl] unless ref($impl);
      my $err;
      for  (@$impl) {
  	my $class = $_;
  	my @args;
  	($class, @args) = @$class if ref($class);
  	no strict 'refs';
  	unless (exists ${"$class\::"}{"VERSION"}) {
  	    eval "require $class";
  	    if ($@) {
  		$err ||= $@;
  		next;
  	    }
  	}
  	return $class->new(@args, @_);
      }
      die $err;
  }
  
  sub AUTOLOAD
  {
      my $class = shift;
      my $algorithm = substr($AUTOLOAD, rindex($AUTOLOAD, '::')+2);
      $class->new($algorithm, @_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Digest - Modules that calculate message digests
  
  =head1 SYNOPSIS
  
    $md5  = Digest->new("MD5");
    $sha1 = Digest->new("SHA-1");
    $sha256 = Digest->new("SHA-256");
    $sha384 = Digest->new("SHA-384");
    $sha512 = Digest->new("SHA-512");
  
    $hmac = Digest->HMAC_MD5($key);
  
  =head1 DESCRIPTION
  
  The C<Digest::> modules calculate digests, also called "fingerprints"
  or "hashes", of some data, called a message.  The digest is (usually)
  some small/fixed size string.  The actual size of the digest depend of
  the algorithm used.  The message is simply a sequence of arbitrary
  bytes or bits.
  
  An important property of the digest algorithms is that the digest is
  I<likely> to change if the message change in some way.  Another
  property is that digest functions are one-way functions, that is it
  should be I<hard> to find a message that correspond to some given
  digest.  Algorithms differ in how "likely" and how "hard", as well as
  how efficient they are to compute.
  
  Note that the properties of the algorithms change over time, as the
  algorithms are analyzed and machines grow faster.  If your application
  for instance depends on it being "impossible" to generate the same
  digest for a different message it is wise to make it easy to plug in
  stronger algorithms as the one used grow weaker.  Using the interface
  documented here should make it easy to change algorithms later.
  
  All C<Digest::> modules provide the same programming interface.  A
  functional interface for simple use, as well as an object oriented
  interface that can handle messages of arbitrary length and which can
  read files directly.
  
  The digest can be delivered in three formats:
  
  =over 8
  
  =item I<binary>
  
  This is the most compact form, but it is not well suited for printing
  or embedding in places that can't handle arbitrary data.
  
  =item I<hex>
  
  A twice as long string of lowercase hexadecimal digits.
  
  =item I<base64>
  
  A string of portable printable characters.  This is the base64 encoded
  representation of the digest with any trailing padding removed.  The
  string will be about 30% longer than the binary version.
  L<MIME::Base64> tells you more about this encoding.
  
  =back
  
  
  The functional interface is simply importable functions with the same
  name as the algorithm.  The functions take the message as argument and
  return the digest.  Example:
  
    use Digest::MD5 qw(md5);
    $digest = md5($message);
  
  There are also versions of the functions with "_hex" or "_base64"
  appended to the name, which returns the digest in the indicated form.
  
  =head1 OO INTERFACE
  
  The following methods are available for all C<Digest::> modules:
  
  =over 4
  
  =item $ctx = Digest->XXX($arg,...)
  
  =item $ctx = Digest->new(XXX => $arg,...)
  
  =item $ctx = Digest::XXX->new($arg,...)
  
  The constructor returns some object that encapsulate the state of the
  message-digest algorithm.  You can add data to the object and finally
  ask for the digest.  The "XXX" should of course be replaced by the proper
  name of the digest algorithm you want to use.
  
  The two first forms are simply syntactic sugar which automatically
  load the right module on first use.  The second form allow you to use
  algorithm names which contains letters which are not legal perl
  identifiers, e.g. "SHA-1".  If no implementation for the given algorithm
  can be found, then an exception is raised.
  
  If new() is called as an instance method (i.e. $ctx->new) it will just
  reset the state the object to the state of a newly created object.  No
  new object is created in this case, and the return value is the
  reference to the object (i.e. $ctx).
  
  =item $other_ctx = $ctx->clone
  
  The clone method creates a copy of the digest state object and returns
  a reference to the copy.
  
  =item $ctx->reset
  
  This is just an alias for $ctx->new.
  
  =item $ctx->add( $data )
  
  =item $ctx->add( $chunk1, $chunk2, ... )
  
  The string value of the $data provided as argument is appended to the
  message we calculate the digest for.  The return value is the $ctx
  object itself.
  
  If more arguments are provided then they are all appended to the
  message, thus all these lines will have the same effect on the state
  of the $ctx object:
  
    $ctx->add("a"); $ctx->add("b"); $ctx->add("c");
    $ctx->add("a")->add("b")->add("c");
    $ctx->add("a", "b", "c");
    $ctx->add("abc");
  
  Most algorithms are only defined for strings of bytes and this method
  might therefore croak if the provided arguments contain chars with
  ordinal number above 255.
  
  =item $ctx->addfile( $io_handle )
  
  The $io_handle is read until EOF and the content is appended to the
  message we calculate the digest for.  The return value is the $ctx
  object itself.
  
  The addfile() method will croak() if it fails reading data for some
  reason.  If it croaks it is unpredictable what the state of the $ctx
  object will be in. The addfile() method might have been able to read
  the file partially before it failed.  It is probably wise to discard
  or reset the $ctx object if this occurs.
  
  In most cases you want to make sure that the $io_handle is in
  "binmode" before you pass it as argument to the addfile() method.
  
  =item $ctx->add_bits( $data, $nbits )
  
  =item $ctx->add_bits( $bitstring )
  
  The add_bits() method is an alternative to add() that allow partial
  bytes to be appended to the message.  Most users should just ignore
  this method as partial bytes is very unlikely to be of any practical
  use.
  
  The two argument form of add_bits() will add the first $nbits bits
  from $data.  For the last potentially partial byte only the high order
  C<< $nbits % 8 >> bits are used.  If $nbits is greater than C<<
  length($data) * 8 >>, then this method would do the same as C<<
  $ctx->add($data) >>.
  
  The one argument form of add_bits() takes a $bitstring of "1" and "0"
  chars as argument.  It's a shorthand for C<< $ctx->add_bits(pack("B*",
  $bitstring), length($bitstring)) >>.
  
  The return value is the $ctx object itself.
  
  This example shows two calls that should have the same effect:
  
     $ctx->add_bits("111100001010");
     $ctx->add_bits("\xF0\xA0", 12);
  
  Most digest algorithms are byte based and for these it is not possible
  to add bits that are not a multiple of 8, and the add_bits() method
  will croak if you try.
  
  =item $ctx->digest
  
  Return the binary digest for the message.
  
  Note that the C<digest> operation is effectively a destructive,
  read-once operation. Once it has been performed, the $ctx object is
  automatically C<reset> and can be used to calculate another digest
  value.  Call $ctx->clone->digest if you want to calculate the digest
  without resetting the digest state.
  
  =item $ctx->hexdigest
  
  Same as $ctx->digest, but will return the digest in hexadecimal form.
  
  =item $ctx->b64digest
  
  Same as $ctx->digest, but will return the digest as a base64 encoded
  string.
  
  =back
  
  =head1 Digest speed
  
  This table should give some indication on the relative speed of
  different algorithms.  It is sorted by throughput based on a benchmark
  done with of some implementations of this API:
  
   Algorithm      Size    Implementation                  MB/s
  
   MD4            128     Digest::MD4 v1.3               165.0
   MD5            128     Digest::MD5 v2.33               98.8
   SHA-256        256     Digest::SHA2 v1.1.0             66.7
   SHA-1          160     Digest::SHA v4.3.1              58.9
   SHA-1          160     Digest::SHA1 v2.10              48.8
   SHA-256        256     Digest::SHA v4.3.1              41.3
   Haval-256      256     Digest::Haval256 v1.0.4         39.8
   SHA-384        384     Digest::SHA2 v1.1.0             19.6
   SHA-512        512     Digest::SHA2 v1.1.0             19.3
   SHA-384        384     Digest::SHA v4.3.1              19.2
   SHA-512        512     Digest::SHA v4.3.1              19.2
   Whirlpool      512     Digest::Whirlpool v1.0.2        13.0
   MD2            128     Digest::MD2 v2.03                9.5
  
   Adler-32        32     Digest::Adler32 v0.03            1.3
   CRC-16          16     Digest::CRC v0.05                1.1
   CRC-32          32     Digest::CRC v0.05                1.1
   MD5            128     Digest::Perl::MD5 v1.5           1.0
   CRC-CCITT       16     Digest::CRC v0.05                0.8
  
  These numbers was achieved Apr 2004 with ActivePerl-5.8.3 running
  under Linux on a P4 2.8 GHz CPU.  The last 5 entries differ by being
  pure perl implementations of the algorithms, which explains why they
  are so slow.
  
  =head1 SEE ALSO
  
  L<Digest::Adler32>, L<Digest::CRC>, L<Digest::Haval256>,
  L<Digest::HMAC>, L<Digest::MD2>, L<Digest::MD4>, L<Digest::MD5>,
  L<Digest::SHA>, L<Digest::SHA1>, L<Digest::SHA2>, L<Digest::Whirlpool>
  
  New digest implementations should consider subclassing from L<Digest::base>.
  
  L<MIME::Base64>
  
  http://en.wikipedia.org/wiki/Cryptographic_hash_function
  
  =head1 AUTHOR
  
  Gisle Aas <gisle@aas.no>
  
  The C<Digest::> interface is based on the interface originally
  developed by Neil Winton for his C<MD5> module.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
      Copyright 1998-2006 Gisle Aas.
      Copyright 1995,1996 Neil Winton.
  
  =cut
DIGEST

$fatpacked{"Digest/base.pm"} = <<'DIGEST_BASE';
  package Digest::base;
  
  use strict;
  use vars qw($VERSION);
  $VERSION = "1.16";
  
  # subclass is supposed to implement at least these
  sub new;
  sub clone;
  sub add;
  sub digest;
  
  sub reset {
      my $self = shift;
      $self->new(@_);  # ugly
  }
  
  sub addfile {
      my ($self, $handle) = @_;
  
      my $n;
      my $buf = "";
  
      while (($n = read($handle, $buf, 4*1024))) {
          $self->add($buf);
      }
      unless (defined $n) {
  	require Carp;
  	Carp::croak("Read failed: $!");
      }
  
      $self;
  }
  
  sub add_bits {
      my $self = shift;
      my $bits;
      my $nbits;
      if (@_ == 1) {
  	my $arg = shift;
  	$bits = pack("B*", $arg);
  	$nbits = length($arg);
      }
      else {
  	($bits, $nbits) = @_;
      }
      if (($nbits % 8) != 0) {
  	require Carp;
  	Carp::croak("Number of bits must be multiple of 8 for this algorithm");
      }
      return $self->add(substr($bits, 0, $nbits/8));
  }
  
  sub hexdigest {
      my $self = shift;
      return unpack("H*", $self->digest(@_));
  }
  
  sub b64digest {
      my $self = shift;
      require MIME::Base64;
      my $b64 = MIME::Base64::encode($self->digest(@_), "");
      $b64 =~ s/=+$//;
      return $b64;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Digest::base - Digest base class
  
  =head1 SYNOPSIS
  
    package Digest::Foo;
    use base 'Digest::base';
  
  =head1 DESCRIPTION
  
  The C<Digest::base> class provide implementations of the methods
  C<addfile> and C<add_bits> in terms of C<add>, and of the methods
  C<hexdigest> and C<b64digest> in terms of C<digest>.
  
  Digest implementations might want to inherit from this class to get
  this implementations of the alternative I<add> and I<digest> methods.
  A minimal subclass needs to implement the following methods by itself:
  
      new
      clone
      add
      digest
  
  The arguments and expected behaviour of these methods are described in
  L<Digest>.
  
  =head1 SEE ALSO
  
  L<Digest>
DIGEST_BASE

$fatpacked{"Digest/file.pm"} = <<'DIGEST_FILE';
  package Digest::file;
  
  use strict;
  
  use Exporter ();
  use Carp qw(croak);
  use Digest ();
  
  use vars qw($VERSION @ISA @EXPORT_OK);
  
  $VERSION = "1.16";
  @ISA = qw(Exporter);
  @EXPORT_OK = qw(digest_file_ctx digest_file digest_file_hex digest_file_base64);
  
  sub digest_file_ctx {
      my $file = shift;
      croak("No digest algorithm specified") unless @_;
      local *F;
      open(F, "<", $file) || croak("Can't open '$file': $!");
      binmode(F);
      my $ctx = Digest->new(@_);
      $ctx->addfile(*F);
      close(F);
      return $ctx;
  }
  
  sub digest_file {
      digest_file_ctx(@_)->digest;
  }
  
  sub digest_file_hex {
      digest_file_ctx(@_)->hexdigest;
  }
  
  sub digest_file_base64 {
      digest_file_ctx(@_)->b64digest;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Digest::file - Calculate digests of files
  
  =head1 SYNOPSIS
  
    # Poor mans "md5sum" command
    use Digest::file qw(digest_file_hex);
    for (@ARGV) {
        print digest_file_hex($_, "MD5"), "  $_\n";
    }
  
  =head1 DESCRIPTION
  
  This module provide 3 convenience functions to calculate the digest
  of files.  The following functions are provided:
  
  =over
  
  =item digest_file( $file, $algorithm, [$arg,...] )
  
  This function will calculate and return the binary digest of the bytes
  of the given file.  The function will croak if it fails to open or
  read the file.
  
  The $algorithm is a string like "MD2", "MD5", "SHA-1", "SHA-512".
  Additional arguments are passed to the constructor for the
  implementation of the given algorithm.
  
  =item digest_file_hex( $file, $algorithm, [$arg,...] )
  
  Same as digest_file(), but return the digest in hex form.
  
  =item digest_file_base64( $file, $algorithm, [$arg,...] )
  
  Same as digest_file(), but return the digest as a base64 encoded
  string.
  
  =back
  
  =head1 SEE ALSO
  
  L<Digest>
DIGEST_FILE

$fatpacked{"File/Listing.pm"} = <<'FILE_LISTING';
  package File::Listing;
  
  sub Version { $VERSION; }
  $VERSION = "5.814";
  
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT = qw(parse_dir);
  
  use strict;
  
  use Carp ();
  use HTTP::Date qw(str2time);
  
  
  
  sub parse_dir ($;$$$)
  {
     my($dir, $tz, $fstype, $error) = @_;
  
     $fstype ||= 'unix';
     $fstype = "File::Listing::" . lc $fstype;
  
     my @args = $_[0];
     push(@args, $tz) if(@_ >= 2);
     push(@args, $error) if(@_ >= 4);
  
     $fstype->parse(@args);
  }
  
  
  sub line { Carp::croak("Not implemented yet"); }
  sub init { } # Dummy sub
  
  
  sub file_mode ($)
  {
      # This routine was originally borrowed from Graham Barr's
      # Net::FTP package.
  
      local $_ = shift;
      my $mode = 0;
      my($type,$ch);
  
      s/^(.)// and $type = $1;
  
      while (/(.)/g) {
  	$mode <<= 1;
  	$mode |= 1 if $1 ne "-" &&
  		      $1 ne 'S' &&
  		      $1 ne 't' &&
  		      $1 ne 'T';
      }
  
      $type eq "d" and $mode |= 0040000 or	# Directory
        $type eq "l" and $mode |= 0120000 or	# Symbolic Link
  	$mode |= 0100000;			# Regular File
  
      $mode |= 0004000 if /^...s....../i;
      $mode |= 0002000 if /^......s.../i;
      $mode |= 0001000 if /^.........t/i;
  
      $mode;
  }
  
  
  sub parse
  {
     my($pkg, $dir, $tz, $error) = @_;
  
     # First let's try to determine what kind of dir parameter we have
     # received.  We allow both listings, reference to arrays and
     # file handles to read from.
  
     if (ref($dir) eq 'ARRAY') {
         # Already splitted up
     }
     elsif (ref($dir) eq 'GLOB') {
         # A file handle
     }
     elsif (ref($dir)) {
        Carp::croak("Illegal argument to parse_dir()");
     }
     elsif ($dir =~ /^\*\w+(::\w+)+$/) {
        # This scalar looks like a file handle, so we assume it is
     }
     else {
        # A normal scalar listing
        $dir = [ split(/\n/, $dir) ];
     }
  
     $pkg->init();
  
     my @files = ();
     if (ref($dir) eq 'ARRAY') {
         for (@$dir) {
  	   push(@files, $pkg->line($_, $tz, $error));
         }
     }
     else {
         local($_);
         while (<$dir>) {
  	   chomp;
  	   push(@files, $pkg->line($_, $tz, $error));
         }
     }
     wantarray ? @files : \@files;
  }
  
  
  
  package File::Listing::unix;
  
  use HTTP::Date qw(str2time);
  
  # A place to remember current directory from last line parsed.
  use vars qw($curdir @ISA);
  
  @ISA = qw(File::Listing);
  
  
  
  sub init
  {
      $curdir = '';
  }
  
  
  sub line
  {
      shift; # package name
      local($_) = shift;
      my($tz, $error) = @_;
  
      s/\015//g;
      #study;
  
      my ($kind, $size, $date, $name);
      if (($kind, $size, $date, $name) =
  	/^([\-FlrwxsStTdD]{10})                   # Type and permission bits
  	 .*                                       # Graps
  	 \D(\d+)                                  # File size
  	 \s+                                      # Some space
  	 (\w{3}\s+\d+\s+(?:\d{1,2}:\d{2}|\d{4})|\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2})  # Date
  	 \s+                                      # Some more space
  	 (.*)$                                    # File name
  	/x )
  
      {
  	return if $name eq '.' || $name eq '..';
  	$name = "$curdir/$name" if length $curdir;
  	my $type = '?';
  	if ($kind =~ /^l/ && $name =~ /(.*) -> (.*)/ ) {
  	    $name = $1;
  	    $type = "l $2";
  	}
  	elsif ($kind =~ /^[\-F]/) { # (hopefully) a regular file
  	    $type = 'f';
  	}
  	elsif ($kind =~ /^[dD]/) {
  	    $type = 'd';
  	    $size = undef;  # Don't believe the reported size
  	}
  	return [$name, $type, $size, str2time($date, $tz), 
                File::Listing::file_mode($kind)];
  
      }
      elsif (/^(.+):$/ && !/^[dcbsp].*\s.*\s.*:$/ ) {
  	my $dir = $1;
  	return () if $dir eq '.';
  	$curdir = $dir;
  	return ();
      }
      elsif (/^[Tt]otal\s+(\d+)$/ || /^\s*$/) {
  	return ();
      }
      elsif (/not found/    || # OSF1, HPUX, and SunOS return
               # "$file not found"
               /No such file/ || # IRIX returns
               # "UX:ls: ERROR: Cannot access $file: No such file or directory"
                                 # Solaris returns
               # "$file: No such file or directory"
               /cannot find/     # Windows NT returns
               # "The system cannot find the path specified."
               ) {
  	return () unless defined $error;
  	&$error($_) if ref($error) eq 'CODE';
  	warn "Error: $_\n" if $error eq 'warn';
  	return ();
      }
      elsif ($_ eq '') {       # AIX, and Linux return nothing
  	return () unless defined $error;
  	&$error("No such file or directory") if ref($error) eq 'CODE';
  	warn "Warning: No such file or directory\n" if $error eq 'warn';
  	return ();
      }
      else {
          # parse failed, check if the dosftp parse understands it
          File::Listing::dosftp->init();
          return(File::Listing::dosftp->line($_,$tz,$error));
      }
  
  }
  
  
  
  package File::Listing::dosftp;
  
  use HTTP::Date qw(str2time);
  
  # A place to remember current directory from last line parsed.
  use vars qw($curdir @ISA);
  
  @ISA = qw(File::Listing);
  
  
  
  sub init
  {
      $curdir = '';
  }
  
  
  sub line
  {
      shift; # package name
      local($_) = shift;
      my($tz, $error) = @_;
  
      s/\015//g;
  
      my ($date, $size_or_dir, $name, $size);
  
      # 02-05-96  10:48AM                 1415 src.slf
      # 09-10-96  09:18AM       <DIR>          sl_util
      if (($date, $size_or_dir, $name) =
          /^(\d\d-\d\d-\d\d\s+\d\d:\d\d\wM)         # Date and time info
           \s+                                      # Some space
           (<\w{3}>|\d+)                            # Dir or Size
           \s+                                      # Some more space
           (.+)$                                    # File name
          /x )
      {
  	return if $name eq '.' || $name eq '..';
  	$name = "$curdir/$name" if length $curdir;
  	my $type = '?';
  	if ($size_or_dir eq '<DIR>') {
  	    $type = "d";
              $size = ""; # directories have no size in the pc listing
          }
          else {
  	    $type = 'f';
              $size = $size_or_dir;
  	}
  	return [$name, $type, $size, str2time($date, $tz), undef];
      }
      else {
  	return () unless defined $error;
  	&$error($_) if ref($error) eq 'CODE';
  	warn "Can't parse: $_\n" if $error eq 'warn';
  	return ();
      }
  
  }
  
  
  
  package File::Listing::vms;
  @File::Listing::vms::ISA = qw(File::Listing);
  
  package File::Listing::netware;
  @File::Listing::netware::ISA = qw(File::Listing);
  
  
  
  package File::Listing::apache;
  
  use vars qw(@ISA);
  
  @ISA = qw(File::Listing);
  
  
  sub init { }
  
  
  sub line {
      shift; # package name
      local($_) = shift;
      my($tz, $error) = @_; # ignored for now...
  
      if (m!<A\s+HREF=\"([^\"]+)\">.*</A>.*?(\d+)-([a-zA-Z]+)-(\d+)\s+(\d+):(\d+)\s+(?:([\d\.]+[kM]?|-))!i) {
  	my($filename, $filesize) = ($1, $7);
  	my($d,$m,$y, $H,$M) = ($2,$3,$4,$5,$6);
  
  	$filesize = 0 if $filesize eq '-';
  	if ($filesize =~ s/k$//i) {
  	    $filesize *= 1024;
  	}
  	elsif ($filesize =~ s/M$//) {
  	    $filesize *= 1024*1024;
  	}
  	elsif ($filesize =~ s/G$//) {
  	    $filesize *= 1024*1024*1024;
  	}
  	$filesize = int $filesize;
  
  	require Time::Local;
  	my $filetime = Time::Local::timelocal(0,$M,$H,$d,_monthabbrev_number($m)-1,_guess_year($y)-1900);
  	my $filetype = ($filename =~ s|/$|| ? "d" : "f");
  	return [$filename, $filetype, $filesize, $filetime, undef];
      }
  
      return ();
  }
  
  
  sub _guess_year {
      my $y = shift;
      if ($y >= 90) {
  	$y = 1900+$y;
      }
      elsif ($y < 100) {
  	$y = 2000+$y;
      }
      $y;
  }
  
  
  sub _monthabbrev_number {
      my $mon = shift;
      +{'Jan' => 1,
        'Feb' => 2,
        'Mar' => 3,
        'Apr' => 4,
        'May' => 5,
        'Jun' => 6,
        'Jul' => 7,
        'Aug' => 8,
        'Sep' => 9,
        'Oct' => 10,
        'Nov' => 11,
        'Dec' => 12,
       }->{$mon};
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  File::Listing - parse directory listing
  
  =head1 SYNOPSIS
  
   use File::Listing qw(parse_dir);
   $ENV{LANG} = "C";  # dates in non-English locales not supported
   for (parse_dir(`ls -l`)) {
       ($name, $type, $size, $mtime, $mode) = @$_;
       next if $type ne 'f'; # plain file
       #...
   }
  
   # directory listing can also be read from a file
   open(LISTING, "zcat ls-lR.gz|");
   $dir = parse_dir(\*LISTING, '+0000');
  
  =head1 DESCRIPTION
  
  This module exports a single function called parse_dir(), which can be
  used to parse directory listings.
  
  The first parameter to parse_dir() is the directory listing to parse.
  It can be a scalar, a reference to an array of directory lines or a
  glob representing a filehandle to read the directory listing from.
  
  The second parameter is the time zone to use when parsing time stamps
  in the listing. If this value is undefined, then the local time zone is
  assumed.
  
  The third parameter is the type of listing to assume.  Currently
  supported formats are 'unix', 'apache' and 'dosftp'.  The default
  value 'unix'.  Ideally, the listing type should be determined
  automatically.
  
  The fourth parameter specifies how unparseable lines should be treated.
  Values can be 'ignore', 'warn' or a code reference.  Warn means that
  the perl warn() function will be called.  If a code reference is
  passed, then this routine will be called and the return value from it
  will be incorporated in the listing.  The default is 'ignore'.
  
  Only the first parameter is mandatory.
  
  The return value from parse_dir() is a list of directory entries.  In
  a scalar context the return value is a reference to the list.  The
  directory entries are represented by an array consisting of [
  $filename, $filetype, $filesize, $filetime, $filemode ].  The
  $filetype value is one of the letters 'f', 'd', 'l' or '?'.  The
  $filetime value is the seconds since Jan 1, 1970.  The
  $filemode is a bitmask like the mode returned by stat().
  
  =head1 CREDITS
  
  Based on lsparse.pl (from Lee McLoughlin's ftp mirror package) and
  Net::FTP's parse_dir (Graham Barr).
FILE_LISTING

$fatpacked{"File/Slurp.pm"} = <<'FILE_SLURP';
  package File::Slurp;
  
  use strict;
  
  use Carp ;
  use POSIX qw( :fcntl_h ) ;
  use Fcntl qw( :DEFAULT ) ;
  use Symbol ;
  
  my $is_win32 = $^O =~ /win32/i ;
  
  # Install subs for various constants that aren't set in older perls
  # (< 5.005).  Fcntl on old perls uses Exporter to define subs without a
  # () prototype These can't be overridden with the constant pragma or
  # we get a prototype mismatch.  Hence this less than aesthetically
  # appealing BEGIN block:
  
  BEGIN {
  	unless( eval { defined SEEK_SET() } ) {
  		*SEEK_SET = sub { 0 };
  		*SEEK_CUR = sub { 1 };
  		*SEEK_END = sub { 2 };
  	}
  
  	unless( eval { defined O_BINARY() } ) {
  		*O_BINARY = sub { 0 };
  		*O_RDONLY = sub { 0 };
  		*O_WRONLY = sub { 1 };
  	}
  
  	unless ( eval { defined O_APPEND() } ) {
  
  		if ( $^O =~ /olaris/ ) {
  			*O_APPEND = sub { 8 };
  			*O_CREAT = sub { 256 };
  			*O_EXCL = sub { 1024 };
  		}
  		elsif ( $^O =~ /inux/ ) {
  			*O_APPEND = sub { 1024 };
  			*O_CREAT = sub { 64 };
  			*O_EXCL = sub { 128 };
  		}
  		elsif ( $^O =~ /BSD/i ) {
  			*O_APPEND = sub { 8 };
  			*O_CREAT = sub { 512 };
  			*O_EXCL = sub { 2048 };
  		}
  	}
  }
  
  # print "OS [$^O]\n" ;
  
  # print "O_BINARY = ", O_BINARY(), "\n" ;
  # print "O_RDONLY = ", O_RDONLY(), "\n" ;
  # print "O_WRONLY = ", O_WRONLY(), "\n" ;
  # print "O_APPEND = ", O_APPEND(), "\n" ;
  # print "O_CREAT   ", O_CREAT(), "\n" ;
  # print "O_EXCL   ", O_EXCL(), "\n" ;
  
  use base 'Exporter' ;
  use vars qw( %EXPORT_TAGS @EXPORT_OK $VERSION @EXPORT ) ;
  
  %EXPORT_TAGS = ( 'all' => [
  	qw( read_file write_file overwrite_file append_file read_dir ) ] ) ;
  
  @EXPORT = ( @{ $EXPORT_TAGS{'all'} } );
  @EXPORT_OK = qw( slurp ) ;
  
  $VERSION = '9999.13';
  
  *slurp = \&read_file ;
  
  sub read_file {
  
  	my( $file_name, %args ) = @_ ;
  
  # set the buffer to either the passed in one or ours and init it to the null
  # string
  
  	my $buf ;
  	my $buf_ref = $args{'buf_ref'} || \$buf ;
  	${$buf_ref} = '' ;
  
  	my( $read_fh, $size_left, $blk_size ) ;
  
  # check if we are reading from a handle (glob ref or IO:: object)
  
  	if ( ref $file_name ) {
  
  # slurping a handle so use it and don't open anything.
  # set the block size so we know it is a handle and read that amount
  
  		$read_fh = $file_name ;
  		$blk_size = $args{'blk_size'} || 1024 * 1024 ;
  		$size_left = $blk_size ;
  
  # DEEP DARK MAGIC. this checks the UNTAINT IO flag of a
  # glob/handle. only the DATA handle is untainted (since it is from
  # trusted data in the source file). this allows us to test if this is
  # the DATA handle and then to do a sysseek to make sure it gets
  # slurped correctly. on some systems, the buffered i/o pointer is not
  # left at the same place as the fd pointer. this sysseek makes them
  # the same so slurping with sysread will work.
  
  		eval{ require B } ;
  
  		if ( $@ ) {
  
  			@_ = ( \%args, <<ERR ) ;
  Can't find B.pm with this Perl: $!.
  That module is needed to slurp the DATA handle.
  ERR
  			goto &_error ;
  		}
  
  		if ( B::svref_2object( $read_fh )->IO->IoFLAGS & 16 ) {
  
  # set the seek position to the current tell.
  
  			sysseek( $read_fh, tell( $read_fh ), SEEK_SET ) ||
  				croak "sysseek $!" ;
  		}
  	}
  	else {
  
  # a regular file. set the sysopen mode
  
  		my $mode = O_RDONLY ;
  		$mode |= O_BINARY if $args{'binmode'} ;
  
  #printf "RD: BINARY %x MODE %x\n", O_BINARY, $mode ;
  
  # open the file and handle any error
  
  		$read_fh = gensym ;
  		unless ( sysopen( $read_fh, $file_name, $mode ) ) {
  			@_ = ( \%args, "read_file '$file_name' - sysopen: $!");
  			goto &_error ;
  		}
  
  # get the size of the file for use in the read loop
  
  		$size_left = -s $read_fh ;
  
  		unless( $size_left ) {
  
  			$blk_size = $args{'blk_size'} || 1024 * 1024 ;
  			$size_left = $blk_size ;
  		}
  	}
  
  # infinite read loop. we exit when we are done slurping
  
  	while( 1 ) {
  
  # do the read and see how much we got
  
  		my $read_cnt = sysread( $read_fh, ${$buf_ref},
  				$size_left, length ${$buf_ref} ) ;
  
  		if ( defined $read_cnt ) {
  
  # good read. see if we hit EOF (nothing left to read)
  
  			last if $read_cnt == 0 ;
  
  # loop if we are slurping a handle. we don't track $size_left then.
  
  			next if $blk_size ;
  
  # count down how much we read and loop if we have more to read.
  			$size_left -= $read_cnt ;
  			last if $size_left <= 0 ;
  			next ;
  		}
  
  # handle the read error
  
  		@_ = ( \%args, "read_file '$file_name' - sysread: $!");
  		goto &_error ;
  	}
  
  # fix up cr/lf to be a newline if this is a windows text file
  
  	${$buf_ref} =~ s/\015\012/\n/g if $is_win32 && !$args{'binmode'} ;
  
  # this is the 5 returns in a row. each handles one possible
  # combination of caller context and requested return type
  
  	my $sep = $/ ;
  	$sep = '\n\n+' if defined $sep && $sep eq '' ;
  
  # caller wants to get an array ref of lines
  
  # this split doesn't work since it tries to use variable length lookbehind
  # the m// line works.
  #	return [ split( m|(?<=$sep)|, ${$buf_ref} ) ] if $args{'array_ref'}  ;
  	return [ length(${$buf_ref}) ? ${$buf_ref} =~ /(.*?$sep|.+)/sg : () ]
  		if $args{'array_ref'}  ;
  
  # caller wants a list of lines (normal list context)
  
  # same problem with this split as before.
  #	return split( m|(?<=$sep)|, ${$buf_ref} ) if wantarray ;
  	return length(${$buf_ref}) ? ${$buf_ref} =~ /(.*?$sep|.+)/sg : ()
  		if wantarray ;
  
  # caller wants a scalar ref to the slurped text
  
  	return $buf_ref if $args{'scalar_ref'} ;
  
  # caller wants a scalar with the slurped text (normal scalar context)
  
  	return ${$buf_ref} if defined wantarray ;
  
  # caller passed in an i/o buffer by reference (normal void context)
  
  	return ;
  }
  
  sub write_file {
  
  	my $file_name = shift ;
  
  # get the optional argument hash ref from @_ or an empty hash ref.
  
  	my $args = ( ref $_[0] eq 'HASH' ) ? shift : {} ;
  
  	my( $buf_ref, $write_fh, $no_truncate, $orig_file_name, $data_is_ref ) ;
  
  # get the buffer ref - it depends on how the data is passed into write_file
  # after this if/else $buf_ref will have a scalar ref to the data.
  
  	if ( ref $args->{'buf_ref'} eq 'SCALAR' ) {
  
  # a scalar ref passed in %args has the data
  # note that the data was passed by ref
  
  		$buf_ref = $args->{'buf_ref'} ;
  		$data_is_ref = 1 ;
  	}
  	elsif ( ref $_[0] eq 'SCALAR' ) {
  
  # the first value in @_ is the scalar ref to the data
  # note that the data was passed by ref
  
  		$buf_ref = shift ;
  		$data_is_ref = 1 ;
  	}
  	elsif ( ref $_[0] eq 'ARRAY' ) {
  
  # the first value in @_ is the array ref to the data so join it.
  
  		${$buf_ref} = join '', @{$_[0]} ;
  	}
  	else {
  
  # good old @_ has all the data so join it.
  
  		${$buf_ref} = join '', @_ ;
  	}
  
  # see if we were passed a open handle to spew to.
  
  	if ( ref $file_name ) {
  
  # we have a handle. make sure we don't call truncate on it.
  
  		$write_fh = $file_name ;
  		$no_truncate = 1 ;
  	}
  	else {
  
  # spew to regular file.
  
  		if ( $args->{'atomic'} ) {
  
  # in atomic mode, we spew to a temp file so make one and save the original
  # file name.
  			$orig_file_name = $file_name ;
  			$file_name .= ".$$" ;
  		}
  
  # set the mode for the sysopen
  
  		my $mode = O_WRONLY | O_CREAT ;
  		$mode |= O_BINARY if $args->{'binmode'} ;
  		$mode |= O_APPEND if $args->{'append'} ;
  		$mode |= O_EXCL if $args->{'no_clobber'} ;
  
  #printf "WR: BINARY %x MODE %x\n", O_BINARY, $mode ;
  
  # open the file and handle any error.
  
  		$write_fh = gensym ;
  		unless ( sysopen( $write_fh, $file_name, $mode ) ) {
  			@_ = ( $args, "write_file '$file_name' - sysopen: $!");
  			goto &_error ;
  		}
  	}
  
  	sysseek( $write_fh, 0, SEEK_END ) if $args->{'append'} ;
  
  
  #print 'WR before data ', unpack( 'H*', ${$buf_ref}), "\n" ;
  
  # fix up newline to write cr/lf if this is a windows text file
  
  	if ( $is_win32 && !$args->{'binmode'} ) {
  
  # copy the write data if it was passed by ref so we don't clobber the
  # caller's data
  		$buf_ref = \do{ my $copy = ${$buf_ref}; } if $data_is_ref ;
  		${$buf_ref} =~ s/\n/\015\012/g ;
  	}
  
  #print 'after data ', unpack( 'H*', ${$buf_ref}), "\n" ;
  
  # get the size of how much we are writing and init the offset into that buffer
  
  	my $size_left = length( ${$buf_ref} ) ;
  	my $offset = 0 ;
  
  # loop until we have no more data left to write
  
  	do {
  
  # do the write and track how much we just wrote
  
  		my $write_cnt = syswrite( $write_fh, ${$buf_ref},
  				$size_left, $offset ) ;
  
  		unless ( defined $write_cnt ) {
  
  # the write failed
  			@_ = ( $args, "write_file '$file_name' - syswrite: $!");
  			goto &_error ;
  		}
  
  # track much left to write and where to write from in the buffer
  
  		$size_left -= $write_cnt ;
  		$offset += $write_cnt ;
  
  	} while( $size_left > 0 ) ;
  
  # we truncate regular files in case we overwrite a long file with a shorter file
  # so seek to the current position to get it (same as tell()).
  
  	truncate( $write_fh,
  		  sysseek( $write_fh, 0, SEEK_CUR ) ) unless $no_truncate ;
  
  	close( $write_fh ) ;
  
  # handle the atomic mode - move the temp file to the original filename.
  
  	rename( $file_name, $orig_file_name ) if $args->{'atomic'} ;
  
  	return 1 ;
  }
  
  # this is for backwards compatibility with the previous File::Slurp module. 
  # write_file always overwrites an existing file
  
  *overwrite_file = \&write_file ;
  
  # the current write_file has an append mode so we use that. this
  # supports the same API with an optional second argument which is a
  # hash ref of options.
  
  sub append_file {
  
  # get the optional args hash ref
  	my $args = $_[1] ;
  	if ( ref $args eq 'HASH' ) {
  
  # we were passed an args ref so just mark the append mode
  
  		$args->{append} = 1 ;
  	}
  	else {
  
  # no args hash so insert one with the append mode
  
  		splice( @_, 1, 0, { append => 1 } ) ;
  	}
  
  # magic goto the main write_file sub. this overlays the sub without touching
  # the stack or @_
  
  	goto &write_file
  }
  
  # basic wrapper around opendir/readdir
  
  sub read_dir {
  
  	my ($dir, %args ) = @_;
  
  # this handle will be destroyed upon return
  
  	local(*DIRH);
  
  # open the dir and handle any errors
  
  	unless ( opendir( DIRH, $dir ) ) {
  
  		@_ = ( \%args, "read_dir '$dir' - opendir: $!" ) ;
  		goto &_error ;
  	}
  
  	my @dir_entries = readdir(DIRH) ;
  
  	@dir_entries = grep( $_ ne "." && $_ ne "..", @dir_entries )
  		unless $args{'keep_dot_dot'} ;
  
  	return @dir_entries if wantarray ;
  	return \@dir_entries ;
  }
  
  # error handling section
  #
  # all the error handling uses magic goto so the caller will get the
  # error message as if from their code and not this module. if we just
  # did a call on the error code, the carp/croak would report it from
  # this module since the error sub is one level down on the call stack
  # from read_file/write_file/read_dir.
  
  
  my %err_func = (
  	'carp'	=> \&carp,
  	'croak'	=> \&croak,
  ) ;
  
  sub _error {
  
  	my( $args, $err_msg ) = @_ ;
  
  # get the error function to use
  
   	my $func = $err_func{ $args->{'err_mode'} || 'croak' } ;
  
  # if we didn't find it in our error function hash, they must have set
  # it to quiet and we don't do anything.
  
  	return unless $func ;
  
  # call the carp/croak function
  
  	$func->($err_msg) ;
  
  # return a hard undef (in list context this will be a single value of
  # undef which is not a legal in-band value)
  
  	return undef ;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  File::Slurp - Efficient Reading/Writing of Complete Files
  
  =head1 SYNOPSIS
  
    use File::Slurp;
  
    my $text = read_file( 'filename' ) ;
    my @lines = read_file( 'filename' ) ;
  
    write_file( 'filename', @lines ) ;
  
    use File::Slurp qw( slurp ) ;
  
    my $text = slurp( 'filename' ) ;
  
  
  =head1 DESCRIPTION
  
  This module provides subs that allow you to read or write entire files
  with one simple call. They are designed to be simple to use, have
  flexible ways to pass in or get the file contents and to be very
  efficient.  There is also a sub to read in all the files in a
  directory other than C<.> and C<..>
  
  These slurp/spew subs work for files, pipes and
  sockets, and stdio, pseudo-files, and DATA.
  
  =head2 B<read_file>
  
  This sub reads in an entire file and returns its contents to the
  caller. In list context it will return a list of lines (using the
  current value of $/ as the separator including support for paragraph
  mode when it is set to ''). In scalar context it returns the entire
  file as a single scalar.
  
    my $text = read_file( 'filename' ) ;
    my @lines = read_file( 'filename' ) ;
  
  The first argument to C<read_file> is the filename and the rest of the
  arguments are key/value pairs which are optional and which modify the
  behavior of the call. Other than binmode the options all control how
  the slurped file is returned to the caller.
  
  If the first argument is a file handle reference or I/O object (if ref
  is true), then that handle is slurped in. This mode is supported so
  you slurp handles such as C<DATA>, C<STDIN>. See the test handle.t
  for an example that does C<open( '-|' )> and child process spews data
  to the parant which slurps it in.  All of the options that control how
  the data is returned to the caller still work in this case.
  
  NOTE: as of version 9999.06, read_file works correctly on the C<DATA>
  handle. It used to need a sysseek workaround but that is now handled
  when needed by the module itself.
  
  You can optionally request that C<slurp()> is exported to your code. This
  is an alias for read_file and is meant to be forward compatible with
  Perl 6 (which will have slurp() built-in).
  
  The options are:
  
  =head3 binmode
  
  If you set the binmode option, then the file will be slurped in binary
  mode.
  
  	my $bin_data = read_file( $bin_file, binmode => ':raw' ) ;
  
  NOTE: this actually sets the O_BINARY mode flag for sysopen. It
  probably should call binmode and pass its argument to support other
  file modes.
  
  =head3 array_ref
  
  If this boolean option is set, the return value (only in scalar
  context) will be an array reference which contains the lines of the
  slurped file. The following two calls are equivalent:
  
  	my $lines_ref = read_file( $bin_file, array_ref => 1 ) ;
  	my $lines_ref = [ read_file( $bin_file ) ] ;
  
  =head3 scalar_ref
  
  If this boolean option is set, the return value (only in scalar
  context) will be an scalar reference to a string which is the contents
  of the slurped file. This will usually be faster than returning the
  plain scalar.
  
  	my $text_ref = read_file( $bin_file, scalar_ref => 1 ) ;
  
  =head3 buf_ref
  
  You can use this option to pass in a scalar reference and the slurped
  file contents will be stored in the scalar. This can be used in
  conjunction with any of the other options.
  
  	my $text_ref = read_file( $bin_file, buf_ref => \$buffer,
  					     array_ref => 1 ) ;
  	my @lines = read_file( $bin_file, buf_ref => \$buffer ) ;
  
  =head3 blk_size
  
  You can use this option to set the block size used when slurping from an already open handle (like \*STDIN). It defaults to 1MB.
  
  	my $text_ref = read_file( $bin_file, blk_size => 10_000_000,
  					     array_ref => 1 ) ;
  
  =head3 err_mode
  
  You can use this option to control how read_file behaves when an error
  occurs. This option defaults to 'croak'. You can set it to 'carp' or
  to 'quiet to have no error handling. This code wants to carp and then
  read abother file if it fails.
  
  	my $text_ref = read_file( $file, err_mode => 'carp' ) ;
  	unless ( $text_ref ) {
  
  		# read a different file but croak if not found
  		$text_ref = read_file( $another_file ) ;
  	}
  	
  	# process ${$text_ref}
  
  =head2 B<write_file>
  
  This sub writes out an entire file in one call.
  
    write_file( 'filename', @data ) ;
  
  The first argument to C<write_file> is the filename. The next argument
  is an optional hash reference and it contains key/values that can
  modify the behavior of C<write_file>. The rest of the argument list is
  the data to be written to the file.
  
    write_file( 'filename', {append => 1 }, @data ) ;
    write_file( 'filename', {binmode => ':raw' }, $buffer ) ;
  
  As a shortcut if the first data argument is a scalar or array
  reference, it is used as the only data to be written to the file. Any
  following arguments in @_ are ignored. This is a faster way to pass in
  the output to be written to the file and is equivilent to the
  C<buf_ref> option. These following pairs are equivilent but the pass
  by reference call will be faster in most cases (especially with larger
  files).
  
    write_file( 'filename', \$buffer ) ;
    write_file( 'filename', $buffer ) ;
  
    write_file( 'filename', \@lines ) ;
    write_file( 'filename', @lines ) ;
  
  If the first argument is a file handle reference or I/O object (if ref
  is true), then that handle is slurped in. This mode is supported so
  you spew to handles such as \*STDOUT. See the test handle.t for an
  example that does C<open( '-|' )> and child process spews data to the
  parant which slurps it in.  All of the options that control how the
  data is passes into C<write_file> still work in this case.
  
  C<write_file> returns 1 upon successfully writing the file or undef if
  it encountered an error.
  
  The options are:
  
  =head3 binmode
  
  If you set the binmode option, then the file will be written in binary
  mode.
  
  	write_file( $bin_file, {binmode => ':raw'}, @data ) ;
  
  NOTE: this actually sets the O_BINARY mode flag for sysopen. It
  probably should call binmode and pass its argument to support other
  file modes.
  
  =head3 buf_ref
  
  You can use this option to pass in a scalar reference which has the
  data to be written. If this is set then any data arguments (including
  the scalar reference shortcut) in @_ will be ignored. These are
  equivilent:
  
  	write_file( $bin_file, { buf_ref => \$buffer } ) ;
  	write_file( $bin_file, \$buffer ) ;
  	write_file( $bin_file, $buffer ) ;
  
  =head3 atomic
  
  If you set this boolean option, the file will be written to in an
  atomic fashion. A temporary file name is created by appending the pid
  ($$) to the file name argument and that file is spewed to. After the
  file is closed it is renamed to the original file name (and rename is
  an atomic operation on most OS's). If the program using this were to
  crash in the middle of this, then the file with the pid suffix could
  be left behind.
  
  =head3 append
  
  If you set this boolean option, the data will be written at the end of
  the current file.
  
  	write_file( $file, {append => 1}, @data ) ;
  
  C<write_file> croaks if it cannot open the file. It returns true if it
  succeeded in writing out the file and undef if there was an
  error. (Yes, I know if it croaks it can't return anything but that is
  for when I add the options to select the error handling mode).
  
  =head3 no_clobber
  
  If you set this boolean option, an existing file will not be overwritten.
  
  	write_file( $file, {no_clobber => 1}, @data ) ;
  
  =head3 err_mode
  
  You can use this option to control how C<write_file> behaves when an
  error occurs. This option defaults to 'croak'. You can set it to
  'carp' or to 'quiet' to have no error handling other than the return
  value. If the first call to C<write_file> fails it will carp and then
  write to another file. If the second call to C<write_file> fails, it
  will croak.
  
  	unless ( write_file( $file, { err_mode => 'carp', \$data ) ;
  
  		# write a different file but croak if not found
  		write_file( $other_file, \$data ) ;
  	}
  
  =head2 overwrite_file
  
  This sub is just a typeglob alias to write_file since write_file
  always overwrites an existing file. This sub is supported for
  backwards compatibility with the original version of this module. See
  write_file for its API and behavior.
  
  =head2 append_file
  
  This sub will write its data to the end of the file. It is a wrapper
  around write_file and it has the same API so see that for the full
  documentation. These calls are equivilent:
  
  	append_file( $file, @data ) ;
  	write_file( $file, {append => 1}, @data ) ;
  
  =head2 read_dir
  
  This sub reads all the file names from directory and returns them to
  the caller but C<.> and C<..> are removed by default.
  
  	my @files = read_dir( '/path/to/dir' ) ;
  
  It croaks if it cannot open the directory.
  
  In a list context C<read_dir> returns a list of the entries in the
  directory. In a scalar context it returns an array reference which has
  the entries.
  
  =head3 keep_dot_dot
  
  If this boolean option is set, C<.> and C<..> are not removed from the
  list of files.
  
  	my @all_files = read_dir( '/path/to/dir', keep_dot_dot => 1 ) ;
  
  =head2 EXPORT
  
    read_file write_file overwrite_file append_file read_dir
  
  =head2 SEE ALSO
  
  An article on file slurping in extras/slurp_article.pod. There is
  also a benchmarking script in extras/slurp_bench.pl.
  
  =head2 BUGS
  
  If run under Perl 5.004, slurping from the DATA handle will fail as
  that requires B.pm which didn't get into core until 5.005.
  
  =head1 AUTHOR
  
  Uri Guttman, E<lt>uri@stemsystems.comE<gt>
  
  =cut
FILE_SLURP

$fatpacked{"File/Temp.pm"} = <<'FILE_TEMP';
  package File::Temp;
  
  =head1 NAME
  
  File::Temp - return name and handle of a temporary file safely
  
  =begin __INTERNALS
  
  =head1 PORTABILITY
  
  This section is at the top in order to provide easier access to
  porters.  It is not expected to be rendered by a standard pod
  formatting tool. Please skip straight to the SYNOPSIS section if you
  are not trying to port this module to a new platform.
  
  This module is designed to be portable across operating systems and it
  currently supports Unix, VMS, DOS, OS/2, Windows and Mac OS
  (Classic). When porting to a new OS there are generally three main
  issues that have to be solved:
  
  =over 4
  
  =item *
  
  Can the OS unlink an open file? If it can not then the
  C<_can_unlink_opened_file> method should be modified.
  
  =item *
  
  Are the return values from C<stat> reliable? By default all the
  return values from C<stat> are compared when unlinking a temporary
  file using the filename and the handle. Operating systems other than
  unix do not always have valid entries in all fields. If C<unlink0> fails
  then the C<stat> comparison should be modified accordingly.
  
  =item *
  
  Security. Systems that can not support a test for the sticky bit
  on a directory can not use the MEDIUM and HIGH security tests.
  The C<_can_do_level> method should be modified accordingly.
  
  =back
  
  =end __INTERNALS
  
  =head1 SYNOPSIS
  
    use File::Temp qw/ tempfile tempdir /;
  
    $fh = tempfile();
    ($fh, $filename) = tempfile();
  
    ($fh, $filename) = tempfile( $template, DIR => $dir);
    ($fh, $filename) = tempfile( $template, SUFFIX => '.dat');
    ($fh, $filename) = tempfile( $template, TMPDIR => 1 );
  
    binmode( $fh, ":utf8" );
  
    $dir = tempdir( CLEANUP => 1 );
    ($fh, $filename) = tempfile( DIR => $dir );
  
  Object interface:
  
    require File::Temp;
    use File::Temp ();
    use File::Temp qw/ :seekable /;
  
    $fh = File::Temp->new();
    $fname = $fh->filename;
  
    $fh = File::Temp->new(TEMPLATE => $template);
    $fname = $fh->filename;
  
    $tmp = File::Temp->new( UNLINK => 0, SUFFIX => '.dat' );
    print $tmp "Some data\n";
    print "Filename is $tmp\n";
    $tmp->seek( 0, SEEK_END );
  
  The following interfaces are provided for compatibility with
  existing APIs. They should not be used in new code.
  
  MkTemp family:
  
    use File::Temp qw/ :mktemp  /;
  
    ($fh, $file) = mkstemp( "tmpfileXXXXX" );
    ($fh, $file) = mkstemps( "tmpfileXXXXXX", $suffix);
  
    $tmpdir = mkdtemp( $template );
  
    $unopened_file = mktemp( $template );
  
  POSIX functions:
  
    use File::Temp qw/ :POSIX /;
  
    $file = tmpnam();
    $fh = tmpfile();
  
    ($fh, $file) = tmpnam();
  
  Compatibility functions:
  
    $unopened_file = File::Temp::tempnam( $dir, $pfx );
  
  =head1 DESCRIPTION
  
  C<File::Temp> can be used to create and open temporary files in a safe
  way.  There is both a function interface and an object-oriented
  interface.  The File::Temp constructor or the tempfile() function can
  be used to return the name and the open filehandle of a temporary
  file.  The tempdir() function can be used to create a temporary
  directory.
  
  The security aspect of temporary file creation is emphasized such that
  a filehandle and filename are returned together.  This helps guarantee
  that a race condition can not occur where the temporary file is
  created by another process between checking for the existence of the
  file and its opening.  Additional security levels are provided to
  check, for example, that the sticky bit is set on world writable
  directories.  See L<"safe_level"> for more information.
  
  For compatibility with popular C library functions, Perl implementations of
  the mkstemp() family of functions are provided. These are, mkstemp(),
  mkstemps(), mkdtemp() and mktemp().
  
  Additionally, implementations of the standard L<POSIX|POSIX>
  tmpnam() and tmpfile() functions are provided if required.
  
  Implementations of mktemp(), tmpnam(), and tempnam() are provided,
  but should be used with caution since they return only a filename
  that was valid when function was called, so cannot guarantee
  that the file will not exist by the time the caller opens the filename.
  
  Filehandles returned by these functions support the seekable methods.
  
  =cut
  
  # 5.6.0 gives us S_IWOTH, S_IWGRP, our and auto-vivifying filehandls
  # People would like a version on 5.004 so give them what they want :-)
  use 5.004;
  use strict;
  use Carp;
  use File::Spec 0.8;
  use File::Path qw/ rmtree /;
  use Fcntl 1.03;
  use IO::Seekable;               # For SEEK_*
  use Errno;
  require VMS::Stdio if $^O eq 'VMS';
  
  # pre-emptively load Carp::Heavy. If we don't when we run out of file
  # handles and attempt to call croak() we get an error message telling
  # us that Carp::Heavy won't load rather than an error telling us we
  # have run out of file handles. We either preload croak() or we
  # switch the calls to croak from _gettemp() to use die.
  eval { require Carp::Heavy; };
  
  # Need the Symbol package if we are running older perl
  require Symbol if $] < 5.006;
  
  ### For the OO interface
  use base qw/ IO::Handle IO::Seekable /;
  use overload '""' => "STRINGIFY", fallback => 1;
  
  # use 'our' on v5.6.0
  use vars qw($VERSION @EXPORT_OK %EXPORT_TAGS $DEBUG $KEEP_ALL);
  
  $DEBUG = 0;
  $KEEP_ALL = 0;
  
  # We are exporting functions
  
  use base qw/Exporter/;
  
  # Export list - to allow fine tuning of export table
  
  @EXPORT_OK = qw{
                   tempfile
                   tempdir
                   tmpnam
                   tmpfile
                   mktemp
                   mkstemp
                   mkstemps
                   mkdtemp
                   unlink0
                   cleanup
                   SEEK_SET
                   SEEK_CUR
                   SEEK_END
               };
  
  # Groups of functions for export
  
  %EXPORT_TAGS = (
                  'POSIX' => [qw/ tmpnam tmpfile /],
                  'mktemp' => [qw/ mktemp mkstemp mkstemps mkdtemp/],
                  'seekable' => [qw/ SEEK_SET SEEK_CUR SEEK_END /],
                 );
  
  # add contents of these tags to @EXPORT
  Exporter::export_tags('POSIX','mktemp','seekable');
  
  # Version number
  
  $VERSION = '0.22';
  
  # This is a list of characters that can be used in random filenames
  
  my @CHARS = (qw/ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
                   a b c d e f g h i j k l m n o p q r s t u v w x y z
                   0 1 2 3 4 5 6 7 8 9 _
                 /);
  
  # Maximum number of tries to make a temp file before failing
  
  use constant MAX_TRIES => 1000;
  
  # Minimum number of X characters that should be in a template
  use constant MINX => 4;
  
  # Default template when no template supplied
  
  use constant TEMPXXX => 'X' x 10;
  
  # Constants for the security level
  
  use constant STANDARD => 0;
  use constant MEDIUM   => 1;
  use constant HIGH     => 2;
  
  # OPENFLAGS. If we defined the flag to use with Sysopen here this gives
  # us an optimisation when many temporary files are requested
  
  my $OPENFLAGS = O_CREAT | O_EXCL | O_RDWR;
  my $LOCKFLAG;
  
  unless ($^O eq 'MacOS') {
    for my $oflag (qw/ NOFOLLOW BINARY LARGEFILE NOINHERIT /) {
      my ($bit, $func) = (0, "Fcntl::O_" . $oflag);
      no strict 'refs';
      $OPENFLAGS |= $bit if eval {
        # Make sure that redefined die handlers do not cause problems
        # e.g. CGI::Carp
        local $SIG{__DIE__} = sub {};
        local $SIG{__WARN__} = sub {};
        $bit = &$func();
        1;
      };
    }
    # Special case O_EXLOCK
    $LOCKFLAG = eval {
      local $SIG{__DIE__} = sub {};
      local $SIG{__WARN__} = sub {};
      &Fcntl::O_EXLOCK();
    };
  }
  
  # On some systems the O_TEMPORARY flag can be used to tell the OS
  # to automatically remove the file when it is closed. This is fine
  # in most cases but not if tempfile is called with UNLINK=>0 and
  # the filename is requested -- in the case where the filename is to
  # be passed to another routine. This happens on windows. We overcome
  # this by using a second open flags variable
  
  my $OPENTEMPFLAGS = $OPENFLAGS;
  unless ($^O eq 'MacOS') {
    for my $oflag (qw/ TEMPORARY /) {
      my ($bit, $func) = (0, "Fcntl::O_" . $oflag);
      local($@);
      no strict 'refs';
      $OPENTEMPFLAGS |= $bit if eval {
        # Make sure that redefined die handlers do not cause problems
        # e.g. CGI::Carp
        local $SIG{__DIE__} = sub {};
        local $SIG{__WARN__} = sub {};
        $bit = &$func();
        1;
      };
    }
  }
  
  # Private hash tracking which files have been created by each process id via the OO interface
  my %FILES_CREATED_BY_OBJECT;
  
  # INTERNAL ROUTINES - not to be used outside of package
  
  # Generic routine for getting a temporary filename
  # modelled on OpenBSD _gettemp() in mktemp.c
  
  # The template must contain X's that are to be replaced
  # with the random values
  
  #  Arguments:
  
  #  TEMPLATE   - string containing the XXXXX's that is converted
  #           to a random filename and opened if required
  
  # Optionally, a hash can also be supplied containing specific options
  #   "open" => if true open the temp file, else just return the name
  #             default is 0
  #   "mkdir"=> if true, we are creating a temp directory rather than tempfile
  #             default is 0
  #   "suffixlen" => number of characters at end of PATH to be ignored.
  #                  default is 0.
  #   "unlink_on_close" => indicates that, if possible,  the OS should remove
  #                        the file as soon as it is closed. Usually indicates
  #                        use of the O_TEMPORARY flag to sysopen.
  #                        Usually irrelevant on unix
  #   "use_exlock" => Indicates that O_EXLOCK should be used. Default is true.
  
  # Optionally a reference to a scalar can be passed into the function
  # On error this will be used to store the reason for the error
  #   "ErrStr"  => \$errstr
  
  # "open" and "mkdir" can not both be true
  # "unlink_on_close" is not used when "mkdir" is true.
  
  # The default options are equivalent to mktemp().
  
  # Returns:
  #   filehandle - open file handle (if called with doopen=1, else undef)
  #   temp name  - name of the temp file or directory
  
  # For example:
  #   ($fh, $name) = _gettemp($template, "open" => 1);
  
  # for the current version, failures are associated with
  # stored in an error string and returned to give the reason whilst debugging
  # This routine is not called by any external function
  sub _gettemp {
  
    croak 'Usage: ($fh, $name) = _gettemp($template, OPTIONS);'
      unless scalar(@_) >= 1;
  
    # the internal error string - expect it to be overridden
    # Need this in case the caller decides not to supply us a value
    # need an anonymous scalar
    my $tempErrStr;
  
    # Default options
    my %options = (
                   "open" => 0,
                   "mkdir" => 0,
                   "suffixlen" => 0,
                   "unlink_on_close" => 0,
                   "use_exlock" => 1,
                   "ErrStr" => \$tempErrStr,
                  );
  
    # Read the template
    my $template = shift;
    if (ref($template)) {
      # Use a warning here since we have not yet merged ErrStr
      carp "File::Temp::_gettemp: template must not be a reference";
      return ();
    }
  
    # Check that the number of entries on stack are even
    if (scalar(@_) % 2 != 0) {
      # Use a warning here since we have not yet merged ErrStr
      carp "File::Temp::_gettemp: Must have even number of options";
      return ();
    }
  
    # Read the options and merge with defaults
    %options = (%options, @_)  if @_;
  
    # Make sure the error string is set to undef
    ${$options{ErrStr}} = undef;
  
    # Can not open the file and make a directory in a single call
    if ($options{"open"} && $options{"mkdir"}) {
      ${$options{ErrStr}} = "doopen and domkdir can not both be true\n";
      return ();
    }
  
    # Find the start of the end of the  Xs (position of last X)
    # Substr starts from 0
    my $start = length($template) - 1 - $options{"suffixlen"};
  
    # Check that we have at least MINX x X (e.g. 'XXXX") at the end of the string
    # (taking suffixlen into account). Any fewer is insecure.
  
    # Do it using substr - no reason to use a pattern match since
    # we know where we are looking and what we are looking for
  
    if (substr($template, $start - MINX + 1, MINX) ne 'X' x MINX) {
      ${$options{ErrStr}} = "The template must end with at least ".
        MINX . " 'X' characters\n";
      return ();
    }
  
    # Replace all the X at the end of the substring with a
    # random character or just all the XX at the end of a full string.
    # Do it as an if, since the suffix adjusts which section to replace
    # and suffixlen=0 returns nothing if used in the substr directly
    # and generate a full path from the template
  
    my $path = _replace_XX($template, $options{"suffixlen"});
  
  
    # Split the path into constituent parts - eventually we need to check
    # whether the directory exists
    # We need to know whether we are making a temp directory
    # or a tempfile
  
    my ($volume, $directories, $file);
    my $parent;                   # parent directory
    if ($options{"mkdir"}) {
      # There is no filename at the end
      ($volume, $directories, $file) = File::Spec->splitpath( $path, 1);
  
      # The parent is then $directories without the last directory
      # Split the directory and put it back together again
      my @dirs = File::Spec->splitdir($directories);
  
      # If @dirs only has one entry (i.e. the directory template) that means
      # we are in the current directory
      if ($#dirs == 0) {
        $parent = File::Spec->curdir;
      } else {
  
        if ($^O eq 'VMS') {     # need volume to avoid relative dir spec
          $parent = File::Spec->catdir($volume, @dirs[0..$#dirs-1]);
          $parent = 'sys$disk:[]' if $parent eq '';
        } else {
  
          # Put it back together without the last one
          $parent = File::Spec->catdir(@dirs[0..$#dirs-1]);
  
          # ...and attach the volume (no filename)
          $parent = File::Spec->catpath($volume, $parent, '');
        }
  
      }
  
    } else {
  
      # Get rid of the last filename (use File::Basename for this?)
      ($volume, $directories, $file) = File::Spec->splitpath( $path );
  
      # Join up without the file part
      $parent = File::Spec->catpath($volume,$directories,'');
  
      # If $parent is empty replace with curdir
      $parent = File::Spec->curdir
        unless $directories ne '';
  
    }
  
    # Check that the parent directories exist
    # Do this even for the case where we are simply returning a name
    # not a file -- no point returning a name that includes a directory
    # that does not exist or is not writable
  
    unless (-e $parent) {
      ${$options{ErrStr}} = "Parent directory ($parent) does not exist";
      return ();
    }
    unless (-d $parent) {
      ${$options{ErrStr}} = "Parent directory ($parent) is not a directory";
      return ();
    }
  
    # Check the stickiness of the directory and chown giveaway if required
    # If the directory is world writable the sticky bit
    # must be set
  
    if (File::Temp->safe_level == MEDIUM) {
      my $safeerr;
      unless (_is_safe($parent,\$safeerr)) {
        ${$options{ErrStr}} = "Parent directory ($parent) is not safe ($safeerr)";
        return ();
      }
    } elsif (File::Temp->safe_level == HIGH) {
      my $safeerr;
      unless (_is_verysafe($parent, \$safeerr)) {
        ${$options{ErrStr}} = "Parent directory ($parent) is not safe ($safeerr)";
        return ();
      }
    }
  
  
    # Now try MAX_TRIES time to open the file
    for (my $i = 0; $i < MAX_TRIES; $i++) {
  
      # Try to open the file if requested
      if ($options{"open"}) {
        my $fh;
  
        # If we are running before perl5.6.0 we can not auto-vivify
        if ($] < 5.006) {
          $fh = &Symbol::gensym;
        }
  
        # Try to make sure this will be marked close-on-exec
        # XXX: Win32 doesn't respect this, nor the proper fcntl,
        #      but may have O_NOINHERIT. This may or may not be in Fcntl.
        local $^F = 2;
  
        # Attempt to open the file
        my $open_success = undef;
        if ( $^O eq 'VMS' and $options{"unlink_on_close"} && !$KEEP_ALL) {
          # make it auto delete on close by setting FAB$V_DLT bit
          $fh = VMS::Stdio::vmssysopen($path, $OPENFLAGS, 0600, 'fop=dlt');
          $open_success = $fh;
        } else {
          my $flags = ( ($options{"unlink_on_close"} && !$KEEP_ALL) ?
                        $OPENTEMPFLAGS :
                        $OPENFLAGS );
          $flags |= $LOCKFLAG if (defined $LOCKFLAG && $options{use_exlock});
          $open_success = sysopen($fh, $path, $flags, 0600);
        }
        if ( $open_success ) {
  
          # in case of odd umask force rw
          chmod(0600, $path);
  
          # Opened successfully - return file handle and name
          return ($fh, $path);
  
        } else {
  
          # Error opening file - abort with error
          # if the reason was anything but EEXIST
          unless ($!{EEXIST}) {
            ${$options{ErrStr}} = "Could not create temp file $path: $!";
            return ();
          }
  
          # Loop round for another try
  
        }
      } elsif ($options{"mkdir"}) {
  
        # Open the temp directory
        if (mkdir( $path, 0700)) {
          # in case of odd umask
          chmod(0700, $path);
  
          return undef, $path;
        } else {
  
          # Abort with error if the reason for failure was anything
          # except EEXIST
          unless ($!{EEXIST}) {
            ${$options{ErrStr}} = "Could not create directory $path: $!";
            return ();
          }
  
          # Loop round for another try
  
        }
  
      } else {
  
        # Return true if the file can not be found
        # Directory has been checked previously
  
        return (undef, $path) unless -e $path;
  
        # Try again until MAX_TRIES
  
      }
  
      # Did not successfully open the tempfile/dir
      # so try again with a different set of random letters
      # No point in trying to increment unless we have only
      # 1 X say and the randomness could come up with the same
      # file MAX_TRIES in a row.
  
      # Store current attempt - in principal this implies that the
      # 3rd time around the open attempt that the first temp file
      # name could be generated again. Probably should store each
      # attempt and make sure that none are repeated
  
      my $original = $path;
      my $counter = 0;            # Stop infinite loop
      my $MAX_GUESS = 50;
  
      do {
  
        # Generate new name from original template
        $path = _replace_XX($template, $options{"suffixlen"});
  
        $counter++;
  
      } until ($path ne $original || $counter > $MAX_GUESS);
  
      # Check for out of control looping
      if ($counter > $MAX_GUESS) {
        ${$options{ErrStr}} = "Tried to get a new temp name different to the previous value $MAX_GUESS times.\nSomething wrong with template?? ($template)";
        return ();
      }
  
    }
  
    # If we get here, we have run out of tries
    ${ $options{ErrStr} } = "Have exceeded the maximum number of attempts ("
      . MAX_TRIES . ") to open temp file/dir";
  
    return ();
  
  }
  
  # Internal routine to replace the XXXX... with random characters
  # This has to be done by _gettemp() every time it fails to
  # open a temp file/dir
  
  # Arguments:  $template (the template with XXX),
  #             $ignore   (number of characters at end to ignore)
  
  # Returns:    modified template
  
  sub _replace_XX {
  
    croak 'Usage: _replace_XX($template, $ignore)'
      unless scalar(@_) == 2;
  
    my ($path, $ignore) = @_;
  
    # Do it as an if, since the suffix adjusts which section to replace
    # and suffixlen=0 returns nothing if used in the substr directly
    # Alternatively, could simply set $ignore to length($path)-1
    # Don't want to always use substr when not required though.
    my $end = ( $] >= 5.006 ? "\\z" : "\\Z" );
  
    if ($ignore) {
      substr($path, 0, - $ignore) =~ s/X(?=X*$end)/$CHARS[ int( rand( @CHARS ) ) ]/ge;
    } else {
      $path =~ s/X(?=X*$end)/$CHARS[ int( rand( @CHARS ) ) ]/ge;
    }
    return $path;
  }
  
  # Internal routine to force a temp file to be writable after
  # it is created so that we can unlink it. Windows seems to occassionally
  # force a file to be readonly when written to certain temp locations
  sub _force_writable {
    my $file = shift;
    chmod 0600, $file;
  }
  
  
  # internal routine to check to see if the directory is safe
  # First checks to see if the directory is not owned by the
  # current user or root. Then checks to see if anyone else
  # can write to the directory and if so, checks to see if
  # it has the sticky bit set
  
  # Will not work on systems that do not support sticky bit
  
  #Args:  directory path to check
  #       Optionally: reference to scalar to contain error message
  # Returns true if the path is safe and false otherwise.
  # Returns undef if can not even run stat() on the path
  
  # This routine based on version written by Tom Christiansen
  
  # Presumably, by the time we actually attempt to create the
  # file or directory in this directory, it may not be safe
  # anymore... Have to run _is_safe directly after the open.
  
  sub _is_safe {
  
    my $path = shift;
    my $err_ref = shift;
  
    # Stat path
    my @info = stat($path);
    unless (scalar(@info)) {
      $$err_ref = "stat(path) returned no values";
      return 0;
    }
    ;
    return 1 if $^O eq 'VMS';     # owner delete control at file level
  
    # Check to see whether owner is neither superuser (or a system uid) nor me
    # Use the effective uid from the $> variable
    # UID is in [4]
    if ($info[4] > File::Temp->top_system_uid() && $info[4] != $>) {
  
      Carp::cluck(sprintf "uid=$info[4] topuid=%s euid=$> path='$path'",
                  File::Temp->top_system_uid());
  
      $$err_ref = "Directory owned neither by root nor the current user"
        if ref($err_ref);
      return 0;
    }
  
    # check whether group or other can write file
    # use 066 to detect either reading or writing
    # use 022 to check writability
    # Do it with S_IWOTH and S_IWGRP for portability (maybe)
    # mode is in info[2]
    if (($info[2] & &Fcntl::S_IWGRP) ||  # Is group writable?
        ($info[2] & &Fcntl::S_IWOTH) ) { # Is world writable?
      # Must be a directory
      unless (-d $path) {
        $$err_ref = "Path ($path) is not a directory"
          if ref($err_ref);
        return 0;
      }
      # Must have sticky bit set
      unless (-k $path) {
        $$err_ref = "Sticky bit not set on $path when dir is group|world writable"
          if ref($err_ref);
        return 0;
      }
    }
  
    return 1;
  }
  
  # Internal routine to check whether a directory is safe
  # for temp files. Safer than _is_safe since it checks for
  # the possibility of chown giveaway and if that is a possibility
  # checks each directory in the path to see if it is safe (with _is_safe)
  
  # If _PC_CHOWN_RESTRICTED is not set, does the full test of each
  # directory anyway.
  
  # Takes optional second arg as scalar ref to error reason
  
  sub _is_verysafe {
  
    # Need POSIX - but only want to bother if really necessary due to overhead
    require POSIX;
  
    my $path = shift;
    print "_is_verysafe testing $path\n" if $DEBUG;
    return 1 if $^O eq 'VMS';     # owner delete control at file level
  
    my $err_ref = shift;
  
    # Should Get the value of _PC_CHOWN_RESTRICTED if it is defined
    # and If it is not there do the extensive test
    local($@);
    my $chown_restricted;
    $chown_restricted = &POSIX::_PC_CHOWN_RESTRICTED()
      if eval { &POSIX::_PC_CHOWN_RESTRICTED(); 1};
  
    # If chown_resticted is set to some value we should test it
    if (defined $chown_restricted) {
  
      # Return if the current directory is safe
      return _is_safe($path,$err_ref) if POSIX::sysconf( $chown_restricted );
  
    }
  
    # To reach this point either, the _PC_CHOWN_RESTRICTED symbol
    # was not avialable or the symbol was there but chown giveaway
    # is allowed. Either way, we now have to test the entire tree for
    # safety.
  
    # Convert path to an absolute directory if required
    unless (File::Spec->file_name_is_absolute($path)) {
      $path = File::Spec->rel2abs($path);
    }
  
    # Split directory into components - assume no file
    my ($volume, $directories, undef) = File::Spec->splitpath( $path, 1);
  
    # Slightly less efficient than having a function in File::Spec
    # to chop off the end of a directory or even a function that
    # can handle ../ in a directory tree
    # Sometimes splitdir() returns a blank at the end
    # so we will probably check the bottom directory twice in some cases
    my @dirs = File::Spec->splitdir($directories);
  
    # Concatenate one less directory each time around
    foreach my $pos (0.. $#dirs) {
      # Get a directory name
      my $dir = File::Spec->catpath($volume,
                                    File::Spec->catdir(@dirs[0.. $#dirs - $pos]),
                                    ''
                                   );
  
      print "TESTING DIR $dir\n" if $DEBUG;
  
      # Check the directory
      return 0 unless _is_safe($dir,$err_ref);
  
    }
  
    return 1;
  }
  
  
  
  # internal routine to determine whether unlink works on this
  # platform for files that are currently open.
  # Returns true if we can, false otherwise.
  
  # Currently WinNT, OS/2 and VMS can not unlink an opened file
  # On VMS this is because the O_EXCL flag is used to open the
  # temporary file. Currently I do not know enough about the issues
  # on VMS to decide whether O_EXCL is a requirement.
  
  sub _can_unlink_opened_file {
  
    if ($^O eq 'MSWin32' || $^O eq 'os2' || $^O eq 'VMS' || $^O eq 'dos' || $^O eq 'MacOS') {
      return 0;
    } else {
      return 1;
    }
  
  }
  
  # internal routine to decide which security levels are allowed
  # see safe_level() for more information on this
  
  # Controls whether the supplied security level is allowed
  
  #   $cando = _can_do_level( $level )
  
  sub _can_do_level {
  
    # Get security level
    my $level = shift;
  
    # Always have to be able to do STANDARD
    return 1 if $level == STANDARD;
  
    # Currently, the systems that can do HIGH or MEDIUM are identical
    if ( $^O eq 'MSWin32' || $^O eq 'os2' || $^O eq 'cygwin' || $^O eq 'dos' || $^O eq 'MacOS' || $^O eq 'mpeix') {
      return 0;
    } else {
      return 1;
    }
  
  }
  
  # This routine sets up a deferred unlinking of a specified
  # filename and filehandle. It is used in the following cases:
  #  - Called by unlink0 if an opened file can not be unlinked
  #  - Called by tempfile() if files are to be removed on shutdown
  #  - Called by tempdir() if directories are to be removed on shutdown
  
  # Arguments:
  #   _deferred_unlink( $fh, $fname, $isdir );
  #
  #   - filehandle (so that it can be expclicitly closed if open
  #   - filename   (the thing we want to remove)
  #   - isdir      (flag to indicate that we are being given a directory)
  #                 [and hence no filehandle]
  
  # Status is not referred to since all the magic is done with an END block
  
  {
    # Will set up two lexical variables to contain all the files to be
    # removed. One array for files, another for directories They will
    # only exist in this block.
  
    #  This means we only have to set up a single END block to remove
    #  all files. 
  
    # in order to prevent child processes inadvertently deleting the parent
    # temp files we use a hash to store the temp files and directories
    # created by a particular process id.
  
    # %files_to_unlink contains values that are references to an array of
    # array references containing the filehandle and filename associated with
    # the temp file.
    my (%files_to_unlink, %dirs_to_unlink);
  
    # Set up an end block to use these arrays
    END {
      local($., $@, $!, $^E, $?);
      cleanup();
    }
  
    # Cleanup function. Always triggered on END but can be invoked
    # manually.
    sub cleanup {
      if (!$KEEP_ALL) {
        # Files
        my @files = (exists $files_to_unlink{$$} ?
                     @{ $files_to_unlink{$$} } : () );
        foreach my $file (@files) {
          # close the filehandle without checking its state
          # in order to make real sure that this is closed
          # if its already closed then I dont care about the answer
          # probably a better way to do this
          close($file->[0]);      # file handle is [0]
  
          if (-f $file->[1]) {       # file name is [1]
            _force_writable( $file->[1] ); # for windows
            unlink $file->[1] or warn "Error removing ".$file->[1];
          }
        }
        # Dirs
        my @dirs = (exists $dirs_to_unlink{$$} ?
                    @{ $dirs_to_unlink{$$} } : () );
        foreach my $dir (@dirs) {
          if (-d $dir) {
            # Some versions of rmtree will abort if you attempt to remove
            # the directory you are sitting in. We protect that and turn it
            # into a warning. We do this because this occurs during
            # cleanup and so can not be caught by the user.
            eval { rmtree($dir, $DEBUG, 0); };
            warn $@ if ($@ && $^W);
          }
        }
  
        # clear the arrays
        @{ $files_to_unlink{$$} } = ()
          if exists $files_to_unlink{$$};
        @{ $dirs_to_unlink{$$} } = ()
          if exists $dirs_to_unlink{$$};
      }
    }
  
  
    # This is the sub called to register a file for deferred unlinking
    # This could simply store the input parameters and defer everything
    # until the END block. For now we do a bit of checking at this
    # point in order to make sure that (1) we have a file/dir to delete
    # and (2) we have been called with the correct arguments.
    sub _deferred_unlink {
  
      croak 'Usage:  _deferred_unlink($fh, $fname, $isdir)'
        unless scalar(@_) == 3;
  
      my ($fh, $fname, $isdir) = @_;
  
      warn "Setting up deferred removal of $fname\n"
        if $DEBUG;
  
      # If we have a directory, check that it is a directory
      if ($isdir) {
  
        if (-d $fname) {
  
          # Directory exists so store it
          # first on VMS turn []foo into [.foo] for rmtree
          $fname = VMS::Filespec::vmspath($fname) if $^O eq 'VMS';
          $dirs_to_unlink{$$} = [] 
            unless exists $dirs_to_unlink{$$};
          push (@{ $dirs_to_unlink{$$} }, $fname);
  
        } else {
          carp "Request to remove directory $fname could not be completed since it does not exist!\n" if $^W;
        }
  
      } else {
  
        if (-f $fname) {
  
          # file exists so store handle and name for later removal
          $files_to_unlink{$$} = []
            unless exists $files_to_unlink{$$};
          push(@{ $files_to_unlink{$$} }, [$fh, $fname]);
  
        } else {
          carp "Request to remove file $fname could not be completed since it is not there!\n" if $^W;
        }
  
      }
  
    }
  
  
  }
  
  =head1 OBJECT-ORIENTED INTERFACE
  
  This is the primary interface for interacting with
  C<File::Temp>. Using the OO interface a temporary file can be created
  when the object is constructed and the file can be removed when the
  object is no longer required.
  
  Note that there is no method to obtain the filehandle from the
  C<File::Temp> object. The object itself acts as a filehandle. Also,
  the object is configured such that it stringifies to the name of the
  temporary file, and can be compared to a filename directly. The object
  isa C<IO::Handle> and isa C<IO::Seekable> so all those methods are
  available.
  
  =over 4
  
  =item B<new>
  
  Create a temporary file object.
  
    my $tmp = File::Temp->new();
  
  by default the object is constructed as if C<tempfile>
  was called without options, but with the additional behaviour
  that the temporary file is removed by the object destructor
  if UNLINK is set to true (the default).
  
  Supported arguments are the same as for C<tempfile>: UNLINK
  (defaulting to true), DIR, EXLOCK and SUFFIX. Additionally, the filename
  template is specified using the TEMPLATE option. The OPEN option
  is not supported (the file is always opened).
  
   $tmp = File::Temp->new( TEMPLATE => 'tempXXXXX',
                          DIR => 'mydir',
                          SUFFIX => '.dat');
  
  Arguments are case insensitive.
  
  Can call croak() if an error occurs.
  
  =cut
  
  sub new {
    my $proto = shift;
    my $class = ref($proto) || $proto;
  
    # read arguments and convert keys to upper case
    my %args = @_;
    %args = map { uc($_), $args{$_} } keys %args;
  
    # see if they are unlinking (defaulting to yes)
    my $unlink = (exists $args{UNLINK} ? $args{UNLINK} : 1 );
    delete $args{UNLINK};
  
    # template (store it in an array so that it will
    # disappear from the arg list of tempfile)
    my @template = ( exists $args{TEMPLATE} ? $args{TEMPLATE} : () );
    delete $args{TEMPLATE};
  
    # Protect OPEN
    delete $args{OPEN};
  
    # Open the file and retain file handle and file name
    my ($fh, $path) = tempfile( @template, %args );
  
    print "Tmp: $fh - $path\n" if $DEBUG;
  
    # Store the filename in the scalar slot
    ${*$fh} = $path;
  
    # Cache the filename by pid so that the destructor can decide whether to remove it
    $FILES_CREATED_BY_OBJECT{$$}{$path} = 1;
  
    # Store unlink information in hash slot (plus other constructor info)
    %{*$fh} = %args;
  
    # create the object
    bless $fh, $class;
  
    # final method-based configuration
    $fh->unlink_on_destroy( $unlink );
  
    return $fh;
  }
  
  =item B<newdir>
  
  Create a temporary directory using an object oriented interface.
  
    $dir = File::Temp->newdir();
  
  By default the directory is deleted when the object goes out of scope.
  
  Supports the same options as the C<tempdir> function. Note that directories
  created with this method default to CLEANUP => 1.
  
    $dir = File::Temp->newdir( $template, %options );
  
  =cut
  
  sub newdir {
    my $self = shift;
  
    # need to handle args as in tempdir because we have to force CLEANUP
    # default without passing CLEANUP to tempdir
    my $template = (scalar(@_) % 2 == 1 ? shift(@_) : undef );
    my %options = @_;
    my $cleanup = (exists $options{CLEANUP} ? $options{CLEANUP} : 1 );
  
    delete $options{CLEANUP};
  
    my $tempdir;
    if (defined $template) {
      $tempdir = tempdir( $template, %options );
    } else {
      $tempdir = tempdir( %options );
    }
    return bless { DIRNAME => $tempdir,
                   CLEANUP => $cleanup,
                   LAUNCHPID => $$,
                 }, "File::Temp::Dir";
  }
  
  =item B<filename>
  
  Return the name of the temporary file associated with this object
  (if the object was created using the "new" constructor).
  
    $filename = $tmp->filename;
  
  This method is called automatically when the object is used as
  a string.
  
  =cut
  
  sub filename {
    my $self = shift;
    return ${*$self};
  }
  
  sub STRINGIFY {
    my $self = shift;
    return $self->filename;
  }
  
  =item B<dirname>
  
  Return the name of the temporary directory associated with this
  object (if the object was created using the "newdir" constructor).
  
    $dirname = $tmpdir->dirname;
  
  This method is called automatically when the object is used in string context.
  
  =item B<unlink_on_destroy>
  
  Control whether the file is unlinked when the object goes out of scope.
  The file is removed if this value is true and $KEEP_ALL is not.
  
   $fh->unlink_on_destroy( 1 );
  
  Default is for the file to be removed.
  
  =cut
  
  sub unlink_on_destroy {
    my $self = shift;
    if (@_) {
      ${*$self}{UNLINK} = shift;
    }
    return ${*$self}{UNLINK};
  }
  
  =item B<DESTROY>
  
  When the object goes out of scope, the destructor is called. This
  destructor will attempt to unlink the file (using C<unlink1>)
  if the constructor was called with UNLINK set to 1 (the default state
  if UNLINK is not specified).
  
  No error is given if the unlink fails.
  
  If the object has been passed to a child process during a fork, the
  file will be deleted when the object goes out of scope in the parent.
  
  For a temporary directory object the directory will be removed
  unless the CLEANUP argument was used in the constructor (and set to
  false) or C<unlink_on_destroy> was modified after creation.
  
  If the global variable $KEEP_ALL is true, the file or directory
  will not be removed.
  
  =cut
  
  sub DESTROY {
    local($., $@, $!, $^E, $?);
    my $self = shift;
  
    # Make sure we always remove the file from the global hash
    # on destruction. This prevents the hash from growing uncontrollably
    # and post-destruction there is no reason to know about the file.
    my $file = $self->filename;
    my $was_created_by_proc;
    if (exists $FILES_CREATED_BY_OBJECT{$$}{$file}) {
      $was_created_by_proc = 1;
      delete $FILES_CREATED_BY_OBJECT{$$}{$file};
    }
  
    if (${*$self}{UNLINK} && !$KEEP_ALL) {
      print "# --------->   Unlinking $self\n" if $DEBUG;
  
      # only delete if this process created it
      return unless $was_created_by_proc;
  
      # The unlink1 may fail if the file has been closed
      # by the caller. This leaves us with the decision
      # of whether to refuse to remove the file or simply
      # do an unlink without test. Seems to be silly
      # to do this when we are trying to be careful
      # about security
      _force_writable( $file ); # for windows
      unlink1( $self, $file )
        or unlink($file);
    }
  }
  
  =back
  
  =head1 FUNCTIONS
  
  This section describes the recommended interface for generating
  temporary files and directories.
  
  =over 4
  
  =item B<tempfile>
  
  This is the basic function to generate temporary files.
  The behaviour of the file can be changed using various options:
  
    $fh = tempfile();
    ($fh, $filename) = tempfile();
  
  Create a temporary file in  the directory specified for temporary
  files, as specified by the tmpdir() function in L<File::Spec>.
  
    ($fh, $filename) = tempfile($template);
  
  Create a temporary file in the current directory using the supplied
  template.  Trailing `X' characters are replaced with random letters to
  generate the filename.  At least four `X' characters must be present
  at the end of the template.
  
    ($fh, $filename) = tempfile($template, SUFFIX => $suffix)
  
  Same as previously, except that a suffix is added to the template
  after the `X' translation.  Useful for ensuring that a temporary
  filename has a particular extension when needed by other applications.
  But see the WARNING at the end.
  
    ($fh, $filename) = tempfile($template, DIR => $dir);
  
  Translates the template as before except that a directory name
  is specified.
  
    ($fh, $filename) = tempfile($template, TMPDIR => 1);
  
  Equivalent to specifying a DIR of "File::Spec->tmpdir", writing the file
  into the same temporary directory as would be used if no template was
  specified at all.
  
    ($fh, $filename) = tempfile($template, UNLINK => 1);
  
  Return the filename and filehandle as before except that the file is
  automatically removed when the program exits (dependent on
  $KEEP_ALL). Default is for the file to be removed if a file handle is
  requested and to be kept if the filename is requested. In a scalar
  context (where no filename is returned) the file is always deleted
  either (depending on the operating system) on exit or when it is
  closed (unless $KEEP_ALL is true when the temp file is created).
  
  Use the object-oriented interface if fine-grained control of when
  a file is removed is required.
  
  If the template is not specified, a template is always
  automatically generated. This temporary file is placed in tmpdir()
  (L<File::Spec>) unless a directory is specified explicitly with the
  DIR option.
  
    $fh = tempfile( DIR => $dir );
  
  If called in scalar context, only the filehandle is returned and the
  file will automatically be deleted when closed on operating systems
  that support this (see the description of tmpfile() elsewhere in this
  document).  This is the preferred mode of operation, as if you only
  have a filehandle, you can never create a race condition by fumbling
  with the filename. On systems that can not unlink an open file or can
  not mark a file as temporary when it is opened (for example, Windows
  NT uses the C<O_TEMPORARY> flag) the file is marked for deletion when
  the program ends (equivalent to setting UNLINK to 1). The C<UNLINK>
  flag is ignored if present.
  
    (undef, $filename) = tempfile($template, OPEN => 0);
  
  This will return the filename based on the template but
  will not open this file.  Cannot be used in conjunction with
  UNLINK set to true. Default is to always open the file
  to protect from possible race conditions. A warning is issued
  if warnings are turned on. Consider using the tmpnam()
  and mktemp() functions described elsewhere in this document
  if opening the file is not required.
  
  If the operating system supports it (for example BSD derived systems), the 
  filehandle will be opened with O_EXLOCK (open with exclusive file lock). 
  This can sometimes cause problems if the intention is to pass the filename 
  to another system that expects to take an exclusive lock itself (such as 
  DBD::SQLite) whilst ensuring that the tempfile is not reused. In this 
  situation the "EXLOCK" option can be passed to tempfile. By default EXLOCK 
  will be true (this retains compatibility with earlier releases).
  
    ($fh, $filename) = tempfile($template, EXLOCK => 0);
  
  Options can be combined as required.
  
  Will croak() if there is an error.
  
  =cut
  
  sub tempfile {
  
    # Can not check for argument count since we can have any
    # number of args
  
    # Default options
    my %options = (
                   "DIR"    => undef, # Directory prefix
                   "SUFFIX" => '',    # Template suffix
                   "UNLINK" => 0,     # Do not unlink file on exit
                   "OPEN"   => 1,     # Open file
                   "TMPDIR" => 0, # Place tempfile in tempdir if template specified
                   "EXLOCK" => 1, # Open file with O_EXLOCK
                  );
  
    # Check to see whether we have an odd or even number of arguments
    my $template = (scalar(@_) % 2 == 1 ? shift(@_) : undef);
  
    # Read the options and merge with defaults
    %options = (%options, @_)  if @_;
  
    # First decision is whether or not to open the file
    if (! $options{"OPEN"}) {
  
      warn "tempfile(): temporary filename requested but not opened.\nPossibly unsafe, consider using tempfile() with OPEN set to true\n"
        if $^W;
  
    }
  
    if ($options{"DIR"} and $^O eq 'VMS') {
  
      # on VMS turn []foo into [.foo] for concatenation
      $options{"DIR"} = VMS::Filespec::vmspath($options{"DIR"});
    }
  
    # Construct the template
  
    # Have a choice of trying to work around the mkstemp/mktemp/tmpnam etc
    # functions or simply constructing a template and using _gettemp()
    # explicitly. Go for the latter
  
    # First generate a template if not defined and prefix the directory
    # If no template must prefix the temp directory
    if (defined $template) {
      # End up with current directory if neither DIR not TMPDIR are set
      if ($options{"DIR"}) {
  
        $template = File::Spec->catfile($options{"DIR"}, $template);
  
      } elsif ($options{TMPDIR}) {
  
        $template = File::Spec->catfile(File::Spec->tmpdir, $template );
  
      }
  
    } else {
  
      if ($options{"DIR"}) {
  
        $template = File::Spec->catfile($options{"DIR"}, TEMPXXX);
  
      } else {
  
        $template = File::Spec->catfile(File::Spec->tmpdir, TEMPXXX);
  
      }
  
    }
  
    # Now add a suffix
    $template .= $options{"SUFFIX"};
  
    # Determine whether we should tell _gettemp to unlink the file
    # On unix this is irrelevant and can be worked out after the file is
    # opened (simply by unlinking the open filehandle). On Windows or VMS
    # we have to indicate temporary-ness when we open the file. In general
    # we only want a true temporary file if we are returning just the
    # filehandle - if the user wants the filename they probably do not
    # want the file to disappear as soon as they close it (which may be
    # important if they want a child process to use the file)
    # For this reason, tie unlink_on_close to the return context regardless
    # of OS.
    my $unlink_on_close = ( wantarray ? 0 : 1);
  
    # Create the file
    my ($fh, $path, $errstr);
    croak "Error in tempfile() using $template: $errstr"
      unless (($fh, $path) = _gettemp($template,
                                      "open" => $options{'OPEN'},
                                      "mkdir"=> 0 ,
                                      "unlink_on_close" => $unlink_on_close,
                                      "suffixlen" => length($options{'SUFFIX'}),
                                      "ErrStr" => \$errstr,
                                      "use_exlock" => $options{EXLOCK},
                                     ) );
  
    # Set up an exit handler that can do whatever is right for the
    # system. This removes files at exit when requested explicitly or when
    # system is asked to unlink_on_close but is unable to do so because
    # of OS limitations.
    # The latter should be achieved by using a tied filehandle.
    # Do not check return status since this is all done with END blocks.
    _deferred_unlink($fh, $path, 0) if $options{"UNLINK"};
  
    # Return
    if (wantarray()) {
  
      if ($options{'OPEN'}) {
        return ($fh, $path);
      } else {
        return (undef, $path);
      }
  
    } else {
  
      # Unlink the file. It is up to unlink0 to decide what to do with
      # this (whether to unlink now or to defer until later)
      unlink0($fh, $path) or croak "Error unlinking file $path using unlink0";
  
      # Return just the filehandle.
      return $fh;
    }
  
  
  }
  
  =item B<tempdir>
  
  This is the recommended interface for creation of temporary
  directories.  By default the directory will not be removed on exit
  (that is, it won't be temporary; this behaviour can not be changed
  because of issues with backwards compatibility). To enable removal
  either use the CLEANUP option which will trigger removal on program
  exit, or consider using the "newdir" method in the object interface which
  will allow the directory to be cleaned up when the object goes out of
  scope.
  
  The behaviour of the function depends on the arguments:
  
    $tempdir = tempdir();
  
  Create a directory in tmpdir() (see L<File::Spec|File::Spec>).
  
    $tempdir = tempdir( $template );
  
  Create a directory from the supplied template. This template is
  similar to that described for tempfile(). `X' characters at the end
  of the template are replaced with random letters to construct the
  directory name. At least four `X' characters must be in the template.
  
    $tempdir = tempdir ( DIR => $dir );
  
  Specifies the directory to use for the temporary directory.
  The temporary directory name is derived from an internal template.
  
    $tempdir = tempdir ( $template, DIR => $dir );
  
  Prepend the supplied directory name to the template. The template
  should not include parent directory specifications itself. Any parent
  directory specifications are removed from the template before
  prepending the supplied directory.
  
    $tempdir = tempdir ( $template, TMPDIR => 1 );
  
  Using the supplied template, create the temporary directory in
  a standard location for temporary files. Equivalent to doing
  
    $tempdir = tempdir ( $template, DIR => File::Spec->tmpdir);
  
  but shorter. Parent directory specifications are stripped from the
  template itself. The C<TMPDIR> option is ignored if C<DIR> is set
  explicitly.  Additionally, C<TMPDIR> is implied if neither a template
  nor a directory are supplied.
  
    $tempdir = tempdir( $template, CLEANUP => 1);
  
  Create a temporary directory using the supplied template, but
  attempt to remove it (and all files inside it) when the program
  exits. Note that an attempt will be made to remove all files from
  the directory even if they were not created by this module (otherwise
  why ask to clean it up?). The directory removal is made with
  the rmtree() function from the L<File::Path|File::Path> module.
  Of course, if the template is not specified, the temporary directory
  will be created in tmpdir() and will also be removed at program exit.
  
  Will croak() if there is an error.
  
  =cut
  
  # '
  
  sub tempdir  {
  
    # Can not check for argument count since we can have any
    # number of args
  
    # Default options
    my %options = (
                   "CLEANUP"    => 0, # Remove directory on exit
                   "DIR"        => '', # Root directory
                   "TMPDIR"     => 0,  # Use tempdir with template
                  );
  
    # Check to see whether we have an odd or even number of arguments
    my $template = (scalar(@_) % 2 == 1 ? shift(@_) : undef );
  
    # Read the options and merge with defaults
    %options = (%options, @_)  if @_;
  
    # Modify or generate the template
  
    # Deal with the DIR and TMPDIR options
    if (defined $template) {
  
      # Need to strip directory path if using DIR or TMPDIR
      if ($options{'TMPDIR'} || $options{'DIR'}) {
  
        # Strip parent directory from the filename
        #
        # There is no filename at the end
        $template = VMS::Filespec::vmspath($template) if $^O eq 'VMS';
        my ($volume, $directories, undef) = File::Spec->splitpath( $template, 1);
  
        # Last directory is then our template
        $template = (File::Spec->splitdir($directories))[-1];
  
        # Prepend the supplied directory or temp dir
        if ($options{"DIR"}) {
  
          $template = File::Spec->catdir($options{"DIR"}, $template);
  
        } elsif ($options{TMPDIR}) {
  
          # Prepend tmpdir
          $template = File::Spec->catdir(File::Spec->tmpdir, $template);
  
        }
  
      }
  
    } else {
  
      if ($options{"DIR"}) {
  
        $template = File::Spec->catdir($options{"DIR"}, TEMPXXX);
  
      } else {
  
        $template = File::Spec->catdir(File::Spec->tmpdir, TEMPXXX);
  
      }
  
    }
  
    # Create the directory
    my $tempdir;
    my $suffixlen = 0;
    if ($^O eq 'VMS') {           # dir names can end in delimiters
      $template =~ m/([\.\]:>]+)$/;
      $suffixlen = length($1);
    }
    if ( ($^O eq 'MacOS') && (substr($template, -1) eq ':') ) {
      # dir name has a trailing ':'
      ++$suffixlen;
    }
  
    my $errstr;
    croak "Error in tempdir() using $template: $errstr"
      unless ((undef, $tempdir) = _gettemp($template,
                                           "open" => 0,
                                           "mkdir"=> 1 ,
                                           "suffixlen" => $suffixlen,
                                           "ErrStr" => \$errstr,
                                          ) );
  
    # Install exit handler; must be dynamic to get lexical
    if ( $options{'CLEANUP'} && -d $tempdir) {
      _deferred_unlink(undef, $tempdir, 1);
    }
  
    # Return the dir name
    return $tempdir;
  
  }
  
  =back
  
  =head1 MKTEMP FUNCTIONS
  
  The following functions are Perl implementations of the
  mktemp() family of temp file generation system calls.
  
  =over 4
  
  =item B<mkstemp>
  
  Given a template, returns a filehandle to the temporary file and the name
  of the file.
  
    ($fh, $name) = mkstemp( $template );
  
  In scalar context, just the filehandle is returned.
  
  The template may be any filename with some number of X's appended
  to it, for example F</tmp/temp.XXXX>. The trailing X's are replaced
  with unique alphanumeric combinations.
  
  Will croak() if there is an error.
  
  =cut
  
  
  
  sub mkstemp {
  
    croak "Usage: mkstemp(template)"
      if scalar(@_) != 1;
  
    my $template = shift;
  
    my ($fh, $path, $errstr);
    croak "Error in mkstemp using $template: $errstr"
      unless (($fh, $path) = _gettemp($template,
                                      "open" => 1,
                                      "mkdir"=> 0 ,
                                      "suffixlen" => 0,
                                      "ErrStr" => \$errstr,
                                     ) );
  
    if (wantarray()) {
      return ($fh, $path);
    } else {
      return $fh;
    }
  
  }
  
  
  =item B<mkstemps>
  
  Similar to mkstemp(), except that an extra argument can be supplied
  with a suffix to be appended to the template.
  
    ($fh, $name) = mkstemps( $template, $suffix );
  
  For example a template of C<testXXXXXX> and suffix of C<.dat>
  would generate a file similar to F<testhGji_w.dat>.
  
  Returns just the filehandle alone when called in scalar context.
  
  Will croak() if there is an error.
  
  =cut
  
  sub mkstemps {
  
    croak "Usage: mkstemps(template, suffix)"
      if scalar(@_) != 2;
  
  
    my $template = shift;
    my $suffix   = shift;
  
    $template .= $suffix;
  
    my ($fh, $path, $errstr);
    croak "Error in mkstemps using $template: $errstr"
      unless (($fh, $path) = _gettemp($template,
                                      "open" => 1,
                                      "mkdir"=> 0 ,
                                      "suffixlen" => length($suffix),
                                      "ErrStr" => \$errstr,
                                     ) );
  
    if (wantarray()) {
      return ($fh, $path);
    } else {
      return $fh;
    }
  
  }
  
  =item B<mkdtemp>
  
  Create a directory from a template. The template must end in
  X's that are replaced by the routine.
  
    $tmpdir_name = mkdtemp($template);
  
  Returns the name of the temporary directory created.
  
  Directory must be removed by the caller.
  
  Will croak() if there is an error.
  
  =cut
  
  #' # for emacs
  
  sub mkdtemp {
  
    croak "Usage: mkdtemp(template)"
      if scalar(@_) != 1;
  
    my $template = shift;
    my $suffixlen = 0;
    if ($^O eq 'VMS') {           # dir names can end in delimiters
      $template =~ m/([\.\]:>]+)$/;
      $suffixlen = length($1);
    }
    if ( ($^O eq 'MacOS') && (substr($template, -1) eq ':') ) {
      # dir name has a trailing ':'
      ++$suffixlen;
    }
    my ($junk, $tmpdir, $errstr);
    croak "Error creating temp directory from template $template\: $errstr"
      unless (($junk, $tmpdir) = _gettemp($template,
                                          "open" => 0,
                                          "mkdir"=> 1 ,
                                          "suffixlen" => $suffixlen,
                                          "ErrStr" => \$errstr,
                                         ) );
  
    return $tmpdir;
  
  }
  
  =item B<mktemp>
  
  Returns a valid temporary filename but does not guarantee
  that the file will not be opened by someone else.
  
    $unopened_file = mktemp($template);
  
  Template is the same as that required by mkstemp().
  
  Will croak() if there is an error.
  
  =cut
  
  sub mktemp {
  
    croak "Usage: mktemp(template)"
      if scalar(@_) != 1;
  
    my $template = shift;
  
    my ($tmpname, $junk, $errstr);
    croak "Error getting name to temp file from template $template: $errstr"
      unless (($junk, $tmpname) = _gettemp($template,
                                           "open" => 0,
                                           "mkdir"=> 0 ,
                                           "suffixlen" => 0,
                                           "ErrStr" => \$errstr,
                                          ) );
  
    return $tmpname;
  }
  
  =back
  
  =head1 POSIX FUNCTIONS
  
  This section describes the re-implementation of the tmpnam()
  and tmpfile() functions described in L<POSIX>
  using the mkstemp() from this module.
  
  Unlike the L<POSIX|POSIX> implementations, the directory used
  for the temporary file is not specified in a system include
  file (C<P_tmpdir>) but simply depends on the choice of tmpdir()
  returned by L<File::Spec|File::Spec>. On some implementations this
  location can be set using the C<TMPDIR> environment variable, which
  may not be secure.
  If this is a problem, simply use mkstemp() and specify a template.
  
  =over 4
  
  =item B<tmpnam>
  
  When called in scalar context, returns the full name (including path)
  of a temporary file (uses mktemp()). The only check is that the file does
  not already exist, but there is no guarantee that that condition will
  continue to apply.
  
    $file = tmpnam();
  
  When called in list context, a filehandle to the open file and
  a filename are returned. This is achieved by calling mkstemp()
  after constructing a suitable template.
  
    ($fh, $file) = tmpnam();
  
  If possible, this form should be used to prevent possible
  race conditions.
  
  See L<File::Spec/tmpdir> for information on the choice of temporary
  directory for a particular operating system.
  
  Will croak() if there is an error.
  
  =cut
  
  sub tmpnam {
  
    # Retrieve the temporary directory name
    my $tmpdir = File::Spec->tmpdir;
  
    croak "Error temporary directory is not writable"
      if $tmpdir eq '';
  
    # Use a ten character template and append to tmpdir
    my $template = File::Spec->catfile($tmpdir, TEMPXXX);
  
    if (wantarray() ) {
      return mkstemp($template);
    } else {
      return mktemp($template);
    }
  
  }
  
  =item B<tmpfile>
  
  Returns the filehandle of a temporary file.
  
    $fh = tmpfile();
  
  The file is removed when the filehandle is closed or when the program
  exits. No access to the filename is provided.
  
  If the temporary file can not be created undef is returned.
  Currently this command will probably not work when the temporary
  directory is on an NFS file system.
  
  Will croak() if there is an error.
  
  =cut
  
  sub tmpfile {
  
    # Simply call tmpnam() in a list context
    my ($fh, $file) = tmpnam();
  
    # Make sure file is removed when filehandle is closed
    # This will fail on NFS
    unlink0($fh, $file)
      or return undef;
  
    return $fh;
  
  }
  
  =back
  
  =head1 ADDITIONAL FUNCTIONS
  
  These functions are provided for backwards compatibility
  with common tempfile generation C library functions.
  
  They are not exported and must be addressed using the full package
  name.
  
  =over 4
  
  =item B<tempnam>
  
  Return the name of a temporary file in the specified directory
  using a prefix. The file is guaranteed not to exist at the time
  the function was called, but such guarantees are good for one
  clock tick only.  Always use the proper form of C<sysopen>
  with C<O_CREAT | O_EXCL> if you must open such a filename.
  
    $filename = File::Temp::tempnam( $dir, $prefix );
  
  Equivalent to running mktemp() with $dir/$prefixXXXXXXXX
  (using unix file convention as an example)
  
  Because this function uses mktemp(), it can suffer from race conditions.
  
  Will croak() if there is an error.
  
  =cut
  
  sub tempnam {
  
    croak 'Usage tempnam($dir, $prefix)' unless scalar(@_) == 2;
  
    my ($dir, $prefix) = @_;
  
    # Add a string to the prefix
    $prefix .= 'XXXXXXXX';
  
    # Concatenate the directory to the file
    my $template = File::Spec->catfile($dir, $prefix);
  
    return mktemp($template);
  
  }
  
  =back
  
  =head1 UTILITY FUNCTIONS
  
  Useful functions for dealing with the filehandle and filename.
  
  =over 4
  
  =item B<unlink0>
  
  Given an open filehandle and the associated filename, make a safe
  unlink. This is achieved by first checking that the filename and
  filehandle initially point to the same file and that the number of
  links to the file is 1 (all fields returned by stat() are compared).
  Then the filename is unlinked and the filehandle checked once again to
  verify that the number of links on that file is now 0.  This is the
  closest you can come to making sure that the filename unlinked was the
  same as the file whose descriptor you hold.
  
    unlink0($fh, $path)
       or die "Error unlinking file $path safely";
  
  Returns false on error but croaks() if there is a security
  anomaly. The filehandle is not closed since on some occasions this is
  not required.
  
  On some platforms, for example Windows NT, it is not possible to
  unlink an open file (the file must be closed first). On those
  platforms, the actual unlinking is deferred until the program ends and
  good status is returned. A check is still performed to make sure that
  the filehandle and filename are pointing to the same thing (but not at
  the time the end block is executed since the deferred removal may not
  have access to the filehandle).
  
  Additionally, on Windows NT not all the fields returned by stat() can
  be compared. For example, the C<dev> and C<rdev> fields seem to be
  different.  Also, it seems that the size of the file returned by stat()
  does not always agree, with C<stat(FH)> being more accurate than
  C<stat(filename)>, presumably because of caching issues even when
  using autoflush (this is usually overcome by waiting a while after
  writing to the tempfile before attempting to C<unlink0> it).
  
  Finally, on NFS file systems the link count of the file handle does
  not always go to zero immediately after unlinking. Currently, this
  command is expected to fail on NFS disks.
  
  This function is disabled if the global variable $KEEP_ALL is true
  and an unlink on open file is supported. If the unlink is to be deferred
  to the END block, the file is still registered for removal.
  
  This function should not be called if you are using the object oriented
  interface since the it will interfere with the object destructor deleting
  the file.
  
  =cut
  
  sub unlink0 {
  
    croak 'Usage: unlink0(filehandle, filename)'
      unless scalar(@_) == 2;
  
    # Read args
    my ($fh, $path) = @_;
  
    cmpstat($fh, $path) or return 0;
  
    # attempt remove the file (does not work on some platforms)
    if (_can_unlink_opened_file()) {
  
      # return early (Without unlink) if we have been instructed to retain files.
      return 1 if $KEEP_ALL;
  
      # XXX: do *not* call this on a directory; possible race
      #      resulting in recursive removal
      croak "unlink0: $path has become a directory!" if -d $path;
      unlink($path) or return 0;
  
      # Stat the filehandle
      my @fh = stat $fh;
  
      print "Link count = $fh[3] \n" if $DEBUG;
  
      # Make sure that the link count is zero
      # - Cygwin provides deferred unlinking, however,
      #   on Win9x the link count remains 1
      # On NFS the link count may still be 1 but we cant know that
      # we are on NFS
      return ( $fh[3] == 0 or $^O eq 'cygwin' ? 1 : 0);
  
    } else {
      _deferred_unlink($fh, $path, 0);
      return 1;
    }
  
  }
  
  =item B<cmpstat>
  
  Compare C<stat> of filehandle with C<stat> of provided filename.  This
  can be used to check that the filename and filehandle initially point
  to the same file and that the number of links to the file is 1 (all
  fields returned by stat() are compared).
  
    cmpstat($fh, $path)
       or die "Error comparing handle with file";
  
  Returns false if the stat information differs or if the link count is
  greater than 1. Calls croak if there is a security anomaly.
  
  On certain platforms, for example Windows, not all the fields returned by stat()
  can be compared. For example, the C<dev> and C<rdev> fields seem to be
  different in Windows.  Also, it seems that the size of the file
  returned by stat() does not always agree, with C<stat(FH)> being more
  accurate than C<stat(filename)>, presumably because of caching issues
  even when using autoflush (this is usually overcome by waiting a while
  after writing to the tempfile before attempting to C<unlink0> it).
  
  Not exported by default.
  
  =cut
  
  sub cmpstat {
  
    croak 'Usage: cmpstat(filehandle, filename)'
      unless scalar(@_) == 2;
  
    # Read args
    my ($fh, $path) = @_;
  
    warn "Comparing stat\n"
      if $DEBUG;
  
    # Stat the filehandle - which may be closed if someone has manually
    # closed the file. Can not turn off warnings without using $^W
    # unless we upgrade to 5.006 minimum requirement
    my @fh;
    {
      local ($^W) = 0;
      @fh = stat $fh;
    }
    return unless @fh;
  
    if ($fh[3] > 1 && $^W) {
      carp "unlink0: fstat found too many links; SB=@fh" if $^W;
    }
  
    # Stat the path
    my @path = stat $path;
  
    unless (@path) {
      carp "unlink0: $path is gone already" if $^W;
      return;
    }
  
    # this is no longer a file, but may be a directory, or worse
    unless (-f $path) {
      confess "panic: $path is no longer a file: SB=@fh";
    }
  
    # Do comparison of each member of the array
    # On WinNT dev and rdev seem to be different
    # depending on whether it is a file or a handle.
    # Cannot simply compare all members of the stat return
    # Select the ones we can use
    my @okstat = (0..$#fh);       # Use all by default
    if ($^O eq 'MSWin32') {
      @okstat = (1,2,3,4,5,7,8,9,10);
    } elsif ($^O eq 'os2') {
      @okstat = (0, 2..$#fh);
    } elsif ($^O eq 'VMS') {      # device and file ID are sufficient
      @okstat = (0, 1);
    } elsif ($^O eq 'dos') {
      @okstat = (0,2..7,11..$#fh);
    } elsif ($^O eq 'mpeix') {
      @okstat = (0..4,8..10);
    }
  
    # Now compare each entry explicitly by number
    for (@okstat) {
      print "Comparing: $_ : $fh[$_] and $path[$_]\n" if $DEBUG;
      # Use eq rather than == since rdev, blksize, and blocks (6, 11,
      # and 12) will be '' on platforms that do not support them.  This
      # is fine since we are only comparing integers.
      unless ($fh[$_] eq $path[$_]) {
        warn "Did not match $_ element of stat\n" if $DEBUG;
        return 0;
      }
    }
  
    return 1;
  }
  
  =item B<unlink1>
  
  Similar to C<unlink0> except after file comparison using cmpstat, the
  filehandle is closed prior to attempting to unlink the file. This
  allows the file to be removed without using an END block, but does
  mean that the post-unlink comparison of the filehandle state provided
  by C<unlink0> is not available.
  
    unlink1($fh, $path)
       or die "Error closing and unlinking file";
  
  Usually called from the object destructor when using the OO interface.
  
  Not exported by default.
  
  This function is disabled if the global variable $KEEP_ALL is true.
  
  Can call croak() if there is a security anomaly during the stat()
  comparison.
  
  =cut
  
  sub unlink1 {
    croak 'Usage: unlink1(filehandle, filename)'
      unless scalar(@_) == 2;
  
    # Read args
    my ($fh, $path) = @_;
  
    cmpstat($fh, $path) or return 0;
  
    # Close the file
    close( $fh ) or return 0;
  
    # Make sure the file is writable (for windows)
    _force_writable( $path );
  
    # return early (without unlink) if we have been instructed to retain files.
    return 1 if $KEEP_ALL;
  
    # remove the file
    return unlink($path);
  }
  
  =item B<cleanup>
  
  Calling this function will cause any temp files or temp directories
  that are registered for removal to be removed. This happens automatically
  when the process exits but can be triggered manually if the caller is sure
  that none of the temp files are required. This method can be registered as
  an Apache callback.
  
  On OSes where temp files are automatically removed when the temp file
  is closed, calling this function will have no effect other than to remove
  temporary directories (which may include temporary files).
  
    File::Temp::cleanup();
  
  Not exported by default.
  
  =back
  
  =head1 PACKAGE VARIABLES
  
  These functions control the global state of the package.
  
  =over 4
  
  =item B<safe_level>
  
  Controls the lengths to which the module will go to check the safety of the
  temporary file or directory before proceeding.
  Options are:
  
  =over 8
  
  =item STANDARD
  
  Do the basic security measures to ensure the directory exists and is
  writable, that temporary files are opened only if they do not already
  exist, and that possible race conditions are avoided.  Finally the
  L<unlink0|"unlink0"> function is used to remove files safely.
  
  =item MEDIUM
  
  In addition to the STANDARD security, the output directory is checked
  to make sure that it is owned either by root or the user running the
  program. If the directory is writable by group or by other, it is then
  checked to make sure that the sticky bit is set.
  
  Will not work on platforms that do not support the C<-k> test
  for sticky bit.
  
  =item HIGH
  
  In addition to the MEDIUM security checks, also check for the
  possibility of ``chown() giveaway'' using the L<POSIX|POSIX>
  sysconf() function. If this is a possibility, each directory in the
  path is checked in turn for safeness, recursively walking back to the
  root directory.
  
  For platforms that do not support the L<POSIX|POSIX>
  C<_PC_CHOWN_RESTRICTED> symbol (for example, Windows NT) it is
  assumed that ``chown() giveaway'' is possible and the recursive test
  is performed.
  
  =back
  
  The level can be changed as follows:
  
    File::Temp->safe_level( File::Temp::HIGH );
  
  The level constants are not exported by the module.
  
  Currently, you must be running at least perl v5.6.0 in order to
  run with MEDIUM or HIGH security. This is simply because the
  safety tests use functions from L<Fcntl|Fcntl> that are not
  available in older versions of perl. The problem is that the version
  number for Fcntl is the same in perl 5.6.0 and in 5.005_03 even though
  they are different versions.
  
  On systems that do not support the HIGH or MEDIUM safety levels
  (for example Win NT or OS/2) any attempt to change the level will
  be ignored. The decision to ignore rather than raise an exception
  allows portable programs to be written with high security in mind
  for the systems that can support this without those programs failing
  on systems where the extra tests are irrelevant.
  
  If you really need to see whether the change has been accepted
  simply examine the return value of C<safe_level>.
  
    $newlevel = File::Temp->safe_level( File::Temp::HIGH );
    die "Could not change to high security"
        if $newlevel != File::Temp::HIGH;
  
  =cut
  
  {
    # protect from using the variable itself
    my $LEVEL = STANDARD;
    sub safe_level {
      my $self = shift;
      if (@_) {
        my $level = shift;
        if (($level != STANDARD) && ($level != MEDIUM) && ($level != HIGH)) {
          carp "safe_level: Specified level ($level) not STANDARD, MEDIUM or HIGH - ignoring\n" if $^W;
        } else {
          # Dont allow this on perl 5.005 or earlier
          if ($] < 5.006 && $level != STANDARD) {
            # Cant do MEDIUM or HIGH checks
            croak "Currently requires perl 5.006 or newer to do the safe checks";
          }
          # Check that we are allowed to change level
          # Silently ignore if we can not.
          $LEVEL = $level if _can_do_level($level);
        }
      }
      return $LEVEL;
    }
  }
  
  =item TopSystemUID
  
  This is the highest UID on the current system that refers to a root
  UID. This is used to make sure that the temporary directory is
  owned by a system UID (C<root>, C<bin>, C<sys> etc) rather than
  simply by root.
  
  This is required since on many unix systems C</tmp> is not owned
  by root.
  
  Default is to assume that any UID less than or equal to 10 is a root
  UID.
  
    File::Temp->top_system_uid(10);
    my $topid = File::Temp->top_system_uid;
  
  This value can be adjusted to reduce security checking if required.
  The value is only relevant when C<safe_level> is set to MEDIUM or higher.
  
  =cut
  
  {
    my $TopSystemUID = 10;
    $TopSystemUID = 197108 if $^O eq 'interix'; # "Administrator"
    sub top_system_uid {
      my $self = shift;
      if (@_) {
        my $newuid = shift;
        croak "top_system_uid: UIDs should be numeric"
          unless $newuid =~ /^\d+$/s;
        $TopSystemUID = $newuid;
      }
      return $TopSystemUID;
    }
  }
  
  =item B<$KEEP_ALL>
  
  Controls whether temporary files and directories should be retained
  regardless of any instructions in the program to remove them
  automatically.  This is useful for debugging but should not be used in
  production code.
  
    $File::Temp::KEEP_ALL = 1;
  
  Default is for files to be removed as requested by the caller.
  
  In some cases, files will only be retained if this variable is true
  when the file is created. This means that you can not create a temporary
  file, set this variable and expect the temp file to still be around
  when the program exits.
  
  =item B<$DEBUG>
  
  Controls whether debugging messages should be enabled.
  
    $File::Temp::DEBUG = 1;
  
  Default is for debugging mode to be disabled.
  
  =back
  
  =head1 WARNING
  
  For maximum security, endeavour always to avoid ever looking at,
  touching, or even imputing the existence of the filename.  You do not
  know that that filename is connected to the same file as the handle
  you have, and attempts to check this can only trigger more race
  conditions.  It's far more secure to use the filehandle alone and
  dispense with the filename altogether.
  
  If you need to pass the handle to something that expects a filename
  then, on a unix system, use C<"/dev/fd/" . fileno($fh)> for arbitrary
  programs, or more generally C<< "+<=&" . fileno($fh) >> for Perl
  programs.  You will have to clear the close-on-exec bit on that file
  descriptor before passing it to another process.
  
      use Fcntl qw/F_SETFD F_GETFD/;
      fcntl($tmpfh, F_SETFD, 0)
          or die "Can't clear close-on-exec flag on temp fh: $!\n";
  
  =head2 Temporary files and NFS
  
  Some problems are associated with using temporary files that reside
  on NFS file systems and it is recommended that a local filesystem
  is used whenever possible. Some of the security tests will most probably
  fail when the temp file is not local. Additionally, be aware that
  the performance of I/O operations over NFS will not be as good as for
  a local disk.
  
  =head2 Forking
  
  In some cases files created by File::Temp are removed from within an
  END block. Since END blocks are triggered when a child process exits
  (unless C<POSIX::_exit()> is used by the child) File::Temp takes care
  to only remove those temp files created by a particular process ID. This
  means that a child will not attempt to remove temp files created by the
  parent process.
  
  If you are forking many processes in parallel that are all creating
  temporary files, you may need to reset the random number seed using
  srand(EXPR) in each child else all the children will attempt to walk
  through the same set of random file names and may well cause
  themselves to give up if they exceed the number of retry attempts.
  
  =head2 Directory removal
  
  Note that if you have chdir'ed into the temporary directory and it is
  subsequently cleaned up (either in the END block or as part of object
  destruction), then you will get a warning from File::Path::rmtree().
  
  =head2 BINMODE
  
  The file returned by File::Temp will have been opened in binary mode
  if such a mode is available. If that is not correct, use the C<binmode()>
  function to change the mode of the filehandle.
  
  Note that you can modify the encoding of a file opened by File::Temp
  also by using C<binmode()>.
  
  =head1 HISTORY
  
  Originally began life in May 1999 as an XS interface to the system
  mkstemp() function. In March 2000, the OpenBSD mkstemp() code was
  translated to Perl for total control of the code's
  security checking, to ensure the presence of the function regardless of
  operating system and to help with portability. The module was shipped
  as a standard part of perl from v5.6.1.
  
  =head1 SEE ALSO
  
  L<POSIX/tmpnam>, L<POSIX/tmpfile>, L<File::Spec>, L<File::Path>
  
  See L<IO::File> and L<File::MkTemp>, L<Apache::TempFile> for
  different implementations of temporary file handling.
  
  See L<File::Tempdir> for an alternative object-oriented wrapper for
  the C<tempdir> function.
  
  =head1 AUTHOR
  
  Tim Jenness E<lt>tjenness@cpan.orgE<gt>
  
  Copyright (C) 2007-2009 Tim Jenness.
  Copyright (C) 1999-2007 Tim Jenness and the UK Particle Physics and
  Astronomy Research Council. All Rights Reserved.  This program is free
  software; you can redistribute it and/or modify it under the same
  terms as Perl itself.
  
  Original Perl implementation loosely based on the OpenBSD C code for
  mkstemp(). Thanks to Tom Christiansen for suggesting that this module
  should be written and providing ideas for code improvements and
  security enhancements.
  
  =cut
  
  package File::Temp::Dir;
  
  use File::Path qw/ rmtree /;
  use strict;
  use overload '""' => "STRINGIFY", fallback => 1;
  
  # private class specifically to support tempdir objects
  # created by File::Temp->newdir
  
  # ostensibly the same method interface as File::Temp but without
  # inheriting all the IO::Seekable methods and other cruft
  
  # Read-only - returns the name of the temp directory
  
  sub dirname {
    my $self = shift;
    return $self->{DIRNAME};
  }
  
  sub STRINGIFY {
    my $self = shift;
    return $self->dirname;
  }
  
  sub unlink_on_destroy {
    my $self = shift;
    if (@_) {
      $self->{CLEANUP} = shift;
    }
    return $self->{CLEANUP};
  }
  
  sub DESTROY {
    my $self = shift;
    local($., $@, $!, $^E, $?);
    if ($self->unlink_on_destroy && 
        $$ == $self->{LAUNCHPID} && !$File::Temp::KEEP_ALL) {
      if (-d $self->{DIRNAME}) {
        # Some versions of rmtree will abort if you attempt to remove
        # the directory you are sitting in. We protect that and turn it
        # into a warning. We do this because this occurs during object
        # destruction and so can not be caught by the user.
        eval { rmtree($self->{DIRNAME}, $File::Temp::DEBUG, 0); };
        warn $@ if ($@ && $^W);
      }
    }
  }
  
  
  1;
FILE_TEMP

$fatpacked{"HTML/Form.pm"} = <<'HTML_FORM';
  package HTML::Form;
  
  use strict;
  use URI;
  use Carp ();
  
  use vars qw($VERSION $Encode_available);
  $VERSION = "5.829";
  
  eval { require Encode };
  $Encode_available = !$@;
  
  my %form_tags = map {$_ => 1} qw(input textarea button select option);
  
  my %type2class = (
   text     => "TextInput",
   password => "TextInput",
   hidden   => "TextInput",
   textarea => "TextInput",
  
   "reset"  => "IgnoreInput",
  
   radio    => "ListInput",
   checkbox => "ListInput",
   option   => "ListInput",
  
   button   => "SubmitInput",
   submit   => "SubmitInput",
   image    => "ImageInput",
   file     => "FileInput",
  
   keygen   => "KeygenInput",
  );
  
  =head1 NAME
  
  HTML::Form - Class that represents an HTML form element
  
  =head1 SYNOPSIS
  
   use HTML::Form;
   $form = HTML::Form->parse($html, $base_uri);
   $form->value(query => "Perl");
  
   use LWP::UserAgent;
   $ua = LWP::UserAgent->new;
   $response = $ua->request($form->click);
  
  =head1 DESCRIPTION
  
  Objects of the C<HTML::Form> class represents a single HTML
  C<E<lt>formE<gt> ... E<lt>/formE<gt>> instance.  A form consists of a
  sequence of inputs that usually have names, and which can take on
  various values.  The state of a form can be tweaked and it can then be
  asked to provide C<HTTP::Request> objects that can be passed to the
  request() method of C<LWP::UserAgent>.
  
  The following methods are available:
  
  =over 4
  
  =item @forms = HTML::Form->parse( $html_document, $base_uri )
  
  =item @forms = HTML::Form->parse( $html_document, base => $base_uri, %opt )
  
  =item @forms = HTML::Form->parse( $response, %opt )
  
  The parse() class method will parse an HTML document and build up
  C<HTML::Form> objects for each <form> element found.  If called in scalar
  context only returns the first <form>.  Returns an empty list if there
  are no forms to be found.
  
  The required arguments is the HTML document to parse ($html_document) and the
  URI used to retrieve the document ($base_uri).  The base URI is needed to resolve
  relative action URIs.  The provided HTML document should be a Unicode string
  (or US-ASCII).
  
  By default HTML::Form assumes that the original document was UTF-8 encoded and
  thus encode forms that don't specify an explict I<accept-charset> as UTF-8.
  The charset assumed can be overridden by providing the C<charset> option to
  parse().  It's a good idea to be explict about this parameter as well, thus
  the recommended simplest invocation becomes:
  
      my @forms = HTML::Form->parse(
          Encode::decode($encoding, $html_document_bytes),
          base => $base_uri,
  	charset => $encoding,
      );
  
  If the document was retrieved with LWP then the response object provide methods
  to obtain a proper value for C<base> and C<charset>:
  
      my $ua = LWP::UserAgent->new;
      my $response = $ua->get("http://www.example.com/form.html");
      my @forms = HTML::Form->parse($response->decoded_content,
  	base => $response->base,
  	charset => $response->content_charset,
      );
  
  In fact, the parse() method can parse from an C<HTTP::Response> object
  directly, so the example above can be more conveniently written as:
  
      my $ua = LWP::UserAgent->new;
      my $response = $ua->get("http://www.example.com/form.html");
      my @forms = HTML::Form->parse($response);
  
  Note that any object that implements a decoded_content(), base() and
  content_charset() method with similar behaviour as C<HTTP::Response> will do.
  
  Additional options might be passed in to control how the parse method
  behaves.  The following are all the options currently recognized:
  
  =over
  
  =item C<< base => $uri >>
  
  This is the URI used to retrive the original document.  This option is not optional ;-)
  
  =item C<< charset => $str >>
  
  Specify what charset the original document was encoded in.  This is used as
  the default for accept_charset.  If not provided this defaults to "UTF-8".
  
  =item C<< verbose => $bool >>
  
  Warn (print messages to STDERR) about any bad HTML form constructs found.
  You can trap these with $SIG{__WARN__}.
  
  =item C<< strict => $bool >>
  
  Initialize any form objects with the given strict attribute.
  
  =back
  
  =cut
  
  sub parse
  {
      my $class = shift;
      my $html = shift;
      unshift(@_, "base") if @_ == 1;
      my %opt = @_;
  
      require HTML::TokeParser;
      my $p = HTML::TokeParser->new(ref($html) ? $html->decoded_content(ref => 1) : \$html);
      die "Failed to create HTML::TokeParser object" unless $p;
  
      my $base_uri = delete $opt{base};
      my $charset = delete $opt{charset};
      my $strict = delete $opt{strict};
      my $verbose = delete $opt{verbose};
  
      if ($^W) {
  	Carp::carp("Unrecognized option $_ in HTML::Form->parse") for sort keys %opt;
      }
  
      unless (defined $base_uri) {
  	if (ref($html)) {
  	    $base_uri = $html->base;
  	}
  	else {
  	    Carp::croak("HTML::Form::parse: No \$base_uri provided");
  	}
      }
      unless (defined $charset) {
  	if (ref($html) and $html->can("content_charset")) {
  	    $charset = $html->content_charset;
  	}
  	unless ($charset) {
  	    $charset = "UTF-8";
  	}
      }
  
      my @forms;
      my $f;  # current form
  
      my %openselect; # index to the open instance of a select
  
      while (my $t = $p->get_tag) {
  	my($tag,$attr) = @$t;
  	if ($tag eq "form") {
  	    my $action = delete $attr->{'action'};
  	    $action = "" unless defined $action;
  	    $action = URI->new_abs($action, $base_uri);
  	    $f = $class->new($attr->{'method'},
  			     $action,
  			     $attr->{'enctype'});
              $f->accept_charset($attr->{'accept-charset'}) if $attr->{'accept-charset'};
  	    $f->{default_charset} = $charset;
  	    $f->{attr} = $attr;
  	    $f->strict(1) if $strict;
              %openselect = ();
  	    push(@forms, $f);
  	    my(%labels, $current_label);
  	    while (my $t = $p->get_tag) {
  		my($tag, $attr) = @$t;
  		last if $tag eq "/form";
  
  		# if we are inside a label tag, then keep
  		# appending any text to the current label
  		if(defined $current_label) {
  		    $current_label = join " ",
  		        grep { defined and length }
  		        $current_label,
  		        $p->get_phrase;
  		}
  
  		if ($tag eq "input") {
  		    $attr->{value_name} =
  		        exists $attr->{id} && exists $labels{$attr->{id}} ? $labels{$attr->{id}} :
  			defined $current_label                            ?  $current_label      :
  		        $p->get_phrase;
  		}
  
  		if ($tag eq "label") {
  		    $current_label = $p->get_phrase;
  		    $labels{ $attr->{for} } = $current_label
  		        if exists $attr->{for};
  		}
  		elsif ($tag eq "/label") {
  		    $current_label = undef;
  		}
  		elsif ($tag eq "input") {
  		    my $type = delete $attr->{type} || "text";
  		    $f->push_input($type, $attr, $verbose);
  		}
                  elsif ($tag eq "button") {
                      my $type = delete $attr->{type} || "submit";
                      $f->push_input($type, $attr, $verbose);
                  }
  		elsif ($tag eq "textarea") {
  		    $attr->{textarea_value} = $attr->{value}
  		        if exists $attr->{value};
  		    my $text = $p->get_text("/textarea");
  		    $attr->{value} = $text;
  		    $f->push_input("textarea", $attr, $verbose);
  		}
  		elsif ($tag eq "select") {
  		    # rename attributes reserved to come for the option tag
  		    for ("value", "value_name") {
  			$attr->{"select_$_"} = delete $attr->{$_}
  			    if exists $attr->{$_};
  		    }
  		    # count this new select option separately
  		    my $name = $attr->{name};
  		    $name = "" unless defined $name;
  		    $openselect{$name}++;
  
  		    while ($t = $p->get_tag) {
  			my $tag = shift @$t;
  			last if $tag eq "/select";
  			next if $tag =~ m,/?optgroup,;
  			next if $tag eq "/option";
  			if ($tag eq "option") {
  			    my %a = %{$t->[0]};
  			    # rename keys so they don't clash with %attr
  			    for (keys %a) {
  				next if $_ eq "value";
  				$a{"option_$_"} = delete $a{$_};
  			    }
  			    while (my($k,$v) = each %$attr) {
  				$a{$k} = $v;
  			    }
  			    $a{value_name} = $p->get_trimmed_text;
  			    $a{value} = delete $a{value_name}
  				unless defined $a{value};
  			    $a{idx} = $openselect{$name};
  			    $f->push_input("option", \%a, $verbose);
  			}
  			else {
  			    warn("Bad <select> tag '$tag' in $base_uri\n") if $verbose;
  			    if ($tag eq "/form" ||
  				$tag eq "input" ||
  				$tag eq "textarea" ||
  				$tag eq "select" ||
  				$tag eq "keygen")
  			    {
  				# MSIE implictly terminate the <select> here, so we
  				# try to do the same.  Actually the MSIE behaviour
  				# appears really strange:  <input> and <textarea>
  				# do implictly close, but not <select>, <keygen> or
  				# </form>.
  				my $type = ($tag =~ s,^/,,) ? "E" : "S";
  				$p->unget_token([$type, $tag, @$t]);
  				last;
  			    }
  			}
  		    }
  		}
  		elsif ($tag eq "keygen") {
  		    $f->push_input("keygen", $attr, $verbose);
  		}
  	    }
  	}
  	elsif ($form_tags{$tag}) {
  	    warn("<$tag> outside <form> in $base_uri\n") if $verbose;
  	}
      }
      for (@forms) {
  	$_->fixup;
      }
  
      wantarray ? @forms : $forms[0];
  }
  
  sub new {
      my $class = shift;
      my $self = bless {}, $class;
      $self->{method} = uc(shift  || "GET");
      $self->{action} = shift  || Carp::croak("No action defined");
      $self->{enctype} = lc(shift || "application/x-www-form-urlencoded");
      $self->{accept_charset} = "UNKNOWN";
      $self->{default_charset} = "UTF-8";
      $self->{inputs} = [@_];
      $self;
  }
  
  
  sub push_input
  {
      my($self, $type, $attr, $verbose) = @_;
      $type = lc $type;
      my $class = $type2class{$type};
      unless ($class) {
  	Carp::carp("Unknown input type '$type'") if $verbose;
  	$class = "TextInput";
      }
      $class = "HTML::Form::$class";
      my @extra;
      push(@extra, readonly => 1) if $type eq "hidden";
      push(@extra, strict => 1) if $self->{strict};
      if ($type eq "file" && exists $attr->{value}) {
  	# it's not safe to trust the value set by the server
  	# the user always need to explictly set the names of files to upload
  	$attr->{orig_value} = delete $attr->{value};
      }
      delete $attr->{type}; # don't confuse the type argument
      my $input = $class->new(type => $type, %$attr, @extra);
      $input->add_to_form($self);
  }
  
  
  =item $method = $form->method
  
  =item $form->method( $new_method )
  
  This method is gets/sets the I<method> name used for the
  C<HTTP::Request> generated.  It is a string like "GET" or "POST".
  
  =item $action = $form->action
  
  =item $form->action( $new_action )
  
  This method gets/sets the URI which we want to apply the request
  I<method> to.
  
  =item $enctype = $form->enctype
  
  =item $form->enctype( $new_enctype )
  
  This method gets/sets the encoding type for the form data.  It is a
  string like "application/x-www-form-urlencoded" or "multipart/form-data".
  
  =item $accept = $form->accept_charset
  
  =item $form->accept_charset( $new_accept )
  
  This method gets/sets the list of charset encodings that the server processing
  the form accepts. Current implementation supports only one-element lists.
  Default value is "UNKNOWN" which we interpret as a request to use document
  charset as specified by the 'charset' parameter of the parse() method. To
  encode character strings you should have modern perl with Encode module. On
  older perls the setting of this attribute has no effect.
  
  =cut
  
  BEGIN {
      # Set up some accesor
      for (qw(method action enctype accept_charset)) {
  	my $m = $_;
  	no strict 'refs';
  	*{$m} = sub {
  	    my $self = shift;
  	    my $old = $self->{$m};
  	    $self->{$m} = shift if @_;
  	    $old;
  	};
      }
      *uri = \&action;  # alias
  }
  
  =item $value = $form->attr( $name )
  
  =item $form->attr( $name, $new_value )
  
  This method give access to the original HTML attributes of the <form> tag.
  The $name should always be passed in lower case.
  
  Example:
  
     @f = HTML::Form->parse( $html, $foo );
     @f = grep $_->attr("id") eq "foo", @f;
     die "No form named 'foo' found" unless @f;
     $foo = shift @f;
  
  =cut
  
  sub attr {
      my $self = shift;
      my $name = shift;
      return undef unless defined $name;
  
      my $old = $self->{attr}{$name};
      $self->{attr}{$name} = shift if @_;
      return $old;
  }
  
  =item $bool = $form->strict
  
  =item $form->strict( $bool )
  
  Gets/sets the strict attribute of a form.  If the strict is turned on
  the methods that change values of the form will croak if you try to
  set illegal values or modify readonly fields.  The default is not to be strict.
  
  =cut
  
  sub strict {
      my $self = shift;
      my $old = $self->{strict};
      if (@_) {
  	$self->{strict} = shift;
  	for my $input (@{$self->{inputs}}) {
  	    $input->strict($self->{strict});
  	}
      }
      return $old;
  }
  
  
  =item @inputs = $form->inputs
  
  This method returns the list of inputs in the form.  If called in
  scalar context it returns the number of inputs contained in the form.
  See L</INPUTS> for what methods are available for the input objects
  returned.
  
  =cut
  
  sub inputs
  {
      my $self = shift;
      @{$self->{'inputs'}};
  }
  
  
  =item $input = $form->find_input( $selector )
  
  =item $input = $form->find_input( $selector, $type )
  
  =item $input = $form->find_input( $selector, $type, $index )
  
  This method is used to locate specific inputs within the form.  All
  inputs that match the arguments given are returned.  In scalar context
  only the first is returned, or C<undef> if none match.
  
  If $selector is specified, then the input's name, id, class attribute must
  match.  A selector prefixed with '#' must match the id attribute of the input.
  A selector prefixed with '.' matches the class attribute.  A selector prefixed
  with '^' or with no prefix matches the name attribute.
  
  If $type is specified, then the input must have the specified type.
  The following type names are used: "text", "password", "hidden",
  "textarea", "file", "image", "submit", "radio", "checkbox" and "option".
  
  The $index is the sequence number of the input matched where 1 is the
  first.  If combined with $name and/or $type then it select the I<n>th
  input with the given name and/or type.
  
  =cut
  
  sub find_input
  {
      my($self, $name, $type, $no) = @_;
      if (wantarray) {
  	my @res;
  	my $c;
  	for (@{$self->{'inputs'}}) {
  	    next if defined($name) && !$_->selected($name);
  	    next if $type && $type ne $_->{type};
  	    $c++;
  	    next if $no && $no != $c;
  	    push(@res, $_);
  	}
  	return @res;
  	
      }
      else {
  	$no ||= 1;
  	for (@{$self->{'inputs'}}) {
  	    next if defined($name) && !$_->selected($name);
  	    next if $type && $type ne $_->{type};
  	    next if --$no;
  	    return $_;
  	}
  	return undef;
      }
  }
  
  sub fixup
  {
      my $self = shift;
      for (@{$self->{'inputs'}}) {
  	$_->fixup;
      }
  }
  
  
  =item $value = $form->value( $selector )
  
  =item $form->value( $selector, $new_value )
  
  The value() method can be used to get/set the value of some input.  If
  strict is enabled and no input has the indicated name, then this method will croak.
  
  If multiple inputs have the same name, only the first one will be
  affected.
  
  The call:
  
      $form->value('foo')
  
  is basically a short-hand for:
  
      $form->find_input('foo')->value;
  
  =cut
  
  sub value
  {
      my $self = shift;
      my $key  = shift;
      my $input = $self->find_input($key);
      unless ($input) {
  	Carp::croak("No such field '$key'") if $self->{strict};
  	return undef unless @_;
  	$input = $self->push_input("text", { name => $key, value => "" });
      }
      local $Carp::CarpLevel = 1;
      $input->value(@_);
  }
  
  =item @names = $form->param
  
  =item @values = $form->param( $name )
  
  =item $form->param( $name, $value, ... )
  
  =item $form->param( $name, \@values )
  
  Alternative interface to examining and setting the values of the form.
  
  If called without arguments then it returns the names of all the
  inputs in the form.  The names will not repeat even if multiple inputs
  have the same name.  In scalar context the number of different names
  is returned.
  
  If called with a single argument then it returns the value or values
  of inputs with the given name.  If called in scalar context only the
  first value is returned.  If no input exists with the given name, then
  C<undef> is returned.
  
  If called with 2 or more arguments then it will set values of the
  named inputs.  This form will croak if no inputs have the given name
  or if any of the values provided does not fit.  Values can also be
  provided as a reference to an array.  This form will allow unsetting
  all values with the given name as well.
  
  This interface resembles that of the param() function of the CGI
  module.
  
  =cut
  
  sub param {
      my $self = shift;
      if (@_) {
          my $name = shift;
          my @inputs;
          for ($self->inputs) {
              my $n = $_->name;
              next if !defined($n) || $n ne $name;
              push(@inputs, $_);
          }
  
          if (@_) {
              # set
              die "No '$name' parameter exists" unless @inputs;
  	    my @v = @_;
  	    @v = @{$v[0]} if @v == 1 && ref($v[0]);
              while (@v) {
                  my $v = shift @v;
                  my $err;
                  for my $i (0 .. @inputs-1) {
                      eval {
                          $inputs[$i]->value($v);
                      };
                      unless ($@) {
                          undef($err);
                          splice(@inputs, $i, 1);
                          last;
                      }
                      $err ||= $@;
                  }
                  die $err if $err;
              }
  
  	    # the rest of the input should be cleared
  	    for (@inputs) {
  		$_->value(undef);
  	    }
          }
          else {
              # get
              my @v;
              for (@inputs) {
  		if (defined(my $v = $_->value)) {
  		    push(@v, $v);
  		}
              }
              return wantarray ? @v : $v[0];
          }
      }
      else {
          # list parameter names
          my @n;
          my %seen;
          for ($self->inputs) {
              my $n = $_->name;
              next if !defined($n) || $seen{$n}++;
              push(@n, $n);
          }
          return @n;
      }
  }
  
  
  =item $form->try_others( \&callback )
  
  This method will iterate over all permutations of unvisited enumerated
  values (<select>, <radio>, <checkbox>) and invoke the callback for
  each.  The callback is passed the $form as argument.  The return value
  from the callback is ignored and the try_others() method itself does
  not return anything.
  
  =cut
  
  sub try_others
  {
      my($self, $cb) = @_;
      my @try;
      for (@{$self->{'inputs'}}) {
  	my @not_tried_yet = $_->other_possible_values;
  	next unless @not_tried_yet;
  	push(@try, [\@not_tried_yet, $_]);
      }
      return unless @try;
      $self->_try($cb, \@try, 0);
  }
  
  sub _try
  {
      my($self, $cb, $try, $i) = @_;
      for (@{$try->[$i][0]}) {
  	$try->[$i][1]->value($_);
  	&$cb($self);
  	$self->_try($cb, $try, $i+1) if $i+1 < @$try;
      }
  }
  
  
  =item $request = $form->make_request
  
  Will return an C<HTTP::Request> object that reflects the current setting
  of the form.  You might want to use the click() method instead.
  
  =cut
  
  sub make_request
  {
      my $self = shift;
      my $method  = uc $self->{'method'};
      my $uri     = $self->{'action'};
      my $enctype = $self->{'enctype'};
      my @form    = $self->form;
  
      my $charset = $self->accept_charset eq "UNKNOWN" ? $self->{default_charset} : $self->accept_charset;
      if ($Encode_available) {
          foreach my $fi (@form) {
              $fi = Encode::encode($charset, $fi) unless ref($fi);
          }
      }
  
      if ($method eq "GET") {
  	require HTTP::Request;
  	$uri = URI->new($uri, "http");
  	$uri->query_form(@form);
  	return HTTP::Request->new(GET => $uri);
      }
      elsif ($method eq "POST") {
  	require HTTP::Request::Common;
  	return HTTP::Request::Common::POST($uri, \@form,
  					   Content_Type => $enctype);
      }
      else {
  	Carp::croak("Unknown method '$method'");
      }
  }
  
  
  =item $request = $form->click
  
  =item $request = $form->click( $selector )
  
  =item $request = $form->click( $x, $y )
  
  =item $request = $form->click( $selector, $x, $y )
  
  Will "click" on the first clickable input (which will be of type
  C<submit> or C<image>).  The result of clicking is an C<HTTP::Request>
  object that can then be passed to C<LWP::UserAgent> if you want to
  obtain the server response.
  
  If a $selector is specified, we will click on the first clickable input
  matching the selector, and the method will croak if no matching clickable
  input is found.  If $selector is I<not> specified, then it
  is ok if the form contains no clickable inputs.  In this case the
  click() method returns the same request as the make_request() method
  would do.  See description of the find_input() method above for how
  the $selector is specified.
  
  If there are multiple clickable inputs with the same name, then there
  is no way to get the click() method of the C<HTML::Form> to click on
  any but the first.  If you need this you would have to locate the
  input with find_input() and invoke the click() method on the given
  input yourself.
  
  A click coordinate pair can also be provided, but this only makes a
  difference if you clicked on an image.  The default coordinate is
  (1,1).  The upper-left corner of the image is (0,0), but some badly
  coded CGI scripts are known to not recognize this.  Therefore (1,1) was
  selected as a safer default.
  
  =cut
  
  sub click
  {
      my $self = shift;
      my $name;
      $name = shift if (@_ % 2) == 1;  # odd number of arguments
  
      # try to find first submit button to activate
      for (@{$self->{'inputs'}}) {
          next unless $_->can("click");
          next if $name && !$_->selected($name);
  	next if $_->disabled;
  	return $_->click($self, @_);
      }
      Carp::croak("No clickable input with name $name") if $name;
      $self->make_request;
  }
  
  
  =item @kw = $form->form
  
  Returns the current setting as a sequence of key/value pairs.  Note
  that keys might be repeated, which means that some values might be
  lost if the return values are assigned to a hash.
  
  In scalar context this method returns the number of key/value pairs
  generated.
  
  =cut
  
  sub form
  {
      my $self = shift;
      map { $_->form_name_value($self) } @{$self->{'inputs'}};
  }
  
  
  =item $form->dump
  
  Returns a textual representation of current state of the form.  Mainly
  useful for debugging.  If called in void context, then the dump is
  printed on STDERR.
  
  =cut
  
  sub dump
  {
      my $self = shift;
      my $method  = $self->{'method'};
      my $uri     = $self->{'action'};
      my $enctype = $self->{'enctype'};
      my $dump = "$method $uri";
      $dump .= " ($enctype)"
  	if $enctype ne "application/x-www-form-urlencoded";
      $dump .= " [$self->{attr}{name}]"
      	if exists $self->{attr}{name};
      $dump .= "\n";
      for ($self->inputs) {
  	$dump .= "  " . $_->dump . "\n";
      }
      print STDERR $dump unless defined wantarray;
      $dump;
  }
  
  
  #---------------------------------------------------
  package HTML::Form::Input;
  
  =back
  
  =head1 INPUTS
  
  An C<HTML::Form> objects contains a sequence of I<inputs>.  References to
  the inputs can be obtained with the $form->inputs or $form->find_input
  methods.
  
  Note that there is I<not> a one-to-one correspondence between input
  I<objects> and E<lt>inputE<gt> I<elements> in the HTML document.  An
  input object basically represents a name/value pair, so when multiple
  HTML elements contribute to the same name/value pair in the submitted
  form they are combined.
  
  The input elements that are mapped one-to-one are "text", "textarea",
  "password", "hidden", "file", "image", "submit" and "checkbox".  For
  the "radio" and "option" inputs the story is not as simple: All
  E<lt>input type="radio"E<gt> elements with the same name will
  contribute to the same input radio object.  The number of radio input
  objects will be the same as the number of distinct names used for the
  E<lt>input type="radio"E<gt> elements.  For a E<lt>selectE<gt> element
  without the C<multiple> attribute there will be one input object of
  type of "option".  For a E<lt>select multipleE<gt> element there will
  be one input object for each contained E<lt>optionE<gt> element.  Each
  one of these option objects will have the same name.
  
  The following methods are available for the I<input> objects:
  
  =over 4
  
  =cut
  
  sub new
  {
      my $class = shift;
      my $self = bless {@_}, $class;
      $self;
  }
  
  sub add_to_form
  {
      my($self, $form) = @_;
      push(@{$form->{'inputs'}}, $self);
      $self;
  }
  
  sub strict {
      my $self = shift;
      my $old = $self->{strict};
      if (@_) {
  	$self->{strict} = shift;
      }
      $old;
  }
  
  sub fixup {}
  
  
  =item $input->type
  
  Returns the type of this input.  The type is one of the following
  strings: "text", "password", "hidden", "textarea", "file", "image", "submit",
  "radio", "checkbox" or "option".
  
  =cut
  
  sub type
  {
      shift->{type};
  }
  
  =item $name = $input->name
  
  =item $input->name( $new_name )
  
  This method can be used to get/set the current name of the input.
  
  =item $input->id
  
  =item $input->class
  
  These methods can be used to get/set the current id or class attribute for the input.
  
  =item $input->selected( $selector )
  
  Returns TRUE if the given selector matched the input.  See the description of
  the find_input() method above for a description of the selector syntax.
  
  =item $value = $input->value
  
  =item $input->value( $new_value )
  
  This method can be used to get/set the current value of an
  input.
  
  If strict is enabled and the input only can take an enumerated list of values,
  then it is an error to try to set it to something else and the method will
  croak if you try.
  
  You will also be able to set the value of read-only inputs, but a
  warning will be generated if running under C<perl -w>.
  
  =cut
  
  sub name
  {
      my $self = shift;
      my $old = $self->{name};
      $self->{name} = shift if @_;
      $old;
  }
  
  sub id
  {
      my $self = shift;
      my $old = $self->{id};
      $self->{id} = shift if @_;
      $old;
  }
  
  sub class
  {
      my $self = shift;
      my $old = $self->{class};
      $self->{class} = shift if @_;
      $old;
  }
  
  sub selected {
      my($self, $sel) = @_;
      return undef unless defined $sel;
      my $attr =
          $sel =~ s/^\^// ? "name"  :
          $sel =~ s/^#//  ? "id"    :
          $sel =~ s/^\.// ? "class" :
  	                  "name";
      return 0 unless defined $self->{$attr};
      return $self->{$attr} eq $sel;
  }
  
  sub value
  {
      my $self = shift;
      my $old = $self->{value};
      $self->{value} = shift if @_;
      $old;
  }
  
  =item $input->possible_values
  
  Returns a list of all values that an input can take.  For inputs that
  do not have discrete values, this returns an empty list.
  
  =cut
  
  sub possible_values
  {
      return;
  }
  
  =item $input->other_possible_values
  
  Returns a list of all values not tried yet.
  
  =cut
  
  sub other_possible_values
  {
      return;
  }
  
  =item $input->value_names
  
  For some inputs the values can have names that are different from the
  values themselves.  The number of names returned by this method will
  match the number of values reported by $input->possible_values.
  
  When setting values using the value() method it is also possible to
  use the value names in place of the value itself.
  
  =cut
  
  sub value_names {
      return
  }
  
  =item $bool = $input->readonly
  
  =item $input->readonly( $bool )
  
  This method is used to get/set the value of the readonly attribute.
  You are allowed to modify the value of readonly inputs, but setting
  the value will generate some noise when warnings are enabled.  Hidden
  fields always start out readonly.
  
  =cut
  
  sub readonly {
      my $self = shift;
      my $old = $self->{readonly};
      $self->{readonly} = shift if @_;
      $old;
  }
  
  =item $bool = $input->disabled
  
  =item $input->disabled( $bool )
  
  This method is used to get/set the value of the disabled attribute.
  Disabled inputs do not contribute any key/value pairs for the form
  value.
  
  =cut
  
  sub disabled {
      my $self = shift;
      my $old = $self->{disabled};
      $self->{disabled} = shift if @_;
      $old;
  }
  
  =item $input->form_name_value
  
  Returns a (possible empty) list of key/value pairs that should be
  incorporated in the form value from this input.
  
  =cut
  
  sub form_name_value
  {
      my $self = shift;
      my $name = $self->{'name'};
      return unless defined $name;
      return if $self->disabled;
      my $value = $self->value;
      return unless defined $value;
      return ($name => $value);
  }
  
  sub dump
  {
      my $self = shift;
      my $name = $self->name;
      $name = "<NONAME>" unless defined $name;
      my $value = $self->value;
      $value = "<UNDEF>" unless defined $value;
      my $dump = "$name=$value";
  
      my $type = $self->type;
  
      $type .= " disabled" if $self->disabled;
      $type .= " readonly" if $self->readonly;
      return sprintf "%-30s %s", $dump, "($type)" unless $self->{menu};
  
      my @menu;
      my $i = 0;
      for (@{$self->{menu}}) {
  	my $opt = $_->{value};
  	$opt = "<UNDEF>" unless defined $opt;
  	$opt .= "/$_->{name}"
  	    if defined $_->{name} && length $_->{name} && $_->{name} ne $opt;
  	substr($opt,0,0) = "-" if $_->{disabled};
  	if (exists $self->{current} && $self->{current} == $i) {
  	    substr($opt,0,0) = "!" unless $_->{seen};
  	    substr($opt,0,0) = "*";
  	}
  	else {
  	    substr($opt,0,0) = ":" if $_->{seen};
  	}
  	push(@menu, $opt);
  	$i++;
      }
  
      return sprintf "%-30s %-10s %s", $dump, "($type)", "[" . join("|", @menu) . "]";
  }
  
  
  #---------------------------------------------------
  package HTML::Form::TextInput;
  @HTML::Form::TextInput::ISA=qw(HTML::Form::Input);
  
  #input/text
  #input/password
  #input/hidden
  #textarea
  
  sub value
  {
      my $self = shift;
      my $old = $self->{value};
      $old = "" unless defined $old;
      if (@_) {
          Carp::croak("Input '$self->{name}' is readonly")
  	    if $self->{strict} && $self->{readonly};
          my $new = shift;
          my $n = exists $self->{maxlength} ? $self->{maxlength} : undef;
          Carp::croak("Input '$self->{name}' has maxlength '$n'")
  	    if $self->{strict} && defined($n) && defined($new) && length($new) > $n;
  	$self->{value} = $new;
      }
      $old;
  }
  
  #---------------------------------------------------
  package HTML::Form::IgnoreInput;
  @HTML::Form::IgnoreInput::ISA=qw(HTML::Form::Input);
  
  #input/button
  #input/reset
  
  sub value { return }
  
  
  #---------------------------------------------------
  package HTML::Form::ListInput;
  @HTML::Form::ListInput::ISA=qw(HTML::Form::Input);
  
  #select/option   (val1, val2, ....)
  #input/radio     (undef, val1, val2,...)
  #input/checkbox  (undef, value)
  #select-multiple/option (undef, value)
  
  sub new
  {
      my $class = shift;
      my $self = $class->SUPER::new(@_);
  
      my $value = delete $self->{value};
      my $value_name = delete $self->{value_name};
      my $type = $self->{type};
  
      if ($type eq "checkbox") {
  	$value = "on" unless defined $value;
  	$self->{menu} = [
  	    { value => undef, name => "off", },
              { value => $value, name => $value_name, },
          ];
  	$self->{current} = (delete $self->{checked}) ? 1 : 0;
  	;
      }
      else {
  	$self->{option_disabled}++
  	    if $type eq "radio" && delete $self->{disabled};
  	$self->{menu} = [
              {value => $value, name => $value_name},
          ];
  	my $checked = $self->{checked} || $self->{option_selected};
  	delete $self->{checked};
  	delete $self->{option_selected};
  	if (exists $self->{multiple}) {
  	    unshift(@{$self->{menu}}, { value => undef, name => "off"});
  	    $self->{current} = $checked ? 1 : 0;
  	}
  	else {
  	    $self->{current} = 0 if $checked;
  	}
      }
      $self;
  }
  
  sub add_to_form
  {
      my($self, $form) = @_;
      my $type = $self->type;
  
      return $self->SUPER::add_to_form($form)
  	if $type eq "checkbox";
  
      if ($type eq "option" && exists $self->{multiple}) {
  	$self->{disabled} ||= delete $self->{option_disabled};
  	return $self->SUPER::add_to_form($form);
      }
  
      die "Assert" if @{$self->{menu}} != 1;
      my $m = $self->{menu}[0];
      $m->{disabled}++ if delete $self->{option_disabled};
  
      my $prev = $form->find_input($self->{name}, $self->{type}, $self->{idx});
      return $self->SUPER::add_to_form($form) unless $prev;
  
      # merge menues
      $prev->{current} = @{$prev->{menu}} if exists $self->{current};
      push(@{$prev->{menu}}, $m);
  }
  
  sub fixup
  {
      my $self = shift;
      if ($self->{type} eq "option" && !(exists $self->{current})) {
  	$self->{current} = 0;
      }
      $self->{menu}[$self->{current}]{seen}++ if exists $self->{current};
  }
  
  sub disabled
  {
      my $self = shift;
      my $type = $self->type;
  
      my $old = $self->{disabled} || _menu_all_disabled(@{$self->{menu}});
      if (@_) {
  	my $v = shift;
  	$self->{disabled} = $v;
          for (@{$self->{menu}}) {
              $_->{disabled} = $v;
          }
      }
      return $old;
  }
  
  sub _menu_all_disabled {
      for (@_) {
  	return 0 unless $_->{disabled};
      }
      return 1;
  }
  
  sub value
  {
      my $self = shift;
      my $old;
      $old = $self->{menu}[$self->{current}]{value} if exists $self->{current};
      $old = $self->{value} if exists $self->{value};
      if (@_) {
  	my $i = 0;
  	my $val = shift;
  	my $cur;
  	my $disabled;
  	for (@{$self->{menu}}) {
  	    if ((defined($val) && defined($_->{value}) && $val eq $_->{value}) ||
  		(!defined($val) && !defined($_->{value}))
  	       )
  	    {
  		$cur = $i;
  		$disabled = $_->{disabled};
  		last unless $disabled;
  	    }
  	    $i++;
  	}
  	if (!(defined $cur) || $disabled) {
  	    if (defined $val) {
  		# try to search among the alternative names as well
  		my $i = 0;
  		my $cur_ignorecase;
  		my $lc_val = lc($val);
  		for (@{$self->{menu}}) {
  		    if (defined $_->{name}) {
  			if ($val eq $_->{name}) {
  			    $disabled = $_->{disabled};
  			    $cur = $i;
  			    last unless $disabled;
  			}
  			if (!defined($cur_ignorecase) && $lc_val eq lc($_->{name})) {
  			    $cur_ignorecase = $i;
  			}
  		    }
  		    $i++;
  		}
  		unless (defined $cur) {
  		    $cur = $cur_ignorecase;
  		    if (defined $cur) {
  			$disabled = $self->{menu}[$cur]{disabled};
  		    }
  		    elsif ($self->{strict}) {
  			my $n = $self->name;
  		        Carp::croak("Illegal value '$val' for field '$n'");
  		    }
  		}
  	    }
  	    elsif ($self->{strict}) {
  		my $n = $self->name;
  	        Carp::croak("The '$n' field can't be unchecked");
  	    }
  	}
  	if ($self->{strict} && $disabled) {
  	    my $n = $self->name;
  	    Carp::croak("The value '$val' has been disabled for field '$n'");
  	}
  	if (defined $cur) {
  	    $self->{current} = $cur;
  	    $self->{menu}[$cur]{seen}++;
  	    delete $self->{value};
  	}
  	else {
  	    $self->{value} = $val;
  	    delete $self->{current};
  	}
      }
      $old;
  }
  
  =item $input->check
  
  Some input types represent toggles that can be turned on/off.  This
  includes "checkbox" and "option" inputs.  Calling this method turns
  this input on without having to know the value name.  If the input is
  already on, then nothing happens.
  
  This has the same effect as:
  
      $input->value($input->possible_values[1]);
  
  The input can be turned off with:
  
      $input->value(undef);
  
  =cut
  
  sub check
  {
      my $self = shift;
      $self->{current} = 1;
      $self->{menu}[1]{seen}++;
  }
  
  sub possible_values
  {
      my $self = shift;
      map $_->{value}, grep !$_->{disabled}, @{$self->{menu}};
  }
  
  sub other_possible_values
  {
      my $self = shift;
      map $_->{value}, grep !$_->{seen} && !$_->{disabled}, @{$self->{menu}};
  }
  
  sub value_names {
      my $self = shift;
      my @names;
      for (@{$self->{menu}}) {
  	my $n = $_->{name};
  	$n = $_->{value} unless defined $n;
  	push(@names, $n);
      }
      @names;
  }
  
  
  #---------------------------------------------------
  package HTML::Form::SubmitInput;
  @HTML::Form::SubmitInput::ISA=qw(HTML::Form::Input);
  
  #input/image
  #input/submit
  
  =item $input->click($form, $x, $y)
  
  Some input types (currently "submit" buttons and "images") can be
  clicked to submit the form.  The click() method returns the
  corresponding C<HTTP::Request> object.
  
  =cut
  
  sub click
  {
      my($self,$form,$x,$y) = @_;
      for ($x, $y) { $_ = 1 unless defined; }
      local($self->{clicked}) = [$x,$y];
      return $form->make_request;
  }
  
  sub form_name_value
  {
      my $self = shift;
      return unless $self->{clicked};
      return $self->SUPER::form_name_value(@_);
  }
  
  
  #---------------------------------------------------
  package HTML::Form::ImageInput;
  @HTML::Form::ImageInput::ISA=qw(HTML::Form::SubmitInput);
  
  sub form_name_value
  {
      my $self = shift;
      my $clicked = $self->{clicked};
      return unless $clicked;
      return if $self->{disabled};
      my $name = $self->{name};
      $name = (defined($name) && length($name)) ? "$name." : "";
      return ("${name}x" => $clicked->[0],
  	    "${name}y" => $clicked->[1]
  	   );
  }
  
  #---------------------------------------------------
  package HTML::Form::FileInput;
  @HTML::Form::FileInput::ISA=qw(HTML::Form::TextInput);
  
  =back
  
  If the input is of type C<file>, then it has these additional methods:
  
  =over 4
  
  =item $input->file
  
  This is just an alias for the value() method.  It sets the filename to
  read data from.
  
  For security reasons this field will never be initialized from the parsing
  of a form.  This prevents the server from triggering stealth uploads of
  arbitrary files from the client machine.
  
  =cut
  
  sub file {
      my $self = shift;
      $self->value(@_);
  }
  
  =item $filename = $input->filename
  
  =item $input->filename( $new_filename )
  
  This get/sets the filename reported to the server during file upload.
  This attribute defaults to the value reported by the file() method.
  
  =cut
  
  sub filename {
      my $self = shift;
      my $old = $self->{filename};
      $self->{filename} = shift if @_;
      $old = $self->file unless defined $old;
      $old;
  }
  
  =item $content = $input->content
  
  =item $input->content( $new_content )
  
  This get/sets the file content provided to the server during file
  upload.  This method can be used if you do not want the content to be
  read from an actual file.
  
  =cut
  
  sub content {
      my $self = shift;
      my $old = $self->{content};
      $self->{content} = shift if @_;
      $old;
  }
  
  =item @headers = $input->headers
  
  =item input->headers($key => $value, .... )
  
  This get/set additional header fields describing the file uploaded.
  This can for instance be used to set the C<Content-Type> reported for
  the file.
  
  =cut
  
  sub headers {
      my $self = shift;
      my $old = $self->{headers} || [];
      $self->{headers} = [@_] if @_;
      @$old;
  }
  
  sub form_name_value {
      my($self, $form) = @_;
      return $self->SUPER::form_name_value($form)
  	if $form->method ne "POST" ||
  	   $form->enctype ne "multipart/form-data";
  
      my $name = $self->name;
      return unless defined $name;
      return if $self->{disabled};
  
      my $file = $self->file;
      my $filename = $self->filename;
      my @headers = $self->headers;
      my $content = $self->content;
      if (defined $content) {
  	$filename = $file unless defined $filename;
  	$file = undef;
  	unshift(@headers, "Content" => $content);
      }
      elsif (!defined($file) || length($file) == 0) {
  	return;
      }
  
      # legacy (this used to be the way to do it)
      if (ref($file) eq "ARRAY") {
  	my $f = shift @$file;
  	my $fn = shift @$file;
  	push(@headers, @$file);
  	$file = $f;
  	$filename = $fn unless defined $filename;
      }
  
      return ($name => [$file, $filename, @headers]);
  }
  
  package HTML::Form::KeygenInput;
  @HTML::Form::KeygenInput::ISA=qw(HTML::Form::Input);
  
  sub challenge {
      my $self = shift;
      return $self->{challenge};
  }
  
  sub keytype {
      my $self = shift;
      return lc($self->{keytype} || 'rsa');
  }
  
  1;
  
  __END__
  
  =back
  
  =head1 SEE ALSO
  
  L<LWP>, L<LWP::UserAgent>, L<HTML::Parser>
  
  =head1 COPYRIGHT
  
  Copyright 1998-2008 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
HTML_FORM

$fatpacked{"HTTP/Body.pm"} = <<'HTTP_BODY';
  package HTTP::Body;
  
  use strict;
  
  use Carp       qw[ ];
  
  our $VERSION = '1.07';
  
  our $TYPES = {
      'application/octet-stream'          => 'HTTP::Body::OctetStream',
      'application/x-www-form-urlencoded' => 'HTTP::Body::UrlEncoded',
      'multipart/form-data'               => 'HTTP::Body::MultiPart',
      'multipart/related'                 => 'HTTP::Body::XFormsMultipart',
      'application/xml'                   => 'HTTP::Body::XForms'
  };
  
  require HTTP::Body::OctetStream;
  require HTTP::Body::UrlEncoded;
  require HTTP::Body::MultiPart;
  require HTTP::Body::XFormsMultipart;
  require HTTP::Body::XForms;
  
  use HTTP::Headers;
  use HTTP::Message;
  
  =head1 NAME
  
  HTTP::Body - HTTP Body Parser
  
  =head1 SYNOPSIS
  
      use HTTP::Body;
      
      sub handler : method {
          my ( $class, $r ) = @_;
  
          my $content_type   = $r->headers_in->get('Content-Type');
          my $content_length = $r->headers_in->get('Content-Length');
          
          my $body   = HTTP::Body->new( $content_type, $content_length );
          my $length = $content_length;
  
          while ( $length ) {
  
              $r->read( my $buffer, ( $length < 8192 ) ? $length : 8192 );
  
              $length -= length($buffer);
              
              $body->add($buffer);
          }
          
          my $uploads = $body->upload; # hashref
          my $params  = $body->param;  # hashref
          my $body    = $body->body;   # IO::Handle
      }
  
  =head1 DESCRIPTION
  
  HTTP::Body parses chunks of HTTP POST data and supports 
  application/octet-stream, application/x-www-form-urlencoded, and
  multipart/form-data.
  
  Chunked bodies are supported by not passing a length value to new().
  
  It is currently used by L<Catalyst> to parse POST bodies.
  
  =head1 NOTES
  
  When parsing multipart bodies, temporary files are created to store any
  uploaded files.  You must delete these temporary files yourself after
  processing them, or set $body->cleanup(1) to automatically delete them
  at DESTROY-time.
  
  =head1 METHODS
  
  =over 4 
  
  =item new 
  
  Constructor. Takes content type and content length as parameters,
  returns a L<HTTP::Body> object.
  
  =cut
  
  sub new {
      my ( $class, $content_type, $content_length ) = @_;
  
      unless ( @_ >= 2 ) {
          Carp::croak( $class, '->new( $content_type, [ $content_length ] )' );
      }
  
      my $type;
      foreach my $supported ( keys %{$TYPES} ) {
          if ( index( lc($content_type), $supported ) >= 0 ) {
              $type = $supported;
          }
      }
  
      my $body = $TYPES->{ $type || 'application/octet-stream' };
  
      my $self = {
          cleanup        => 0,
          buffer         => '',
          chunk_buffer   => '',
          body           => undef,
          chunked        => !defined $content_length,
          content_length => defined $content_length ? $content_length : -1,
          content_type   => $content_type,
          length         => 0,
          param          => {},
          state          => 'buffering',
          upload         => {},
          tmpdir         => File::Spec->tmpdir(),
      };
  
      bless( $self, $body );
  
      return $self->init;
  }
  
  sub DESTROY {
      my $self = shift;
      
      if ( $self->{cleanup} ) {
          my @temps = ();
          for my $upload ( values %{ $self->{upload} } ) {
              push @temps, map { $_->{tempname} || () }
                  ( ref $upload eq 'ARRAY' ? @{$upload} : $upload );
          }
          
          unlink map { $_ } grep { -e $_ } @temps;
      }
  }
  
  =item add
  
  Add string to internal buffer. Will call spin unless done. returns
  length before adding self.
  
  =cut
  
  sub add {
      my $self = shift;
      
      if ( $self->{chunked} ) {
          $self->{chunk_buffer} .= $_[0];
          
          while ( $self->{chunk_buffer} =~ m/^([\da-fA-F]+).*\x0D\x0A/ ) {
              my $chunk_len = hex($1);
              
              if ( $chunk_len == 0 ) {
                  # Strip chunk len
                  $self->{chunk_buffer} =~ s/^([\da-fA-F]+).*\x0D\x0A//;
                  
                  # End of data, there may be trailing headers
                  if (  my ($headers) = $self->{chunk_buffer} =~ m/(.*)\x0D\x0A/s ) {
                      if ( my $message = HTTP::Message->parse( $headers ) ) {
                          $self->{trailing_headers} = $message->headers;
                      }
                  }
                  
                  $self->{chunk_buffer} = '';
                  
                  # Set content_length equal to the amount of data we read,
                  # so the spin methods can finish up.
                  $self->{content_length} = $self->{length};
              }
              else {
                  # Make sure we have the whole chunk in the buffer (+CRLF)
                  if ( length( $self->{chunk_buffer} ) >= $chunk_len ) {
                      # Strip chunk len
                      $self->{chunk_buffer} =~ s/^([\da-fA-F]+).*\x0D\x0A//;
                      
                      # Pull chunk data out of chunk buffer into real buffer
                      $self->{buffer} .= substr $self->{chunk_buffer}, 0, $chunk_len, '';
                  
                      # Strip remaining CRLF
                      $self->{chunk_buffer} =~ s/^\x0D\x0A//;
                  
                      $self->{length} += $chunk_len;
                  }
                  else {
                      # Not enough data for this chunk, wait for more calls to add()
                      return;
                  }
              }
              
              unless ( $self->{state} eq 'done' ) {
                  $self->spin;
              }
          }
          
          return;
      }
      
      my $cl = $self->content_length;
  
      if ( defined $_[0] ) {
          $self->{length} += length( $_[0] );
          
          # Don't allow buffer data to exceed content-length
          if ( $self->{length} > $cl ) {
              $_[0] = substr $_[0], 0, $cl - $self->{length};
              $self->{length} = $cl;
          }
          
          $self->{buffer} .= $_[0];
      }
  
      unless ( $self->state eq 'done' ) {
          $self->spin;
      }
  
      return ( $self->length - $cl );
  }
  
  =item body
  
  accessor for the body.
  
  =cut
  
  sub body {
      my $self = shift;
      $self->{body} = shift if @_;
      return $self->{body};
  }
  
  =item chunked
  
  Returns 1 if the request is chunked.
  
  =cut
  
  sub chunked {
      return shift->{chunked};
  }
  
  =item cleanup
  
  Set to 1 to enable automatic deletion of temporary files at DESTROY-time.
  
  =cut
  
  sub cleanup {
      my $self = shift;
      $self->{cleanup} = shift if @_;
      return $self->{cleanup};
  }
  
  =item content_length
  
  Returns the content-length for the body data if known.
  Returns -1 if the request is chunked.
  
  =cut
  
  sub content_length {
      return shift->{content_length};
  }
  
  =item content_type
  
  Returns the content-type of the body data.
  
  =cut
  
  sub content_type {
      return shift->{content_type};
  }
  
  =item init
  
  return self.
  
  =cut
  
  sub init {
      return $_[0];
  }
  
  =item length
  
  Returns the total length of data we expect to read if known.
  In the case of a chunked request, returns the amount of data
  read so far.
  
  =cut
  
  sub length {
      return shift->{length};
  }
  
  =item trailing_headers
  
  If a chunked request body had trailing headers, trailing_headers will
  return an HTTP::Headers object populated with those headers.
  
  =cut
  
  sub trailing_headers {
      return shift->{trailing_headers};
  }
  
  =item spin
  
  Abstract method to spin the io handle.
  
  =cut
  
  sub spin {
      Carp::croak('Define abstract method spin() in implementation');
  }
  
  =item state
  
  Returns the current state of the parser.
  
  =cut
  
  sub state {
      my $self = shift;
      $self->{state} = shift if @_;
      return $self->{state};
  }
  
  =item param
  
  Get/set body parameters.
  
  =cut
  
  sub param {
      my $self = shift;
  
      if ( @_ == 2 ) {
  
          my ( $name, $value ) = @_;
  
          if ( exists $self->{param}->{$name} ) {
              for ( $self->{param}->{$name} ) {
                  $_ = [$_] unless ref($_) eq "ARRAY";
                  push( @$_, $value );
              }
          }
          else {
              $self->{param}->{$name} = $value;
          }
      }
  
      return $self->{param};
  }
  
  =item upload
  
  Get/set file uploads.
  
  =cut
  
  sub upload {
      my $self = shift;
  
      if ( @_ == 2 ) {
  
          my ( $name, $upload ) = @_;
  
          if ( exists $self->{upload}->{$name} ) {
              for ( $self->{upload}->{$name} ) {
                  $_ = [$_] unless ref($_) eq "ARRAY";
                  push( @$_, $upload );
              }
          }
          else {
              $self->{upload}->{$name} = $upload;
          }
      }
  
      return $self->{upload};
  }
  
  =item tmpdir 
  
  Specify a different path for temporary files.  Defaults to the system temporary path.
  
  =cut
  
  sub tmpdir {
      my $self = shift;
      $self->{tmpdir} = shift if @_;
      return $self->{tmpdir};
  }
  
  =back
  
  =head1 AUTHOR
  
  Christian Hansen, C<chansen@cpan.org>
  
  Sebastian Riedel, C<sri@cpan.org>
  
  Andy Grundman, C<andy@hybridized.org>
  
  =head1 LICENSE
  
  This library is free software. You can redistribute it and/or modify 
  it under the same terms as perl itself.
  
  =cut
  
  1;
HTTP_BODY

$fatpacked{"HTTP/Body/MultiPart.pm"} = <<'HTTP_BODY_MULTIPART';
  package HTTP::Body::MultiPart;
  
  use strict;
  use base 'HTTP::Body';
  use bytes;
  
  use IO::File;
  use File::Temp 0.14;
  
  =head1 NAME
  
  HTTP::Body::MultiPart - HTTP Body Multipart Parser
  
  =head1 SYNOPSIS
  
      use HTTP::Body::Multipart;
  
  =head1 DESCRIPTION
  
  HTTP Body Multipart Parser.
  
  =head1 METHODS
  
  =over 4
  
  =item init
  
  =cut
  
  sub init {
      my $self = shift;
  
      unless ( $self->content_type =~ /boundary=\"?([^\";]+)\"?/ ) {
          my $content_type = $self->content_type;
          Carp::croak("Invalid boundary in content_type: '$content_type'");
      }
  
      $self->{boundary} = $1;
      $self->{state}    = 'preamble';
  
      return $self;
  }
  
  =item spin
  
  =cut
  
  sub spin {
      my $self = shift;
  
      while (1) {
  
          if ( $self->{state} =~ /^(preamble|boundary|header|body)$/ ) {
              my $method = "parse_$1";
              return unless $self->$method;
          }
  
          else {
              Carp::croak('Unknown state');
          }
      }
  }
  
  =item boundary
  
  =cut
  
  sub boundary {
      return shift->{boundary};
  }
  
  =item boundary_begin
  
  =cut
  
  sub boundary_begin {
      return "--" . shift->boundary;
  }
  
  =item boundary_end
  
  =cut
  
  sub boundary_end {
      return shift->boundary_begin . "--";
  }
  
  =item crlf
  
  =cut
  
  sub crlf () {
      return "\x0d\x0a";
  }
  
  =item delimiter_begin
  
  =cut
  
  sub delimiter_begin {
      my $self = shift;
      return $self->crlf . $self->boundary_begin;
  }
  
  =item delimiter_end
  
  =cut
  
  sub delimiter_end {
      my $self = shift;
      return $self->crlf . $self->boundary_end;
  }
  
  =item parse_preamble
  
  =cut
  
  sub parse_preamble {
      my $self = shift;
  
      my $index = index( $self->{buffer}, $self->boundary_begin );
  
      unless ( $index >= 0 ) {
          return 0;
      }
  
      # replace preamble with CRLF so we can match dash-boundary as delimiter
      substr( $self->{buffer}, 0, $index, $self->crlf );
  
      $self->{state} = 'boundary';
  
      return 1;
  }
  
  =item parse_boundary
  
  =cut
  
  sub parse_boundary {
      my $self = shift;
  
      if ( index( $self->{buffer}, $self->delimiter_begin . $self->crlf ) == 0 ) {
  
          substr( $self->{buffer}, 0, length( $self->delimiter_begin ) + 2, '' );
          $self->{part}  = {};
          $self->{state} = 'header';
  
          return 1;
      }
  
      if ( index( $self->{buffer}, $self->delimiter_end . $self->crlf ) == 0 ) {
  
          substr( $self->{buffer}, 0, length( $self->delimiter_end ) + 2, '' );
          $self->{part}  = {};
          $self->{state} = 'done';
  
          return 0;
      }
  
      return 0;
  }
  
  =item parse_header
  
  =cut
  
  sub parse_header {
      my $self = shift;
  
      my $crlf  = $self->crlf;
      my $index = index( $self->{buffer}, $crlf . $crlf );
  
      unless ( $index >= 0 ) {
          return 0;
      }
  
      my $header = substr( $self->{buffer}, 0, $index );
  
      substr( $self->{buffer}, 0, $index + 4, '' );
  
      my @headers;
      for ( split /$crlf/, $header ) {
          if (s/^[ \t]+//) {
              $headers[-1] .= $_;
          }
          else {
              push @headers, $_;
          }
      }
  
      my $token = qr/[^][\x00-\x1f\x7f()<>@,;:\\"\/?={} \t]+/;
  
      for my $header (@headers) {
  
          $header =~ s/^($token):[\t ]*//;
  
          ( my $field = $1 ) =~ s/\b(\w)/uc($1)/eg;
  
          if ( exists $self->{part}->{headers}->{$field} ) {
              for ( $self->{part}->{headers}->{$field} ) {
                  $_ = [$_] unless ref($_) eq "ARRAY";
                  push( @$_, $header );
              }
          }
          else {
              $self->{part}->{headers}->{$field} = $header;
          }
      }
  
      $self->{state} = 'body';
  
      return 1;
  }
  
  =item parse_body
  
  =cut
  
  sub parse_body {
      my $self = shift;
  
      my $index = index( $self->{buffer}, $self->delimiter_begin );
  
      if ( $index < 0 ) {
  
          # make sure we have enough buffer to detect end delimiter
          my $length = length( $self->{buffer} ) - ( length( $self->delimiter_end ) + 2 );
  
          unless ( $length > 0 ) {
              return 0;
          }
  
          $self->{part}->{data} .= substr( $self->{buffer}, 0, $length, '' );
          $self->{part}->{size} += $length;
          $self->{part}->{done} = 0;
  
          $self->handler( $self->{part} );
  
          return 0;
      }
  
      $self->{part}->{data} .= substr( $self->{buffer}, 0, $index, '' );
      $self->{part}->{size} += $index;
      $self->{part}->{done} = 1;
  
      $self->handler( $self->{part} );
  
      $self->{state} = 'boundary';
  
      return 1;
  }
  
  =item handler
  
  =cut
  
  sub handler {
      my ( $self, $part ) = @_;
  
      unless ( exists $part->{name} ) {
  
          my $disposition = $part->{headers}->{'Content-Disposition'};
          my ($name)      = $disposition =~ / name="?([^\";]+)"?/;
          my ($filename)  = $disposition =~ / filename="?([^\"]*)"?/;
          # Need to match empty filenames above, so this part is flagged as an upload type
  
          $part->{name} = $name;
  
          if ( defined $filename ) {
              $part->{filename} = $filename;
  
              if ( $filename ne "" ) {
                  my $fh = File::Temp->new( UNLINK => 0, DIR => $self->tmpdir );
  
                  $part->{fh}       = $fh;
                  $part->{tempname} = $fh->filename;
              }
          }
      }
  
      if ( $part->{fh} && ( my $length = length( $part->{data} ) ) ) {
          $part->{fh}->write( substr( $part->{data}, 0, $length, '' ), $length );
      }
  
      if ( $part->{done} ) {
  
          if ( exists $part->{filename} ) {
              if ( $part->{filename} ne "" ) {
                  $part->{fh}->close if defined $part->{fh};
  
                  delete @{$part}{qw[ data done fh ]};
  
                  $self->upload( $part->{name}, $part );
              }
          }
          else {
              $self->param( $part->{name}, $part->{data} );
          }
      }
  }
  
  =back
  
  =head1 AUTHOR
  
  Christian Hansen, C<ch@ngmedia.com>
  
  =head1 LICENSE
  
  This library is free software . You can redistribute it and/or modify 
  it under the same terms as perl itself.
  
  =cut
  
  1;
HTTP_BODY_MULTIPART

$fatpacked{"HTTP/Body/OctetStream.pm"} = <<'HTTP_BODY_OCTETSTREAM';
  package HTTP::Body::OctetStream;
  
  use strict;
  use base 'HTTP::Body';
  use bytes;
  
  use File::Temp 0.14;
  
  =head1 NAME
  
  HTTP::Body::OctetStream - HTTP Body OctetStream Parser
  
  =head1 SYNOPSIS
  
      use HTTP::Body::OctetStream;
  
  =head1 DESCRIPTION
  
  HTTP Body OctetStream Parser.
  
  =head1 METHODS
  
  =over 4
  
  =item spin
  
  =cut
  
  sub spin {
      my $self = shift;
  
      unless ( $self->body ) {
          $self->body( File::Temp->new( DIR => $self->tmpdir ) );
      }
  
      if ( my $length = length( $self->{buffer} ) ) {
          $self->body->write( substr( $self->{buffer}, 0, $length, '' ), $length );
      }
  
      if ( $self->length == $self->content_length ) {
          seek( $self->body, 0, 0 );
          $self->state('done');
      }
  }
  
  =back
  
  =head1 AUTHOR
  
  Christian Hansen, C<ch@ngmedia.com>
  
  =head1 LICENSE
  
  This library is free software . You can redistribute it and/or modify 
  it under the same terms as perl itself.
  
  =cut
  
  1;
HTTP_BODY_OCTETSTREAM

$fatpacked{"HTTP/Body/UrlEncoded.pm"} = <<'HTTP_BODY_URLENCODED';
  package HTTP::Body::UrlEncoded;
  
  use strict;
  use base 'HTTP::Body';
  use bytes;
  
  our $DECODE = qr/%([0-9a-fA-F]{2})/;
  
  our %hex_chr;
  
  for my $num ( 0 .. 255 ) {
      my $h = sprintf "%02X", $num;
      $hex_chr{ lc $h } = $hex_chr{ uc $h } = chr $num;
  }
  
  =head1 NAME
  
  HTTP::Body::UrlEncoded - HTTP Body UrlEncoded Parser
  
  =head1 SYNOPSIS
  
      use HTTP::Body::UrlEncoded;
  
  =head1 DESCRIPTION
  
  HTTP Body UrlEncoded Parser.
  
  =head1 METHODS
  
  =over 4
  
  =item spin
  
  =cut
  
  sub spin {
      my $self = shift;
  
      return unless $self->length == $self->content_length;
      
      # I tested parsing this using APR::Request, but perl is faster
      # Pure-Perl    2560/s
      # APR::Request 2305/s
      
      # Note: s/// appears faster than tr///
      $self->{buffer} =~ s/\+/ /g;
  
      for my $pair ( split( /[&;](?:\s+)?/, $self->{buffer} ) ) {
  
          my ( $name, $value ) = split( /=/, $pair , 2 );
  
          next unless defined $name;
          next unless defined $value;
          
          $name  =~ s/$DECODE/$hex_chr{$1}/gs;
          $value =~ s/$DECODE/$hex_chr{$1}/gs;
  
          $self->param( $name, $value );
      }
  
      $self->{buffer} = '';
      $self->{state}  = 'done';
  }
  
  =back
  
  =head1 AUTHORS
  
  Christian Hansen, C<ch@ngmedia.com>
  
  Andy Grundman, C<andy@hybridized.org>
  
  =head1 LICENSE
  
  This library is free software . You can redistribute it and/or modify 
  it under the same terms as perl itself.
  
  =cut
  
  1;
HTTP_BODY_URLENCODED

$fatpacked{"HTTP/Body/XForms.pm"} = <<'HTTP_BODY_XFORMS';
  package HTTP::Body::XForms;
  
  use strict;
  use base 'HTTP::Body';
  use bytes;
  
  use File::Temp 0.14;
  
  =head1 NAME
  
  HTTP::Body::XForms - HTTP Body XForms Parser
  
  =head1 SYNOPSIS
  
      use HTTP::Body::XForms;
  
  =head1 DESCRIPTION
  
  HTTP Body XForms Parser. This module parses single part XForms
  submissions, which are identifiable by the content-type
  application/xml. The XML is stored unparsed on the parameter
  XForms:Model.
  
  =head1 METHODS
  
  =over 4
  
  =item spin
  
  This method is overwrited to set the param XForms:Model with
  the buffer content.
  
  =cut
  
  sub spin {
      my $self = shift;
  
      $self->body($self->{buffer});
      $self->param( 'XForms:Model', $self->{buffer} );
      $self->{buffer} = '';
      $self->{state}  = 'done';
  
      return $self->SUPER::init();
  }
  
  =back
  
  =head1 AUTHOR
  
  Daniel Ruoso, C<daniel@ruoso.com>
  
  =head1 LICENSE
  
  This library is free software . You can redistribute it and/or modify 
  it under the same terms as perl itself.
  
  =cut
  
  1;
HTTP_BODY_XFORMS

$fatpacked{"HTTP/Body/XFormsMultipart.pm"} = <<'HTTP_BODY_XFORMSMULTIPART';
  package HTTP::Body::XFormsMultipart;
  
  use strict;
  use base 'HTTP::Body::MultiPart';
  use bytes;
  
  use IO::File;
  use File::Temp 0.14;
  
  =head1 NAME
  
  HTTP::Body::XFormsMultipart - HTTP Body XForms multipart/related submission Parser
  
  =head1 SYNOPSIS
  
      use HTTP::Body::XForms;
  
  =head1 DESCRIPTION
  
  HTTP Body XForms submission Parser. Inherits HTTP::Body::MultiPart.
  
  This body type is used to parse XForms submission. In this case, the
  XML part that contains the model is indicated by the start attribute
  in the content-type. The XML content is stored unparsed on the
  parameter XForms:Model.
  
  =head1 METHODS
  
  =over 4
  
  =item init
  
  This function is overrided to detect the start part of the
  multipart/related post.
  
  =cut
  
  sub init {
      my $self = shift;
      $self->SUPER::init(@_);
      unless ( $self->content_type =~ /start=\"?\<?([^\"\>;,]+)\>?\"?/ ) {
          my $content_type = $self->content_type;
          Carp::croak( "Invalid boundary in content_type: '$content_type'" );
      }
      
      $self->{start} = $1;
  
      return $self;
  }
  
  =item start
  
  Defines the start part of the multipart/related body.
  
  =cut
  
  sub start {
      return shift->{start};
  }
  
  =item handler
  
  This function is overrided to differ the start part, which should be
  set as the XForms:Model param if its content type is application/xml.
  
  =cut
  
  sub handler {
      my ( $self, $part ) = @_;
  
      my $contentid = $part->{headers}{'Content-ID'};
      $contentid =~ s/^.*[\<\"]//;
      $contentid =~ s/[\>\"].*$//;
      
      if ( $contentid eq $self->start ) {
          $part->{name} = 'XForms:Model';
          if ($part->{done}) {
              $self->body($part->{data});
          }
      }
      elsif ( defined $contentid ) {
          $part->{name}     = $contentid;
          $part->{filename} = $contentid;
      }
  
      return $self->SUPER::handler($part);
  }
  
  =back
  
  =head1 AUTHOR
  
  Daniel Ruoso C<daniel@ruoso.com>
  
  =head1 LICENSE
  
  This library is free software . You can redistribute it and/or modify 
  it under the same terms as perl itself.
  
  =cut
  
  1;
HTTP_BODY_XFORMSMULTIPART

$fatpacked{"HTTP/Config.pm"} = <<'HTTP_CONFIG';
  package HTTP::Config;
  
  use strict;
  use URI;
  use vars qw($VERSION);
  
  $VERSION = "5.835";
  
  sub new {
      my $class = shift;
      return bless [], $class;
  }
  
  sub entries {
      my $self = shift;
      @$self;
  }
  
  sub empty {
      my $self = shift;
      not @$self;
  }
  
  sub add {
      if (@_ == 2) {
          my $self = shift;
          push(@$self, shift);
          return;
      }
      my($self, %spec) = @_;
      push(@$self, \%spec);
      return;
  }
  
  sub find2 {
      my($self, %spec) = @_;
      my @found;
      my @rest;
   ITEM:
      for my $item (@$self) {
          for my $k (keys %spec) {
              if (!exists $item->{$k} || $spec{$k} ne $item->{$k}) {
                  push(@rest, $item);
                  next ITEM;
              }
          }
          push(@found, $item);
      }
      return \@found unless wantarray;
      return \@found, \@rest;
  }
  
  sub find {
      my $self = shift;
      my $f = $self->find2(@_);
      return @$f if wantarray;
      return $f->[0];
  }
  
  sub remove {
      my($self, %spec) = @_;
      my($removed, $rest) = $self->find2(%spec);
      @$self = @$rest if @$removed;
      return @$removed;
  }
  
  my %MATCH = (
      m_scheme => sub {
          my($v, $uri) = @_;
          return $uri->_scheme eq $v;  # URI known to be canonical
      },
      m_secure => sub {
          my($v, $uri) = @_;
          my $secure = $uri->can("secure") ? $uri->secure : $uri->_scheme eq "https";
          return $secure == !!$v;
      },
      m_host_port => sub {
          my($v, $uri) = @_;
          return unless $uri->can("host_port");
          return $uri->host_port eq $v, 7;
      },
      m_host => sub {
          my($v, $uri) = @_;
          return unless $uri->can("host");
          return $uri->host eq $v, 6;
      },
      m_port => sub {
          my($v, $uri) = @_;
          return unless $uri->can("port");
          return $uri->port eq $v;
      },
      m_domain => sub {
          my($v, $uri) = @_;
          return unless $uri->can("host");
          my $h = $uri->host;
          $h = "$h.local" unless $h =~ /\./;
          $v = ".$v" unless $v =~ /^\./;
          return length($v), 5 if substr($h, -length($v)) eq $v;
          return 0;
      },
      m_path => sub {
          my($v, $uri) = @_;
          return unless $uri->can("path");
          return $uri->path eq $v, 4;
      },
      m_path_prefix => sub {
          my($v, $uri) = @_;
          return unless $uri->can("path");
          my $path = $uri->path;
          my $len = length($v);
          return $len, 3 if $path eq $v;
          return 0 if length($path) <= $len;
          $v .= "/" unless $v =~ m,/\z,,;
          return $len, 3 if substr($path, 0, length($v)) eq $v;
          return 0;
      },
      m_path_match => sub {
          my($v, $uri) = @_;
          return unless $uri->can("path");
          return $uri->path =~ $v;
      },
      m_uri__ => sub {
          my($v, $k, $uri) = @_;
          return unless $uri->can($k);
          return 1 unless defined $v;
          return $uri->$k eq $v;
      },
      m_method => sub {
          my($v, $uri, $request) = @_;
          return $request && $request->method eq $v;
      },
      m_proxy => sub {
          my($v, $uri, $request) = @_;
          return $request && ($request->{proxy} || "") eq $v;
      },
      m_code => sub {
          my($v, $uri, $request, $response) = @_;
          $v =~ s/xx\z//;
          return unless $response;
          return length($v), 2 if substr($response->code, 0, length($v)) eq $v;
      },
      m_media_type => sub {  # for request too??
          my($v, $uri, $request, $response) = @_;
          return unless $response;
          return 1, 1 if $v eq "*/*";
          my $ct = $response->content_type;
          return 2, 1 if $v =~ s,/\*\z,, && $ct =~ m,^\Q$v\E/,;
          return 3, 1 if $v eq "html" && $response->content_is_html;
          return 4, 1 if $v eq "xhtml" && $response->content_is_xhtml;
          return 10, 1 if $v eq $ct;
          return 0;
      },
      m_header__ => sub {
          my($v, $k, $uri, $request, $response) = @_;
          return unless $request;
          return 1 if $request->header($k) eq $v;
          return 1 if $response && $response->header($k) eq $v;
          return 0;
      },
      m_response_attr__ => sub {
          my($v, $k, $uri, $request, $response) = @_;
          return unless $response;
          return 1 if !defined($v) && exists $response->{$k};
          return 0 unless exists $response->{$k};
          return 1 if $response->{$k} eq $v;
          return 0;
      },
  );
  
  sub matching {
      my $self = shift;
      if (@_ == 1) {
          if ($_[0]->can("request")) {
              unshift(@_, $_[0]->request);
              unshift(@_, undef) unless defined $_[0];
          }
          unshift(@_, $_[0]->uri_canonical) if $_[0] && $_[0]->can("uri_canonical");
      }
      my($uri, $request, $response) = @_;
      $uri = URI->new($uri) unless ref($uri);
  
      my @m;
   ITEM:
      for my $item (@$self) {
          my $order;
          for my $ikey (keys %$item) {
              my $mkey = $ikey;
              my $k;
              $k = $1 if $mkey =~ s/__(.*)/__/;
              if (my $m = $MATCH{$mkey}) {
                  #print "$ikey $mkey\n";
                  my($c, $o);
                  my @arg = (
                      defined($k) ? $k : (),
                      $uri, $request, $response
                  );
                  my $v = $item->{$ikey};
                  $v = [$v] unless ref($v) eq "ARRAY";
                  for (@$v) {
                      ($c, $o) = $m->($_, @arg);
                      #print "  - $_ ==> $c $o\n";
                      last if $c;
                  }
                  next ITEM unless $c;
                  $order->[$o || 0] += $c;
              }
          }
          $order->[7] ||= 0;
          $item->{_order} = join(".", reverse map sprintf("%03d", $_ || 0), @$order);
          push(@m, $item);
      }
      @m = sort { $b->{_order} cmp $a->{_order} } @m;
      delete $_->{_order} for @m;
      return @m if wantarray;
      return $m[0];
  }
  
  sub add_item {
      my $self = shift;
      my $item = shift;
      return $self->add(item => $item, @_);
  }
  
  sub remove_items {
      my $self = shift;
      return map $_->{item}, $self->remove(@_);
  }
  
  sub matching_items {
      my $self = shift;
      return map $_->{item}, $self->matching(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Config - Configuration for request and response objects
  
  =head1 SYNOPSIS
  
   use HTTP::Config;
   my $c = HTTP::Config->new;
   $c->add(m_domain => ".example.com", m_scheme => "http", verbose => 1);
   
   use HTTP::Request;
   my $request = HTTP::Request->new(GET => "http://www.example.com");
   
   if (my @m = $c->matching($request)) {
      print "Yadayada\n" if $m[0]->{verbose};
   }
  
  =head1 DESCRIPTION
  
  An C<HTTP::Config> object is a list of entries that
  can be matched against request or request/response pairs.  Its
  purpose is to hold configuration data that can be looked up given a
  request or response object.
  
  Each configuration entry is a hash.  Some keys specify matching to
  occur against attributes of request/response objects.  Other keys can
  be used to hold user data.
  
  The following methods are provided:
  
  =over 4
  
  =item $conf = HTTP::Config->new
  
  Constructs a new empty C<HTTP::Config> object and returns it.
  
  =item $conf->entries
  
  Returns the list of entries in the configuration object.
  In scalar context returns the number of entries.
  
  =item $conf->empty
  
  Return true if there are no entries in the configuration object.
  This is just a shorthand for C<< not $conf->entries >>.
  
  =item $conf->add( %matchspec, %other )
  
  =item $conf->add( \%entry )
  
  Adds a new entry to the configuration.
  You can either pass separate key/value pairs or a hash reference.
  
  =item $conf->remove( %spec )
  
  Removes (and returns) the entries that have matches for all the key/value pairs in %spec.
  If %spec is empty this will match all entries; so it will empty the configuation object.
  
  =item $conf->matching( $uri, $request, $response )
  
  =item $conf->matching( $uri )
  
  =item $conf->matching( $request )
  
  =item $conf->matching( $response )
  
  Returns the entries that match the given $uri, $request and $response triplet.
  
  If called with a single $request object then the $uri is obtained by calling its 'uri_canonical' method.
  If called with a single $response object, then the request object is obtained by calling its 'request' method;
  and then the $uri is obtained as if a single $request was provided.
  
  The entries are returned with the most specific matches first.
  In scalar context returns the most specific match or C<undef> in none match.
  
  =item $conf->add_item( $item, %matchspec )
  
  =item $conf->remove_items( %spec )
  
  =item $conf->matching_items( $uri, $request, $response )
  
  Wrappers that hides the entries themselves.
  
  =back
  
  =head2 Matching
  
  The following keys on a configuration entry specify matching.  For all
  of these you can provide an array of values instead of a single value.
  The entry matches if at least one of the values in the array matches.
  
  Entries that require match against a response object attribute will never match
  unless a response object was provided.
  
  =over
  
  =item m_scheme => $scheme
  
  Matches if the URI uses the specified scheme; e.g. "http".
  
  =item m_secure => $bool
  
  If $bool is TRUE; matches if the URI uses a secure scheme.  If $bool
  is FALSE; matches if the URI does not use a secure scheme.  An example
  of a secure scheme is "https".
  
  =item m_host_port => "$hostname:$port"
  
  Matches if the URI's host_port method return the specified value.
  
  =item m_host => $hostname
  
  Matches if the URI's host method returns the specified value.
  
  =item m_port => $port
  
  Matches if the URI's port method returns the specified value.
  
  =item m_domain => ".$domain"
  
  Matches if the URI's host method return a value that within the given
  domain.  The hostname "www.example.com" will for instance match the
  domain ".com".
  
  =item m_path => $path
  
  Matches if the URI's path method returns the specified value.
  
  =item m_path_prefix => $path
  
  Matches if the URI's path is the specified path or has the specified
  path as prefix.
  
  =item m_path_match => $Regexp
  
  Matches if the regular expression matches the URI's path.  Eg. qr/\.html$/.
  
  =item m_method => $method
  
  Matches if the request method matches the specified value. Eg. "GET" or "POST".
  
  =item m_code => $digit
  
  =item m_code => $status_code
  
  Matches if the response status code matches.  If a single digit is
  specified; matches for all response status codes beginning with that digit.
  
  =item m_proxy => $url
  
  Matches if the request is to be sent to the given Proxy server.
  
  =item m_media_type => "*/*"
  
  =item m_media_type => "text/*"
  
  =item m_media_type => "html"
  
  =item m_media_type => "xhtml"
  
  =item m_media_type => "text/html"
  
  Matches if the response media type matches.
  
  With a value of "html" matches if $response->content_is_html returns TRUE.
  With a value of "xhtml" matches if $response->content_is_xhtml returns TRUE.
  
  =item m_uri__I<$method> => undef
  
  Matches if the URI object provides the method.
  
  =item m_uri__I<$method> => $string
  
  Matches if the URI's $method method returns the given value.
  
  =item m_header__I<$field> => $string
  
  Matches if either the request or the response have a header $field with the given value.
  
  =item m_response_attr__I<$key> => undef
  
  =item m_response_attr__I<$key> => $string
  
  Matches if the response object has that key, or the entry has the given value.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>, L<HTTP::Request>, L<HTTP::Response>
  
  =head1 COPYRIGHT
  
  Copyright 2008, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
HTTP_CONFIG

$fatpacked{"HTTP/Cookies.pm"} = <<'HTTP_COOKIES';
  package HTTP::Cookies;
  
  use strict;
  use HTTP::Date qw(str2time parse_date time2str);
  use HTTP::Headers::Util qw(_split_header_words join_header_words);
  
  use vars qw($VERSION $EPOCH_OFFSET);
  $VERSION = "5.833";
  
  # Legacy: because "use "HTTP::Cookies" used be the ONLY way
  #  to load the class HTTP::Cookies::Netscape.
  require HTTP::Cookies::Netscape;
  
  $EPOCH_OFFSET = 0;  # difference from Unix epoch
  if ($^O eq "MacOS") {
      require Time::Local;
      $EPOCH_OFFSET = Time::Local::timelocal(0,0,0,1,0,70);
  }
  
  # A HTTP::Cookies object is a hash.  The main attribute is the
  # COOKIES 3 level hash:  $self->{COOKIES}{$domain}{$path}{$key}.
  
  sub new
  {
      my $class = shift;
      my $self = bless {
  	COOKIES => {},
      }, $class;
      my %cnf = @_;
      for (keys %cnf) {
  	$self->{lc($_)} = $cnf{$_};
      }
      $self->load;
      $self;
  }
  
  
  sub add_cookie_header
  {
      my $self = shift;
      my $request = shift || return;
      my $url = $request->uri;
      my $scheme = $url->scheme;
      unless ($scheme =~ /^https?\z/) {
  	return;
      }
  
      my $domain = _host($request, $url);
      $domain = "$domain.local" unless $domain =~ /\./;
      my $secure_request = ($scheme eq "https");
      my $req_path = _url_path($url);
      my $req_port = $url->port;
      my $now = time();
      _normalize_path($req_path) if $req_path =~ /%/;
  
      my @cval;    # cookie values for the "Cookie" header
      my $set_ver;
      my $netscape_only = 0; # An exact domain match applies to any cookie
  
      while ($domain =~ /\./) {
          # Checking $domain for cookies"
  	my $cookies = $self->{COOKIES}{$domain};
  	next unless $cookies;
  	if ($self->{delayload} && defined($cookies->{'//+delayload'})) {
  	    my $cookie_data = $cookies->{'//+delayload'}{'cookie'};
  	    delete $self->{COOKIES}{$domain};
  	    $self->load_cookie($cookie_data->[1]);
  	    $cookies = $self->{COOKIES}{$domain};
  	    next unless $cookies;  # should not really happen
  	}
  
  	# Want to add cookies corresponding to the most specific paths
  	# first (i.e. longest path first)
  	my $path;
  	for $path (sort {length($b) <=> length($a) } keys %$cookies) {
  	    if (index($req_path, $path) != 0) {
  		next;
  	    }
  
  	    my($key,$array);
  	    while (($key,$array) = each %{$cookies->{$path}}) {
  		my($version,$val,$port,$path_spec,$secure,$expires) = @$array;
  		if ($secure && !$secure_request) {
  		    next;
  		}
  		if ($expires && $expires < $now) {
  		    next;
  		}
  		if ($port) {
  		    my $found;
  		    if ($port =~ s/^_//) {
  			# The corresponding Set-Cookie attribute was empty
  			$found++ if $port eq $req_port;
  			$port = "";
  		    }
  		    else {
  			my $p;
  			for $p (split(/,/, $port)) {
  			    $found++, last if $p eq $req_port;
  			}
  		    }
  		    unless ($found) {
  			next;
  		    }
  		}
  		if ($version > 0 && $netscape_only) {
  		    next;
  		}
  
  		# set version number of cookie header.
  	        # XXX: What should it be if multiple matching
                  #      Set-Cookie headers have different versions themselves
  		if (!$set_ver++) {
  		    if ($version >= 1) {
  			push(@cval, "\$Version=$version");
  		    }
  		    elsif (!$self->{hide_cookie2}) {
  			$request->header(Cookie2 => '$Version="1"');
  		    }
  		}
  
  		# do we need to quote the value
  		if ($val =~ /\W/ && $version) {
  		    $val =~ s/([\\\"])/\\$1/g;
  		    $val = qq("$val");
  		}
  
  		# and finally remember this cookie
  		push(@cval, "$key=$val");
  		if ($version >= 1) {
  		    push(@cval, qq(\$Path="$path"))     if $path_spec;
  		    push(@cval, qq(\$Domain="$domain")) if $domain =~ /^\./;
  		    if (defined $port) {
  			my $p = '$Port';
  			$p .= qq(="$port") if length $port;
  			push(@cval, $p);
  		    }
  		}
  
  	    }
          }
  
      } continue {
  	# Try with a more general domain, alternately stripping
  	# leading name components and leading dots.  When this
  	# results in a domain with no leading dot, it is for
  	# Netscape cookie compatibility only:
  	#
  	# a.b.c.net	Any cookie
  	# .b.c.net	Any cookie
  	# b.c.net	Netscape cookie only
  	# .c.net	Any cookie
  
  	if ($domain =~ s/^\.+//) {
  	    $netscape_only = 1;
  	}
  	else {
  	    $domain =~ s/[^.]*//;
  	    $netscape_only = 0;
  	}
      }
  
      if (@cval) {
  	if (my $old = $request->header("Cookie")) {
  	    unshift(@cval, $old);
  	}
  	$request->header(Cookie => join("; ", @cval));
      }
  
      $request;
  }
  
  
  sub extract_cookies
  {
      my $self = shift;
      my $response = shift || return;
  
      my @set = _split_header_words($response->_header("Set-Cookie2"));
      my @ns_set = $response->_header("Set-Cookie");
  
      return $response unless @set || @ns_set;  # quick exit
  
      my $request = $response->request;
      my $url = $request->uri;
      my $req_host = _host($request, $url);
      $req_host = "$req_host.local" unless $req_host =~ /\./;
      my $req_port = $url->port;
      my $req_path = _url_path($url);
      _normalize_path($req_path) if $req_path =~ /%/;
  
      if (@ns_set) {
  	# The old Netscape cookie format for Set-Cookie
  	# http://curl.haxx.se/rfc/cookie_spec.html
  	# can for instance contain an unquoted "," in the expires
  	# field, so we have to use this ad-hoc parser.
  	my $now = time();
  
  	# Build a hash of cookies that was present in Set-Cookie2
  	# headers.  We need to skip them if we also find them in a
  	# Set-Cookie header.
  	my %in_set2;
  	for (@set) {
  	    $in_set2{$_->[0]}++;
  	}
  
  	my $set;
  	for $set (@ns_set) {
              $set =~ s/^\s+//;
  	    my @cur;
  	    my $param;
  	    my $expires;
  	    my $first_param = 1;
  	    for $param (split(/;\s*/, $set)) {
                  next unless length($param);
  		my($k,$v) = split(/\s*=\s*/, $param, 2);
  		if (defined $v) {
  		    $v =~ s/\s+$//;
  		    #print "$k => $v\n";
  		}
  		else {
  		    $k =~ s/\s+$//;
  		    #print "$k => undef";
  		}
  		if (!$first_param && lc($k) eq "expires") {
  		    my $etime = str2time($v);
  		    if (defined $etime) {
  			push(@cur, "Max-Age" => $etime - $now);
  			$expires++;
  		    }
  		    else {
  			# parse_date can deal with years outside the range of time_t,
  			my($year, $mon, $day, $hour, $min, $sec, $tz) = parse_date($v);
  			if ($year) {
  			    my $thisyear = (gmtime)[5] + 1900;
  			    if ($year < $thisyear) {
  				push(@cur, "Max-Age" => -1);  # any negative value will do
  				$expires++;
  			    }
  			    elsif ($year >= $thisyear + 10) {
  				# the date is at least 10 years into the future, just replace
  				# it with something approximate
  				push(@cur, "Max-Age" => 10 * 365 * 24 * 60 * 60);
  				$expires++;
  			    }
  			}
  		    }
  		}
                  elsif (!$first_param && lc($k) =~ /^(?:version|discard|ns-cookie)/) {
                      # ignore
                  }
  		else {
  		    push(@cur, $k => $v);
  		}
  		$first_param = 0;
  	    }
              next unless @cur;
  	    next if $in_set2{$cur[0]};
  
  #	    push(@cur, "Port" => $req_port);
  	    push(@cur, "Discard" => undef) unless $expires;
  	    push(@cur, "Version" => 0);
  	    push(@cur, "ns-cookie" => 1);
  	    push(@set, \@cur);
  	}
      }
  
    SET_COOKIE:
      for my $set (@set) {
  	next unless @$set >= 2;
  
  	my $key = shift @$set;
  	my $val = shift @$set;
  
  	my %hash;
  	while (@$set) {
  	    my $k = shift @$set;
  	    my $v = shift @$set;
  	    my $lc = lc($k);
  	    # don't loose case distinction for unknown fields
  	    $k = $lc if $lc =~ /^(?:discard|domain|max-age|
                                      path|port|secure|version)$/x;
  	    if ($k eq "discard" || $k eq "secure") {
  		$v = 1 unless defined $v;
  	    }
  	    next if exists $hash{$k};  # only first value is significant
  	    $hash{$k} = $v;
  	};
  
  	my %orig_hash = %hash;
  	my $version   = delete $hash{version};
  	$version = 1 unless defined($version);
  	my $discard   = delete $hash{discard};
  	my $secure    = delete $hash{secure};
  	my $maxage    = delete $hash{'max-age'};
  	my $ns_cookie = delete $hash{'ns-cookie'};
  
  	# Check domain
  	my $domain  = delete $hash{domain};
  	$domain = lc($domain) if defined $domain;
  	if (defined($domain)
  	    && $domain ne $req_host && $domain ne ".$req_host") {
  	    if ($domain !~ /\./ && $domain ne "local") {
  		next SET_COOKIE;
  	    }
  	    $domain = ".$domain" unless $domain =~ /^\./;
  	    if ($domain =~ /\.\d+$/) {
  		next SET_COOKIE;
  	    }
  	    my $len = length($domain);
  	    unless (substr($req_host, -$len) eq $domain) {
  		next SET_COOKIE;
  	    }
  	    my $hostpre = substr($req_host, 0, length($req_host) - $len);
  	    if ($hostpre =~ /\./ && !$ns_cookie) {
  		next SET_COOKIE;
  	    }
  	}
  	else {
  	    $domain = $req_host;
  	}
  
  	my $path = delete $hash{path};
  	my $path_spec;
  	if (defined $path && $path ne '') {
  	    $path_spec++;
  	    _normalize_path($path) if $path =~ /%/;
  	    if (!$ns_cookie &&
                  substr($req_path, 0, length($path)) ne $path) {
  		next SET_COOKIE;
  	    }
  	}
  	else {
  	    $path = $req_path;
  	    $path =~ s,/[^/]*$,,;
  	    $path = "/" unless length($path);
  	}
  
  	my $port;
  	if (exists $hash{port}) {
  	    $port = delete $hash{port};
  	    if (defined $port) {
  		$port =~ s/\s+//g;
  		my $found;
  		for my $p (split(/,/, $port)) {
  		    unless ($p =~ /^\d+$/) {
  			next SET_COOKIE;
  		    }
  		    $found++ if $p eq $req_port;
  		}
  		unless ($found) {
  		    next SET_COOKIE;
  		}
  	    }
  	    else {
  		$port = "_$req_port";
  	    }
  	}
  	$self->set_cookie($version,$key,$val,$path,$domain,$port,$path_spec,$secure,$maxage,$discard, \%hash)
  	    if $self->set_cookie_ok(\%orig_hash);
      }
  
      $response;
  }
  
  sub set_cookie_ok
  {
      1;
  }
  
  
  sub set_cookie
  {
      my $self = shift;
      my($version,
         $key, $val, $path, $domain, $port,
         $path_spec, $secure, $maxage, $discard, $rest) = @_;
  
      # path and key can not be empty (key can't start with '$')
      return $self if !defined($path) || $path !~ m,^/, ||
  	            !defined($key)  || $key  =~ m,^\$,;
  
      # ensure legal port
      if (defined $port) {
  	return $self unless $port =~ /^_?\d+(?:,\d+)*$/;
      }
  
      my $expires;
      if (defined $maxage) {
  	if ($maxage <= 0) {
  	    delete $self->{COOKIES}{$domain}{$path}{$key};
  	    return $self;
  	}
  	$expires = time() + $maxage;
      }
      $version = 0 unless defined $version;
  
      my @array = ($version, $val,$port,
  		 $path_spec,
  		 $secure, $expires, $discard);
      push(@array, {%$rest}) if defined($rest) && %$rest;
      # trim off undefined values at end
      pop(@array) while !defined $array[-1];
  
      $self->{COOKIES}{$domain}{$path}{$key} = \@array;
      $self;
  }
  
  
  sub save
  {
      my $self = shift;
      my $file = shift || $self->{'file'} || return;
      local(*FILE);
      open(FILE, ">$file") or die "Can't open $file: $!";
      print FILE "#LWP-Cookies-1.0\n";
      print FILE $self->as_string(!$self->{ignore_discard});
      close(FILE);
      1;
  }
  
  
  sub load
  {
      my $self = shift;
      my $file = shift || $self->{'file'} || return;
      local(*FILE, $_);
      local $/ = "\n";  # make sure we got standard record separator
      open(FILE, $file) or return;
      my $magic = <FILE>;
      unless ($magic =~ /^\#LWP-Cookies-(\d+\.\d+)/) {
  	warn "$file does not seem to contain cookies";
  	return;
      }
      while (<FILE>) {
  	next unless s/^Set-Cookie3:\s*//;
  	chomp;
  	my $cookie;
  	for $cookie (_split_header_words($_)) {
  	    my($key,$val) = splice(@$cookie, 0, 2);
  	    my %hash;
  	    while (@$cookie) {
  		my $k = shift @$cookie;
  		my $v = shift @$cookie;
  		$hash{$k} = $v;
  	    }
  	    my $version   = delete $hash{version};
  	    my $path      = delete $hash{path};
  	    my $domain    = delete $hash{domain};
  	    my $port      = delete $hash{port};
  	    my $expires   = str2time(delete $hash{expires});
  
  	    my $path_spec = exists $hash{path_spec}; delete $hash{path_spec};
  	    my $secure    = exists $hash{secure};    delete $hash{secure};
  	    my $discard   = exists $hash{discard};   delete $hash{discard};
  
  	    my @array =	($version,$val,$port,
  			 $path_spec,$secure,$expires,$discard);
  	    push(@array, \%hash) if %hash;
  	    $self->{COOKIES}{$domain}{$path}{$key} = \@array;
  	}
      }
      close(FILE);
      1;
  }
  
  
  sub revert
  {
      my $self = shift;
      $self->clear->load;
      $self;
  }
  
  
  sub clear
  {
      my $self = shift;
      if (@_ == 0) {
  	$self->{COOKIES} = {};
      }
      elsif (@_ == 1) {
  	delete $self->{COOKIES}{$_[0]};
      }
      elsif (@_ == 2) {
  	delete $self->{COOKIES}{$_[0]}{$_[1]};
      }
      elsif (@_ == 3) {
  	delete $self->{COOKIES}{$_[0]}{$_[1]}{$_[2]};
      }
      else {
  	require Carp;
          Carp::carp('Usage: $c->clear([domain [,path [,key]]])');
      }
      $self;
  }
  
  
  sub clear_temporary_cookies
  {
      my($self) = @_;
  
      $self->scan(sub {
          if($_[9] or        # "Discard" flag set
             not $_[8]) {    # No expire field?
              $_[8] = -1;            # Set the expire/max_age field
              $self->set_cookie(@_); # Clear the cookie
          }
        });
  }
  
  
  sub DESTROY
  {
      my $self = shift;
      local($., $@, $!, $^E, $?);
      $self->save if $self->{'autosave'};
  }
  
  
  sub scan
  {
      my($self, $cb) = @_;
      my($domain,$path,$key);
      for $domain (sort keys %{$self->{COOKIES}}) {
  	for $path (sort keys %{$self->{COOKIES}{$domain}}) {
  	    for $key (sort keys %{$self->{COOKIES}{$domain}{$path}}) {
  		my($version,$val,$port,$path_spec,
  		   $secure,$expires,$discard,$rest) =
  		       @{$self->{COOKIES}{$domain}{$path}{$key}};
  		$rest = {} unless defined($rest);
  		&$cb($version,$key,$val,$path,$domain,$port,
  		     $path_spec,$secure,$expires,$discard,$rest);
  	    }
  	}
      }
  }
  
  
  sub as_string
  {
      my($self, $skip_discard) = @_;
      my @res;
      $self->scan(sub {
  	my($version,$key,$val,$path,$domain,$port,
  	   $path_spec,$secure,$expires,$discard,$rest) = @_;
  	return if $discard && $skip_discard;
  	my @h = ($key, $val);
  	push(@h, "path", $path);
  	push(@h, "domain" => $domain);
  	push(@h, "port" => $port) if defined $port;
  	push(@h, "path_spec" => undef) if $path_spec;
  	push(@h, "secure" => undef) if $secure;
  	push(@h, "expires" => HTTP::Date::time2isoz($expires)) if $expires;
  	push(@h, "discard" => undef) if $discard;
  	my $k;
  	for $k (sort keys %$rest) {
  	    push(@h, $k, $rest->{$k});
  	}
  	push(@h, "version" => $version);
  	push(@res, "Set-Cookie3: " . join_header_words(\@h));
      });
      join("\n", @res, "");
  }
  
  sub _host
  {
      my($request, $url) = @_;
      if (my $h = $request->header("Host")) {
  	$h =~ s/:\d+$//;  # might have a port as well
  	return lc($h);
      }
      return lc($url->host);
  }
  
  sub _url_path
  {
      my $url = shift;
      my $path;
      if($url->can('epath')) {
         $path = $url->epath;    # URI::URL method
      }
      else {
         $path = $url->path;           # URI::_generic method
      }
      $path = "/" unless length $path;
      $path;
  }
  
  sub _normalize_path  # so that plain string compare can be used
  {
      my $x;
      $_[0] =~ s/%([0-9a-fA-F][0-9a-fA-F])/
  	         $x = uc($1);
                   $x eq "2F" || $x eq "25" ? "%$x" :
                                              pack("C", hex($x));
                /eg;
      $_[0] =~ s/([\0-\x20\x7f-\xff])/sprintf("%%%02X",ord($1))/eg;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Cookies - HTTP cookie jars
  
  =head1 SYNOPSIS
  
    use HTTP::Cookies;
    $cookie_jar = HTTP::Cookies->new(
      file => "$ENV{'HOME'}/lwp_cookies.dat',
      autosave => 1,
    );
  
    use LWP;
    my $browser = LWP::UserAgent->new;
    $browser->cookie_jar($cookie_jar);
  
  Or for an empty and temporary cookie jar:
  
    use LWP;
    my $browser = LWP::UserAgent->new;
    $browser->cookie_jar( {} );
  
  =head1 DESCRIPTION
  
  This class is for objects that represent a "cookie jar" -- that is, a
  database of all the HTTP cookies that a given LWP::UserAgent object
  knows about.
  
  Cookies are a general mechanism which server side connections can use
  to both store and retrieve information on the client side of the
  connection.  For more information about cookies refer to
  <URL:http://curl.haxx.se/rfc/cookie_spec.html> and
  <URL:http://www.cookiecentral.com/>.  This module also implements the
  new style cookies described in I<RFC 2965>.
  The two variants of cookies are supposed to be able to coexist happily.
  
  Instances of the class I<HTTP::Cookies> are able to store a collection
  of Set-Cookie2: and Set-Cookie: headers and are able to use this
  information to initialize Cookie-headers in I<HTTP::Request> objects.
  The state of a I<HTTP::Cookies> object can be saved in and restored from
  files.
  
  =head1 METHODS
  
  The following methods are provided:
  
  =over 4
  
  =item $cookie_jar = HTTP::Cookies->new
  
  The constructor takes hash style parameters.  The following
  parameters are recognized:
  
    file:            name of the file to restore cookies from and save cookies to
    autosave:        save during destruction (bool)
    ignore_discard:  save even cookies that are requested to be discarded (bool)
    hide_cookie2:    do not add Cookie2 header to requests
  
  Future parameters might include (not yet implemented):
  
    max_cookies               300
    max_cookies_per_domain    20
    max_cookie_size           4096
  
    no_cookies   list of domain names that we never return cookies to
  
  =item $cookie_jar->add_cookie_header( $request )
  
  The add_cookie_header() method will set the appropriate Cookie:-header
  for the I<HTTP::Request> object given as argument.  The $request must
  have a valid url attribute before this method is called.
  
  =item $cookie_jar->extract_cookies( $response )
  
  The extract_cookies() method will look for Set-Cookie: and
  Set-Cookie2: headers in the I<HTTP::Response> object passed as
  argument.  Any of these headers that are found are used to update
  the state of the $cookie_jar.
  
  =item $cookie_jar->set_cookie( $version, $key, $val, $path, $domain, $port, $path_spec, $secure, $maxage, $discard, \%rest )
  
  The set_cookie() method updates the state of the $cookie_jar.  The
  $key, $val, $domain, $port and $path arguments are strings.  The
  $path_spec, $secure, $discard arguments are boolean values. The $maxage
  value is a number indicating number of seconds that this cookie will
  live.  A value <= 0 will delete this cookie.  %rest defines
  various other attributes like "Comment" and "CommentURL".
  
  =item $cookie_jar->save
  
  =item $cookie_jar->save( $file )
  
  This method file saves the state of the $cookie_jar to a file.
  The state can then be restored later using the load() method.  If a
  filename is not specified we will use the name specified during
  construction.  If the attribute I<ignore_discard> is set, then we
  will even save cookies that are marked to be discarded.
  
  The default is to save a sequence of "Set-Cookie3" lines.
  "Set-Cookie3" is a proprietary LWP format, not known to be compatible
  with any browser.  The I<HTTP::Cookies::Netscape> sub-class can
  be used to save in a format compatible with Netscape.
  
  =item $cookie_jar->load
  
  =item $cookie_jar->load( $file )
  
  This method reads the cookies from the file and adds them to the
  $cookie_jar.  The file must be in the format written by the save()
  method.
  
  =item $cookie_jar->revert
  
  This method empties the $cookie_jar and re-loads the $cookie_jar
  from the last save file.
  
  =item $cookie_jar->clear
  
  =item $cookie_jar->clear( $domain )
  
  =item $cookie_jar->clear( $domain, $path )
  
  =item $cookie_jar->clear( $domain, $path, $key )
  
  Invoking this method without arguments will empty the whole
  $cookie_jar.  If given a single argument only cookies belonging to
  that domain will be removed.  If given two arguments, cookies
  belonging to the specified path within that domain are removed.  If
  given three arguments, then the cookie with the specified key, path
  and domain is removed.
  
  =item $cookie_jar->clear_temporary_cookies
  
  Discard all temporary cookies. Scans for all cookies in the jar
  with either no expire field or a true C<discard> flag. To be
  called when the user agent shuts down according to RFC 2965.
  
  =item $cookie_jar->scan( \&callback )
  
  The argument is a subroutine that will be invoked for each cookie
  stored in the $cookie_jar.  The subroutine will be invoked with
  the following arguments:
  
    0  version
    1  key
    2  val
    3  path
    4  domain
    5  port
    6  path_spec
    7  secure
    8  expires
    9  discard
   10  hash
  
  =item $cookie_jar->as_string
  
  =item $cookie_jar->as_string( $skip_discardables )
  
  The as_string() method will return the state of the $cookie_jar
  represented as a sequence of "Set-Cookie3" header lines separated by
  "\n".  If $skip_discardables is TRUE, it will not return lines for
  cookies with the I<Discard> attribute.
  
  =back
  
  =head1 SEE ALSO
  
  L<HTTP::Cookies::Netscape>, L<HTTP::Cookies::Microsoft>
  
  =head1 COPYRIGHT
  
  Copyright 1997-2002 Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
HTTP_COOKIES

$fatpacked{"HTTP/Cookies/Microsoft.pm"} = <<'HTTP_COOKIES_MICROSOFT';
  package HTTP::Cookies::Microsoft;
  
  use strict;
  
  use vars qw(@ISA $VERSION);
  
  $VERSION = "5.821";
  
  require HTTP::Cookies;
  @ISA=qw(HTTP::Cookies);
  
  sub load_cookies_from_file
  {
  	my ($file) = @_;
  	my @cookies;
  	my ($key, $value, $domain_path, $flags, $lo_expire, $hi_expire);
  	my ($lo_create, $hi_create, $sep);
  
  	open(COOKIES, $file) || return;
  
  	while ($key = <COOKIES>)
  	{
  		chomp($key);
  		chomp($value     = <COOKIES>);
  		chomp($domain_path= <COOKIES>);
  		chomp($flags     = <COOKIES>);		# 0x0001 bit is for secure
  		chomp($lo_expire = <COOKIES>);
  		chomp($hi_expire = <COOKIES>);
  		chomp($lo_create = <COOKIES>);
  		chomp($hi_create = <COOKIES>);
  		chomp($sep       = <COOKIES>);
  
  		if (!defined($key) || !defined($value) || !defined($domain_path) ||
  			!defined($flags) || !defined($hi_expire) || !defined($lo_expire) ||
  			!defined($hi_create) || !defined($lo_create) || !defined($sep) ||
  			($sep ne '*'))
  		{
  			last;
  		}
  
  		if ($domain_path =~ /^([^\/]+)(\/.*)$/)
  		{
  			my $domain = $1;
  			my $path = $2;
  
  			push(@cookies, {KEY => $key, VALUE => $value, DOMAIN => $domain,
  					PATH => $path, FLAGS =>$flags, HIXP =>$hi_expire,
  					LOXP => $lo_expire, HICREATE => $hi_create,
  					LOCREATE => $lo_create});
  		}
  	}
  
  	return \@cookies;
  }
  
  sub get_user_name
  {
  	use Win32;
  	use locale;
  	my $user = lc(Win32::LoginName());
  
  	return $user;
  }
  
  # MSIE stores create and expire times as Win32 FILETIME,
  # which is 64 bits of 100 nanosecond intervals since Jan 01 1601
  #
  # But Cookies code expects time in 32-bit value expressed
  # in seconds since Jan 01 1970
  #
  sub epoch_time_offset_from_win32_filetime
  {
  	my ($high, $low) = @_;
  
  	#--------------------------------------------------------
  	# USEFUL CONSTANT
  	#--------------------------------------------------------
  	# 0x019db1de 0xd53e8000 is 1970 Jan 01 00:00:00 in Win32 FILETIME
  	#
  	# 100 nanosecond intervals == 0.1 microsecond intervals
  	
  	my $filetime_low32_1970 = 0xd53e8000;
  	my $filetime_high32_1970 = 0x019db1de;
  
  	#------------------------------------
  	# ALGORITHM
  	#------------------------------------
  	# To go from 100 nanosecond intervals to seconds since 00:00 Jan 01 1970:
  	#
  	# 1. Adjust 100 nanosecond intervals to Jan 01 1970 base
  	# 2. Divide by 10 to get to microseconds (1/millionth second)
  	# 3. Divide by 1000000 (10 ^ 6) to get to seconds
  	#
  	# We can combine Step 2 & 3 into one divide.
  	#
  	# After much trial and error, I came up with the following code which
  	# avoids using Math::BigInt or floating pt, but still gives correct answers
  
  	# If the filetime is before the epoch, return 0
  	if (($high < $filetime_high32_1970) ||
  	    (($high == $filetime_high32_1970) && ($low < $filetime_low32_1970)))
      	{
  		return 0;
  	}
  
  	# Can't multiply by 0x100000000, (1 << 32),
  	# without Perl issuing an integer overflow warning
  	#
  	# So use two multiplies by 0x10000 instead of one multiply by 0x100000000
  	#
  	# The result is the same.
  	#
  	my $date1970 = (($filetime_high32_1970 * 0x10000) * 0x10000) + $filetime_low32_1970;
  	my $time = (($high * 0x10000) * 0x10000) + $low;
  
  	$time -= $date1970;
  	$time /= 10000000;
  
  	return $time;
  }
  
  sub load_cookie
  {
  	my($self, $file) = @_;
          my $now = time() - $HTTP::Cookies::EPOCH_OFFSET;
  	my $cookie_data;
  
          if (-f $file)
          {
  		# open the cookie file and get the data
  		$cookie_data = load_cookies_from_file($file);
  
  		foreach my $cookie (@{$cookie_data})
  		{
  			my $secure = ($cookie->{FLAGS} & 1) != 0;
  			my $expires = epoch_time_offset_from_win32_filetime($cookie->{HIXP}, $cookie->{LOXP});
  
  			$self->set_cookie(undef, $cookie->{KEY}, $cookie->{VALUE}, 
  					  $cookie->{PATH}, $cookie->{DOMAIN}, undef,
  					  0, $secure, $expires-$now, 0);
  		}
  	}
  }
  
  sub load
  {
  	my($self, $cookie_index) = @_;
  	my $now = time() - $HTTP::Cookies::EPOCH_OFFSET;
  	my $cookie_dir = '';
  	my $delay_load = (defined($self->{'delayload'}) && $self->{'delayload'});
  	my $user_name = get_user_name();
  	my $data;
  
  	$cookie_index ||= $self->{'file'} || return;
  	if ($cookie_index =~ /[\\\/][^\\\/]+$/)
  	{
  		$cookie_dir = $` . "\\";
  	}
  
  	local(*INDEX, $_);
  
  	open(INDEX, $cookie_index) || return;
  	binmode(INDEX);
  	if (256 != read(INDEX, $data, 256))
  	{
  		warn "$cookie_index file is not large enough";
  		close(INDEX);
  		return;
  	}
  
  	# Cookies' index.dat file starts with 32 bytes of signature
  	# followed by an offset to the first record, stored as a little-endian DWORD
  	my ($sig, $size) = unpack('a32 V', $data);
  	
  	if (($sig !~ /^Client UrlCache MMF Ver 5\.2/) || # check that sig is valid (only tested in IE6.0)
  		(0x4000 != $size))
  	{
  		warn "$cookie_index ['$sig' $size] does not seem to contain cookies";
  		close(INDEX);
  		return;
  	}
  
  	if (0 == seek(INDEX, $size, 0)) # move the file ptr to start of the first record
  	{
  		close(INDEX);
  		return;
  	}
  
  	# Cookies are usually stored in 'URL ' records in two contiguous 0x80 byte sectors (256 bytes)
  	# so read in two 0x80 byte sectors and adjust if not a Cookie.
  	while (256 == read(INDEX, $data, 256))
  	{
  		# each record starts with a 4-byte signature
  		# and a count (little-endian DWORD) of 0x80 byte sectors for the record
  		($sig, $size) = unpack('a4 V', $data);
  
  		# Cookies are found in 'URL ' records
  		if ('URL ' ne $sig)
  		{
  			# skip over uninteresting record: I've seen 'HASH' and 'LEAK' records
  			if (($sig eq 'HASH') || ($sig eq 'LEAK'))
  			{
  				# '-2' takes into account the two 0x80 byte sectors we've just read in
  				if (($size > 0) && ($size != 2))
  				{
  				    if (0 == seek(INDEX, ($size-2)*0x80, 1))
  				    {
  					    # Seek failed. Something's wrong. Gonna stop.
  					    last;
  				    }
  				}
  			}
  			next;
  		}
  
  		#$REMOVE Need to check if URL records in Cookies' index.dat will
  		#        ever use more than two 0x80 byte sectors
  		if ($size > 2)
  		{
  			my $more_data = ($size-2)*0x80;
  
  			if ($more_data != read(INDEX, $data, $more_data, 256))
  			{
  				last;
  			}
  		}
  
                  (my $user_name2 = $user_name) =~ s/ /_/g;
  		if ($data =~ /Cookie\:\Q$user_name\E\@([\x21-\xFF]+).*?((?:\Q$user_name\E|\Q$user_name2\E)\@[\x21-\xFF]+\.txt)/)
  		{
  			my $cookie_file = $cookie_dir . $2; # form full pathname
  
  			if (!$delay_load)
  			{
  				$self->load_cookie($cookie_file);
  			}
  			else
  			{
  				my $domain = $1;
  
  				# grab only the domain name, drop everything from the first dir sep on
  				if ($domain =~ m{[\\/]})
  				{
  					$domain = $`;
  				}
  
  				# set the delayload cookie for this domain with 
  				# the cookie_file as cookie for later-loading info
  				$self->set_cookie(undef, 'cookie', $cookie_file,
  						      '//+delayload', $domain, undef,
  						      0, 0, $now+86400, 0);
  			}
  		}
  	}
  
  	close(INDEX);
  
  	1;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Cookies::Microsoft - access to Microsoft cookies files
  
  =head1 SYNOPSIS
  
   use LWP;
   use HTTP::Cookies::Microsoft;
   use Win32::TieRegistry(Delimiter => "/");
   my $cookies_dir = $Registry->
        {"CUser/Software/Microsoft/Windows/CurrentVersion/Explorer/Shell Folders/Cookies"};
  
   $cookie_jar = HTTP::Cookies::Microsoft->new(
                     file     => "$cookies_dir\\index.dat",
                     'delayload' => 1,
                 );
   my $browser = LWP::UserAgent->new;
   $browser->cookie_jar( $cookie_jar );
  
  =head1 DESCRIPTION
  
  This is a subclass of C<HTTP::Cookies> which
  loads Microsoft Internet Explorer 5.x and 6.x for Windows (MSIE)
  cookie files.
  
  See the documentation for L<HTTP::Cookies>.
  
  =head1 METHODS
  
  The following methods are provided:
  
  =over 4
  
  =item $cookie_jar = HTTP::Cookies::Microsoft->new;
  
  The constructor takes hash style parameters. In addition
  to the regular HTTP::Cookies parameters, HTTP::Cookies::Microsoft
  recognizes the following:
  
    delayload:       delay loading of cookie data until a request
                     is actually made. This results in faster
                     runtime unless you use most of the cookies
                     since only the domain's cookie data
                     is loaded on demand.
  
  =back
  
  =head1 CAVEATS
  
  Please note that the code DOESN'T support saving to the MSIE
  cookie file format.
  
  =head1 AUTHOR
  
  Johnny Lee <typo_pl@hotmail.com>
  
  =head1 COPYRIGHT
  
  Copyright 2002 Johnny Lee
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
HTTP_COOKIES_MICROSOFT

$fatpacked{"HTTP/Cookies/Netscape.pm"} = <<'HTTP_COOKIES_NETSCAPE';
  package HTTP::Cookies::Netscape;
  
  use strict;
  use vars qw(@ISA $VERSION);
  
  $VERSION = "5.832";
  
  require HTTP::Cookies;
  @ISA=qw(HTTP::Cookies);
  
  sub load
  {
      my($self, $file) = @_;
      $file ||= $self->{'file'} || return;
      local(*FILE, $_);
      local $/ = "\n";  # make sure we got standard record separator
      my @cookies;
      open(FILE, $file) || return;
      my $magic = <FILE>;
      unless ($magic =~ /^\#(?: Netscape)? HTTP Cookie File/) {
  	warn "$file does not look like a netscape cookies file" if $^W;
  	close(FILE);
  	return;
      }
      my $now = time() - $HTTP::Cookies::EPOCH_OFFSET;
      while (<FILE>) {
  	next if /^\s*\#/;
  	next if /^\s*$/;
  	tr/\n\r//d;
  	my($domain,$bool1,$path,$secure, $expires,$key,$val) = split(/\t/, $_);
  	$secure = ($secure eq "TRUE");
  	$self->set_cookie(undef,$key,$val,$path,$domain,undef,
  			  0,$secure,$expires-$now, 0);
      }
      close(FILE);
      1;
  }
  
  sub save
  {
      my($self, $file) = @_;
      $file ||= $self->{'file'} || return;
      local(*FILE, $_);
      open(FILE, ">$file") || return;
  
      # Use old, now broken link to the old cookie spec just in case something
      # else (not us!) requires the comment block exactly this way.
      print FILE <<EOT;
  # Netscape HTTP Cookie File
  # http://www.netscape.com/newsref/std/cookie_spec.html
  # This is a generated file!  Do not edit.
  
  EOT
  
      my $now = time - $HTTP::Cookies::EPOCH_OFFSET;
      $self->scan(sub {
  	my($version,$key,$val,$path,$domain,$port,
  	   $path_spec,$secure,$expires,$discard,$rest) = @_;
  	return if $discard && !$self->{ignore_discard};
  	$expires = $expires ? $expires - $HTTP::Cookies::EPOCH_OFFSET : 0;
  	return if $now > $expires;
  	$secure = $secure ? "TRUE" : "FALSE";
  	my $bool = $domain =~ /^\./ ? "TRUE" : "FALSE";
  	print FILE join("\t", $domain, $bool, $path, $secure, $expires, $key, $val), "\n";
      });
      close(FILE);
      1;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  HTTP::Cookies::Netscape - access to Netscape cookies files
  
  =head1 SYNOPSIS
  
   use LWP;
   use HTTP::Cookies::Netscape;
   $cookie_jar = HTTP::Cookies::Netscape->new(
     file => "c:/program files/netscape/users/ZombieCharity/cookies.txt",
   );
   my $browser = LWP::UserAgent->new;
   $browser->cookie_jar( $cookie_jar );
  
  =head1 DESCRIPTION
  
  This is a subclass of C<HTTP::Cookies> that reads (and optionally
  writes) Netscape/Mozilla cookie files.
  
  See the documentation for L<HTTP::Cookies>.
  
  =head1 CAVEATS
  
  Please note that the Netscape/Mozilla cookie file format can't store
  all the information available in the Set-Cookie2 headers, so you will
  probably lose some information if you save in this format.
  
  At time of writing, this module seems to work fine with Mozilla      
  Phoenix/Firebird.
  
  =head1 SEE ALSO
  
  L<HTTP::Cookies::Microsoft>
  
  =head1 COPYRIGHT
  
  Copyright 2002-2003 Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
HTTP_COOKIES_NETSCAPE

$fatpacked{"HTTP/Daemon.pm"} = <<'HTTP_DAEMON';
  package HTTP::Daemon;
  
  use strict;
  use vars qw($VERSION @ISA $PROTO $DEBUG);
  
  $VERSION = "5.827";
  
  use IO::Socket qw(AF_INET INADDR_ANY inet_ntoa);
  @ISA=qw(IO::Socket::INET);
  
  $PROTO = "HTTP/1.1";
  
  
  sub new
  {
      my($class, %args) = @_;
      $args{Listen} ||= 5;
      $args{Proto}  ||= 'tcp';
      return $class->SUPER::new(%args);
  }
  
  
  sub accept
  {
      my $self = shift;
      my $pkg = shift || "HTTP::Daemon::ClientConn";
      my ($sock, $peer) = $self->SUPER::accept($pkg);
      if ($sock) {
          ${*$sock}{'httpd_daemon'} = $self;
          return wantarray ? ($sock, $peer) : $sock;
      }
      else {
          return;
      }
  }
  
  
  sub url
  {
      my $self = shift;
      my $url = $self->_default_scheme . "://";
      my $addr = $self->sockaddr;
      if (!$addr || $addr eq INADDR_ANY) {
   	require Sys::Hostname;
   	$url .= lc Sys::Hostname::hostname();
      }
      else {
  	$url .= gethostbyaddr($addr, AF_INET) || inet_ntoa($addr);
      }
      my $port = $self->sockport;
      $url .= ":$port" if $port != $self->_default_port;
      $url .= "/";
      $url;
  }
  
  
  sub _default_port {
      80;
  }
  
  
  sub _default_scheme {
      "http";
  }
  
  
  sub product_tokens
  {
      "libwww-perl-daemon/$HTTP::Daemon::VERSION";
  }
  
  
  
  package HTTP::Daemon::ClientConn;
  
  use vars qw(@ISA $DEBUG);
  use IO::Socket ();
  @ISA=qw(IO::Socket::INET);
  *DEBUG = \$HTTP::Daemon::DEBUG;
  
  use HTTP::Request  ();
  use HTTP::Response ();
  use HTTP::Status;
  use HTTP::Date qw(time2str);
  use LWP::MediaTypes qw(guess_media_type);
  use Carp ();
  
  my $CRLF = "\015\012";   # "\r\n" is not portable
  my $HTTP_1_0 = _http_version("HTTP/1.0");
  my $HTTP_1_1 = _http_version("HTTP/1.1");
  
  
  sub get_request
  {
      my($self, $only_headers) = @_;
      if (${*$self}{'httpd_nomore'}) {
          $self->reason("No more requests from this connection");
  	return;
      }
  
      $self->reason("");
      my $buf = ${*$self}{'httpd_rbuf'};
      $buf = "" unless defined $buf;
  
      my $timeout = $ {*$self}{'io_socket_timeout'};
      my $fdset = "";
      vec($fdset, $self->fileno, 1) = 1;
      local($_);
  
    READ_HEADER:
      while (1) {
  	# loop until we have the whole header in $buf
  	$buf =~ s/^(?:\015?\012)+//;  # ignore leading blank lines
  	if ($buf =~ /\012/) {  # potential, has at least one line
  	    if ($buf =~ /^\w+[^\012]+HTTP\/\d+\.\d+\015?\012/) {
  		if ($buf =~ /\015?\012\015?\012/) {
  		    last READ_HEADER;  # we have it
  		}
  		elsif (length($buf) > 16*1024) {
  		    $self->send_error(413); # REQUEST_ENTITY_TOO_LARGE
  		    $self->reason("Very long header");
  		    return;
  		}
  	    }
  	    else {
  		last READ_HEADER;  # HTTP/0.9 client
  	    }
  	}
  	elsif (length($buf) > 16*1024) {
  	    $self->send_error(414); # REQUEST_URI_TOO_LARGE
  	    $self->reason("Very long first line");
  	    return;
  	}
  	print STDERR "Need more data for complete header\n" if $DEBUG;
  	return unless $self->_need_more($buf, $timeout, $fdset);
      }
      if ($buf !~ s/^(\S+)[ \t]+(\S+)(?:[ \t]+(HTTP\/\d+\.\d+))?[^\012]*\012//) {
  	${*$self}{'httpd_client_proto'} = _http_version("HTTP/1.0");
  	$self->send_error(400);  # BAD_REQUEST
  	$self->reason("Bad request line: $buf");
  	return;
      }
      my $method = $1;
      my $uri = $2;
      my $proto = $3 || "HTTP/0.9";
      $uri = "http://$uri" if $method eq "CONNECT";
      $uri = $HTTP::URI_CLASS->new($uri, $self->daemon->url);
      my $r = HTTP::Request->new($method, $uri);
      $r->protocol($proto);
      ${*$self}{'httpd_client_proto'} = $proto = _http_version($proto);
      ${*$self}{'httpd_head'} = ($method eq "HEAD");
  
      if ($proto >= $HTTP_1_0) {
  	# we expect to find some headers
  	my($key, $val);
        HEADER:
  	while ($buf =~ s/^([^\012]*)\012//) {
  	    $_ = $1;
  	    s/\015$//;
  	    if (/^([^:\s]+)\s*:\s*(.*)/) {
  		$r->push_header($key, $val) if $key;
  		($key, $val) = ($1, $2);
  	    }
  	    elsif (/^\s+(.*)/) {
  		$val .= " $1";
  	    }
  	    else {
  		last HEADER;
  	    }
  	}
  	$r->push_header($key, $val) if $key;
      }
  
      my $conn = $r->header('Connection');
      if ($proto >= $HTTP_1_1) {
  	${*$self}{'httpd_nomore'}++ if $conn && lc($conn) =~ /\bclose\b/;
      }
      else {
  	${*$self}{'httpd_nomore'}++ unless $conn &&
                                             lc($conn) =~ /\bkeep-alive\b/;
      }
  
      if ($only_headers) {
  	${*$self}{'httpd_rbuf'} = $buf;
          return $r;
      }
  
      # Find out how much content to read
      my $te  = $r->header('Transfer-Encoding');
      my $ct  = $r->header('Content-Type');
      my $len = $r->header('Content-Length');
  
      # Act on the Expect header, if it's there
      for my $e ( $r->header('Expect') ) {
          if( lc($e) eq '100-continue' ) {
              $self->send_status_line(100);
              $self->send_crlf;
          }
          else {
              $self->send_error(417);
              $self->reason("Unsupported Expect header value");
              return;
          }
      }
  
      if ($te && lc($te) eq 'chunked') {
  	# Handle chunked transfer encoding
  	my $body = "";
        CHUNK:
  	while (1) {
  	    print STDERR "Chunked\n" if $DEBUG;
  	    if ($buf =~ s/^([^\012]*)\012//) {
  		my $chunk_head = $1;
  		unless ($chunk_head =~ /^([0-9A-Fa-f]+)/) {
  		    $self->send_error(400);
  		    $self->reason("Bad chunk header $chunk_head");
  		    return;
  		}
  		my $size = hex($1);
  		last CHUNK if $size == 0;
  
  		my $missing = $size - length($buf) + 2; # 2=CRLF at chunk end
  		# must read until we have a complete chunk
  		while ($missing > 0) {
  		    print STDERR "Need $missing more bytes\n" if $DEBUG;
  		    my $n = $self->_need_more($buf, $timeout, $fdset);
  		    return unless $n;
  		    $missing -= $n;
  		}
  		$body .= substr($buf, 0, $size);
  		substr($buf, 0, $size+2) = '';
  
  	    }
  	    else {
  		# need more data in order to have a complete chunk header
  		return unless $self->_need_more($buf, $timeout, $fdset);
  	    }
  	}
  	$r->content($body);
  
  	# pretend it was a normal entity body
  	$r->remove_header('Transfer-Encoding');
  	$r->header('Content-Length', length($body));
  
  	my($key, $val);
        FOOTER:
  	while (1) {
  	    if ($buf !~ /\012/) {
  		# need at least one line to look at
  		return unless $self->_need_more($buf, $timeout, $fdset);
  	    }
  	    else {
  		$buf =~ s/^([^\012]*)\012//;
  		$_ = $1;
  		s/\015$//;
  		if (/^([\w\-]+)\s*:\s*(.*)/) {
  		    $r->push_header($key, $val) if $key;
  		    ($key, $val) = ($1, $2);
  		}
  		elsif (/^\s+(.*)/) {
  		    $val .= " $1";
  		}
  		elsif (!length) {
  		    last FOOTER;
  		}
  		else {
  		    $self->reason("Bad footer syntax");
  		    return;
  		}
  	    }
  	}
  	$r->push_header($key, $val) if $key;
  
      }
      elsif ($te) {
  	$self->send_error(501); 	# Unknown transfer encoding
  	$self->reason("Unknown transfer encoding '$te'");
  	return;
  
      }
      elsif ($len) {
  	# Plain body specified by "Content-Length"
  	my $missing = $len - length($buf);
  	while ($missing > 0) {
  	    print "Need $missing more bytes of content\n" if $DEBUG;
  	    my $n = $self->_need_more($buf, $timeout, $fdset);
  	    return unless $n;
  	    $missing -= $n;
  	}
  	if (length($buf) > $len) {
  	    $r->content(substr($buf,0,$len));
  	    substr($buf, 0, $len) = '';
  	}
  	else {
  	    $r->content($buf);
  	    $buf='';
  	}
      }
      elsif ($ct && $ct =~ m/^multipart\/\w+\s*;.*boundary\s*=\s*("?)(\w+)\1/i) {
  	# Handle multipart content type
  	my $boundary = "$CRLF--$2--";
  	my $index;
  	while (1) {
  	    $index = index($buf, $boundary);
  	    last if $index >= 0;
  	    # end marker not yet found
  	    return unless $self->_need_more($buf, $timeout, $fdset);
  	}
  	$index += length($boundary);
  	$r->content(substr($buf, 0, $index));
  	substr($buf, 0, $index) = '';
  
      }
      ${*$self}{'httpd_rbuf'} = $buf;
  
      $r;
  }
  
  
  sub _need_more
  {
      my $self = shift;
      #my($buf,$timeout,$fdset) = @_;
      if ($_[1]) {
  	my($timeout, $fdset) = @_[1,2];
  	print STDERR "select(,,,$timeout)\n" if $DEBUG;
  	my $n = select($fdset,undef,undef,$timeout);
  	unless ($n) {
  	    $self->reason(defined($n) ? "Timeout" : "select: $!");
  	    return;
  	}
      }
      print STDERR "sysread()\n" if $DEBUG;
      my $n = sysread($self, $_[0], 2048, length($_[0]));
      $self->reason(defined($n) ? "Client closed" : "sysread: $!") unless $n;
      $n;
  }
  
  
  sub read_buffer
  {
      my $self = shift;
      my $old = ${*$self}{'httpd_rbuf'};
      if (@_) {
  	${*$self}{'httpd_rbuf'} = shift;
      }
      $old;
  }
  
  
  sub reason
  {
      my $self = shift;
      my $old = ${*$self}{'httpd_reason'};
      if (@_) {
          ${*$self}{'httpd_reason'} = shift;
      }
      $old;
  }
  
  
  sub proto_ge
  {
      my $self = shift;
      ${*$self}{'httpd_client_proto'} >= _http_version(shift);
  }
  
  
  sub _http_version
  {
      local($_) = shift;
      return 0 unless m,^(?:HTTP/)?(\d+)\.(\d+)$,i;
      $1 * 1000 + $2;
  }
  
  
  sub antique_client
  {
      my $self = shift;
      ${*$self}{'httpd_client_proto'} < $HTTP_1_0;
  }
  
  
  sub force_last_request
  {
      my $self = shift;
      ${*$self}{'httpd_nomore'}++;
  }
  
  sub head_request
  {
      my $self = shift;
      ${*$self}{'httpd_head'};
  }
  
  
  sub send_status_line
  {
      my($self, $status, $message, $proto) = @_;
      return if $self->antique_client;
      $status  ||= RC_OK;
      $message ||= status_message($status) || "";
      $proto   ||= $HTTP::Daemon::PROTO || "HTTP/1.1";
      print $self "$proto $status $message$CRLF";
  }
  
  
  sub send_crlf
  {
      my $self = shift;
      print $self $CRLF;
  }
  
  
  sub send_basic_header
  {
      my $self = shift;
      return if $self->antique_client;
      $self->send_status_line(@_);
      print $self "Date: ", time2str(time), $CRLF;
      my $product = $self->daemon->product_tokens;
      print $self "Server: $product$CRLF" if $product;
  }
  
  
  sub send_header
  {
      my $self = shift;
      while (@_) {
  	my($k, $v) = splice(@_, 0, 2);
  	$v = "" unless defined($v);
  	print $self "$k: $v$CRLF";
      }
  }
  
  
  sub send_response
  {
      my $self = shift;
      my $res = shift;
      if (!ref $res) {
  	$res ||= RC_OK;
  	$res = HTTP::Response->new($res, @_);
      }
      my $content = $res->content;
      my $chunked;
      unless ($self->antique_client) {
  	my $code = $res->code;
  	$self->send_basic_header($code, $res->message, $res->protocol);
  	if ($code =~ /^(1\d\d|[23]04)$/) {
  	    # make sure content is empty
  	    $res->remove_header("Content-Length");
  	    $content = "";
  	}
  	elsif ($res->request && $res->request->method eq "HEAD") {
  	    # probably OK
  	}
  	elsif (ref($content) eq "CODE") {
  	    if ($self->proto_ge("HTTP/1.1")) {
  		$res->push_header("Transfer-Encoding" => "chunked");
  		$chunked++;
  	    }
  	    else {
  		$self->force_last_request;
  	    }
  	}
  	elsif (length($content)) {
  	    $res->header("Content-Length" => length($content));
  	}
  	else {
  	    $self->force_last_request;
              $res->header('connection','close'); 
  	}
  	print $self $res->headers_as_string($CRLF);
  	print $self $CRLF;  # separates headers and content
      }
      if ($self->head_request) {
  	# no content
      }
      elsif (ref($content) eq "CODE") {
  	while (1) {
  	    my $chunk = &$content();
  	    last unless defined($chunk) && length($chunk);
  	    if ($chunked) {
  		printf $self "%x%s%s%s", length($chunk), $CRLF, $chunk, $CRLF;
  	    }
  	    else {
  		print $self $chunk;
  	    }
  	}
  	print $self "0$CRLF$CRLF" if $chunked;  # no trailers either
      }
      elsif (length $content) {
  	print $self $content;
      }
  }
  
  
  sub send_redirect
  {
      my($self, $loc, $status, $content) = @_;
      $status ||= RC_MOVED_PERMANENTLY;
      Carp::croak("Status '$status' is not redirect") unless is_redirect($status);
      $self->send_basic_header($status);
      my $base = $self->daemon->url;
      $loc = $HTTP::URI_CLASS->new($loc, $base) unless ref($loc);
      $loc = $loc->abs($base);
      print $self "Location: $loc$CRLF";
      if ($content) {
  	my $ct = $content =~ /^\s*</ ? "text/html" : "text/plain";
  	print $self "Content-Type: $ct$CRLF";
      }
      print $self $CRLF;
      print $self $content if $content && !$self->head_request;
      $self->force_last_request;  # no use keeping the connection open
  }
  
  
  sub send_error
  {
      my($self, $status, $error) = @_;
      $status ||= RC_BAD_REQUEST;
      Carp::croak("Status '$status' is not an error") unless is_error($status);
      my $mess = status_message($status);
      $error  ||= "";
      $mess = <<EOT;
  <title>$status $mess</title>
  <h1>$status $mess</h1>
  $error
  EOT
      unless ($self->antique_client) {
          $self->send_basic_header($status);
          print $self "Content-Type: text/html$CRLF";
  	print $self "Content-Length: " . length($mess) . $CRLF;
          print $self $CRLF;
      }
      print $self $mess unless $self->head_request;
      $status;
  }
  
  
  sub send_file_response
  {
      my($self, $file) = @_;
      if (-d $file) {
  	$self->send_dir($file);
      }
      elsif (-f _) {
  	# plain file
  	local(*F);
  	sysopen(F, $file, 0) or 
  	  return $self->send_error(RC_FORBIDDEN);
  	binmode(F);
  	my($ct,$ce) = guess_media_type($file);
  	my($size,$mtime) = (stat _)[7,9];
  	unless ($self->antique_client) {
  	    $self->send_basic_header;
  	    print $self "Content-Type: $ct$CRLF";
  	    print $self "Content-Encoding: $ce$CRLF" if $ce;
  	    print $self "Content-Length: $size$CRLF" if $size;
  	    print $self "Last-Modified: ", time2str($mtime), "$CRLF" if $mtime;
  	    print $self $CRLF;
  	}
  	$self->send_file(\*F) unless $self->head_request;
  	return RC_OK;
      }
      else {
  	$self->send_error(RC_NOT_FOUND);
      }
  }
  
  
  sub send_dir
  {
      my($self, $dir) = @_;
      $self->send_error(RC_NOT_FOUND) unless -d $dir;
      $self->send_error(RC_NOT_IMPLEMENTED);
  }
  
  
  sub send_file
  {
      my($self, $file) = @_;
      my $opened = 0;
      local(*FILE);
      if (!ref($file)) {
  	open(FILE, $file) || return undef;
  	binmode(FILE);
  	$file = \*FILE;
  	$opened++;
      }
      my $cnt = 0;
      my $buf = "";
      my $n;
      while ($n = sysread($file, $buf, 8*1024)) {
  	last if !$n;
  	$cnt += $n;
  	print $self $buf;
      }
      close($file) if $opened;
      $cnt;
  }
  
  
  sub daemon
  {
      my $self = shift;
      ${*$self}{'httpd_daemon'};
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Daemon - a simple http server class
  
  =head1 SYNOPSIS
  
    use HTTP::Daemon;
    use HTTP::Status;
  
    my $d = HTTP::Daemon->new || die;
    print "Please contact me at: <URL:", $d->url, ">\n";
    while (my $c = $d->accept) {
        while (my $r = $c->get_request) {
  	  if ($r->method eq 'GET' and $r->uri->path eq "/xyzzy") {
                # remember, this is *not* recommended practice :-)
  	      $c->send_file_response("/etc/passwd");
  	  }
  	  else {
  	      $c->send_error(RC_FORBIDDEN)
  	  }
        }
        $c->close;
        undef($c);
    }
  
  =head1 DESCRIPTION
  
  Instances of the C<HTTP::Daemon> class are HTTP/1.1 servers that
  listen on a socket for incoming requests. The C<HTTP::Daemon> is a
  subclass of C<IO::Socket::INET>, so you can perform socket operations
  directly on it too.
  
  The accept() method will return when a connection from a client is
  available.  The returned value will be an C<HTTP::Daemon::ClientConn>
  object which is another C<IO::Socket::INET> subclass.  Calling the
  get_request() method on this object will read data from the client and
  return an C<HTTP::Request> object.  The ClientConn object also provide
  methods to send back various responses.
  
  This HTTP daemon does not fork(2) for you.  Your application, i.e. the
  user of the C<HTTP::Daemon> is responsible for forking if that is
  desirable.  Also note that the user is responsible for generating
  responses that conform to the HTTP/1.1 protocol.
  
  The following methods of C<HTTP::Daemon> are new (or enhanced) relative
  to the C<IO::Socket::INET> base class:
  
  =over 4
  
  =item $d = HTTP::Daemon->new
  
  =item $d = HTTP::Daemon->new( %opts )
  
  The constructor method takes the same arguments as the
  C<IO::Socket::INET> constructor, but unlike its base class it can also
  be called without any arguments.  The daemon will then set up a listen
  queue of 5 connections and allocate some random port number.
  
  A server that wants to bind to some specific address on the standard
  HTTP port will be constructed like this:
  
    $d = HTTP::Daemon->new(
             LocalAddr => 'www.thisplace.com',
             LocalPort => 80,
         );
  
  See L<IO::Socket::INET> for a description of other arguments that can
  be used configure the daemon during construction.
  
  =item $c = $d->accept
  
  =item $c = $d->accept( $pkg )
  
  =item ($c, $peer_addr) = $d->accept
  
  This method works the same the one provided by the base class, but it
  returns an C<HTTP::Daemon::ClientConn> reference by default.  If a
  package name is provided as argument, then the returned object will be
  blessed into the given class.  It is probably a good idea to make that
  class a subclass of C<HTTP::Daemon::ClientConn>.
  
  The accept method will return C<undef> if timeouts have been enabled
  and no connection is made within the given time.  The timeout() method
  is described in L<IO::Socket>.
  
  In list context both the client object and the peer address will be
  returned; see the description of the accept method L<IO::Socket> for
  details.
  
  =item $d->url
  
  Returns a URL string that can be used to access the server root.
  
  =item $d->product_tokens
  
  Returns the name that this server will use to identify itself.  This
  is the string that is sent with the C<Server> response header.  The
  main reason to have this method is that subclasses can override it if
  they want to use another product name.
  
  The default is the string "libwww-perl-daemon/#.##" where "#.##" is
  replaced with the version number of this module.
  
  =back
  
  The C<HTTP::Daemon::ClientConn> is a C<IO::Socket::INET>
  subclass. Instances of this class are returned by the accept() method
  of C<HTTP::Daemon>.  The following methods are provided:
  
  =over 4
  
  =item $c->get_request
  
  =item $c->get_request( $headers_only )
  
  This method reads data from the client and turns it into an
  C<HTTP::Request> object which is returned.  It returns C<undef>
  if reading fails.  If it fails, then the C<HTTP::Daemon::ClientConn>
  object ($c) should be discarded, and you should not try call this
  method again on it.  The $c->reason method might give you some
  information about why $c->get_request failed.
  
  The get_request() method will normally not return until the whole
  request has been received from the client.  This might not be what you
  want if the request is an upload of a large file (and with chunked
  transfer encoding HTTP can even support infinite request messages -
  uploading live audio for instance).  If you pass a TRUE value as the
  $headers_only argument, then get_request() will return immediately
  after parsing the request headers and you are responsible for reading
  the rest of the request content.  If you are going to call
  $c->get_request again on the same connection you better read the
  correct number of bytes.
  
  =item $c->read_buffer
  
  =item $c->read_buffer( $new_value )
  
  Bytes read by $c->get_request, but not used are placed in the I<read
  buffer>.  The next time $c->get_request is called it will consume the
  bytes in this buffer before reading more data from the network
  connection itself.  The read buffer is invalid after $c->get_request
  has failed.
  
  If you handle the reading of the request content yourself you need to
  empty this buffer before you read more and you need to place
  unconsumed bytes here.  You also need this buffer if you implement
  services like I<101 Switching Protocols>.
  
  This method always returns the old buffer content and can optionally
  replace the buffer content if you pass it an argument.
  
  =item $c->reason
  
  When $c->get_request returns C<undef> you can obtain a short string
  describing why it happened by calling $c->reason.
  
  =item $c->proto_ge( $proto )
  
  Return TRUE if the client announced a protocol with version number
  greater or equal to the given argument.  The $proto argument can be a
  string like "HTTP/1.1" or just "1.1".
  
  =item $c->antique_client
  
  Return TRUE if the client speaks the HTTP/0.9 protocol.  No status
  code and no headers should be returned to such a client.  This should
  be the same as !$c->proto_ge("HTTP/1.0").
  
  =item $c->head_request
  
  Return TRUE if the last request was a C<HEAD> request.  No content
  body must be generated for these requests.
  
  =item $c->force_last_request
  
  Make sure that $c->get_request will not try to read more requests off
  this connection.  If you generate a response that is not self
  delimiting, then you should signal this fact by calling this method.
  
  This attribute is turned on automatically if the client announces
  protocol HTTP/1.0 or worse and does not include a "Connection:
  Keep-Alive" header.  It is also turned on automatically when HTTP/1.1
  or better clients send the "Connection: close" request header.
  
  =item $c->send_status_line
  
  =item $c->send_status_line( $code )
  
  =item $c->send_status_line( $code, $mess )
  
  =item $c->send_status_line( $code, $mess, $proto )
  
  Send the status line back to the client.  If $code is omitted 200 is
  assumed.  If $mess is omitted, then a message corresponding to $code
  is inserted.  If $proto is missing the content of the
  $HTTP::Daemon::PROTO variable is used.
  
  =item $c->send_crlf
  
  Send the CRLF sequence to the client.
  
  =item $c->send_basic_header
  
  =item $c->send_basic_header( $code )
  
  =item $c->send_basic_header( $code, $mess )
  
  =item $c->send_basic_header( $code, $mess, $proto )
  
  Send the status line and the "Date:" and "Server:" headers back to
  the client.  This header is assumed to be continued and does not end
  with an empty CRLF line.
  
  See the description of send_status_line() for the description of the
  accepted arguments.
  
  =item $c->send_header( $field, $value )
  
  =item $c->send_header( $field1, $value1, $field2, $value2, ... )
  
  Send one or more header lines.
  
  =item $c->send_response( $res )
  
  Write a C<HTTP::Response> object to the
  client as a response.  We try hard to make sure that the response is
  self delimiting so that the connection can stay persistent for further
  request/response exchanges.
  
  The content attribute of the C<HTTP::Response> object can be a normal
  string or a subroutine reference.  If it is a subroutine, then
  whatever this callback routine returns is written back to the
  client as the response content.  The routine will be called until it
  return an undefined or empty value.  If the client is HTTP/1.1 aware
  then we will use chunked transfer encoding for the response.
  
  =item $c->send_redirect( $loc )
  
  =item $c->send_redirect( $loc, $code )
  
  =item $c->send_redirect( $loc, $code, $entity_body )
  
  Send a redirect response back to the client.  The location ($loc) can
  be an absolute or relative URL. The $code must be one the redirect
  status codes, and defaults to "301 Moved Permanently"
  
  =item $c->send_error
  
  =item $c->send_error( $code )
  
  =item $c->send_error( $code, $error_message )
  
  Send an error response back to the client.  If the $code is missing a
  "Bad Request" error is reported.  The $error_message is a string that
  is incorporated in the body of the HTML entity body.
  
  =item $c->send_file_response( $filename )
  
  Send back a response with the specified $filename as content.  If the
  file is a directory we try to generate an HTML index of it.
  
  =item $c->send_file( $filename )
  
  =item $c->send_file( $fd )
  
  Copy the file to the client.  The file can be a string (which
  will be interpreted as a filename) or a reference to an C<IO::Handle>
  or glob.
  
  =item $c->daemon
  
  Return a reference to the corresponding C<HTTP::Daemon> object.
  
  =back
  
  =head1 SEE ALSO
  
  RFC 2616
  
  L<IO::Socket::INET>, L<IO::Socket>
  
  =head1 COPYRIGHT
  
  Copyright 1996-2003, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
HTTP_DAEMON

$fatpacked{"HTTP/Date.pm"} = <<'HTTP_DATE';
  package HTTP::Date;
  
  $VERSION = "5.831";
  
  require 5.004;
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT = qw(time2str str2time);
  @EXPORT_OK = qw(parse_date time2iso time2isoz);
  
  use strict;
  require Time::Local;
  
  use vars qw(@DoW @MoY %MoY);
  @DoW = qw(Sun Mon Tue Wed Thu Fri Sat);
  @MoY = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);
  @MoY{@MoY} = (1..12);
  
  my %GMT_ZONE = (GMT => 1, UTC => 1, UT => 1, Z => 1);
  
  
  sub time2str (;$)
  {
      my $time = shift;
      $time = time unless defined $time;
      my ($sec, $min, $hour, $mday, $mon, $year, $wday) = gmtime($time);
      sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT",
  	    $DoW[$wday],
  	    $mday, $MoY[$mon], $year+1900,
  	    $hour, $min, $sec);
  }
  
  
  sub str2time ($;$)
  {
      my $str = shift;
      return undef unless defined $str;
  
      # fast exit for strictly conforming string
      if ($str =~ /^[SMTWF][a-z][a-z], (\d\d) ([JFMAJSOND][a-z][a-z]) (\d\d\d\d) (\d\d):(\d\d):(\d\d) GMT$/) {
  	return eval {
  	    my $t = Time::Local::timegm($6, $5, $4, $1, $MoY{$2}-1, $3);
  	    $t < 0 ? undef : $t;
  	};
      }
  
      my @d = parse_date($str);
      return undef unless @d;
      $d[1]--;        # month
  
      my $tz = pop(@d);
      unless (defined $tz) {
  	unless (defined($tz = shift)) {
  	    return eval { my $frac = $d[-1]; $frac -= ($d[-1] = int($frac));
  			  my $t = Time::Local::timelocal(reverse @d) + $frac;
  			  $t < 0 ? undef : $t;
  		        };
  	}
      }
  
      my $offset = 0;
      if ($GMT_ZONE{uc $tz}) {
  	# offset already zero
      }
      elsif ($tz =~ /^([-+])?(\d\d?):?(\d\d)?$/) {
  	$offset = 3600 * $2;
  	$offset += 60 * $3 if $3;
  	$offset *= -1 if $1 && $1 eq '-';
      }
      else {
  	eval { require Time::Zone } || return undef;
  	$offset = Time::Zone::tz_offset($tz);
  	return undef unless defined $offset;
      }
  
      return eval { my $frac = $d[-1]; $frac -= ($d[-1] = int($frac));
  		  my $t = Time::Local::timegm(reverse @d) + $frac;
  		  $t < 0 ? undef : $t - $offset;
  		};
  }
  
  
  sub parse_date ($)
  {
      local($_) = shift;
      return unless defined;
  
      # More lax parsing below
      s/^\s+//;  # kill leading space
      s/^(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)[a-z]*,?\s*//i; # Useless weekday
  
      my($day, $mon, $yr, $hr, $min, $sec, $tz, $ampm);
  
      # Then we are able to check for most of the formats with this regexp
      (($day,$mon,$yr,$hr,$min,$sec,$tz) =
          /^
  	 (\d\d?)               # day
  	    (?:\s+|[-\/])
  	 (\w+)                 # month
  	    (?:\s+|[-\/])
  	 (\d+)                 # year
  	 (?:
  	       (?:\s+|:)       # separator before clock
  	    (\d\d?):(\d\d)     # hour:min
  	    (?::(\d\d))?       # optional seconds
  	 )?                    # optional clock
  	    \s*
  	 ([-+]?\d{2,4}|(?![APap][Mm]\b)[A-Za-z]+)? # timezone
  	    \s*
  	 (?:\(\w+\))?	       # ASCII representation of timezone in parens.
  	    \s*$
  	/x)
  
      ||
  
      # Try the ctime and asctime format
      (($mon, $day, $hr, $min, $sec, $tz, $yr) =
  	/^
  	 (\w{1,3})             # month
  	    \s+
  	 (\d\d?)               # day
  	    \s+
  	 (\d\d?):(\d\d)        # hour:min
  	 (?::(\d\d))?          # optional seconds
  	    \s+
  	 (?:([A-Za-z]+)\s+)?   # optional timezone
  	 (\d+)                 # year
  	    \s*$               # allow trailing whitespace
  	/x)
  
      ||
  
      # Then the Unix 'ls -l' date format
      (($mon, $day, $yr, $hr, $min, $sec) =
  	/^
  	 (\w{3})               # month
  	    \s+
  	 (\d\d?)               # day
  	    \s+
  	 (?:
  	    (\d\d\d\d) |       # year
  	    (\d{1,2}):(\d{2})  # hour:min
              (?::(\d\d))?       # optional seconds
  	 )
  	 \s*$
         /x)
  
      ||
  
      # ISO 8601 format '1996-02-29 12:00:00 -0100' and variants
      (($yr, $mon, $day, $hr, $min, $sec, $tz) =
  	/^
  	  (\d{4})              # year
  	     [-\/]?
  	  (\d\d?)              # numerical month
  	     [-\/]?
  	  (\d\d?)              # day
  	 (?:
  	       (?:\s+|[-:Tt])  # separator before clock
  	    (\d\d?):?(\d\d)    # hour:min
  	    (?::?(\d\d(?:\.\d*)?))?  # optional seconds (and fractional)
  	 )?                    # optional clock
  	    \s*
  	 ([-+]?\d\d?:?(:?\d\d)?
  	  |Z|z)?               # timezone  (Z is "zero meridian", i.e. GMT)
  	    \s*$
  	/x)
  
      ||
  
      # Windows 'dir' 11-12-96  03:52PM
      (($mon, $day, $yr, $hr, $min, $ampm) =
          /^
            (\d{2})                # numerical month
               -
            (\d{2})                # day
               -
            (\d{2})                # year
               \s+
            (\d\d?):(\d\d)([APap][Mm])  # hour:min AM or PM
               \s*$
          /x)
  
      ||
      return;  # unrecognized format
  
      # Translate month name to number
      $mon = $MoY{$mon} ||
             $MoY{"\u\L$mon"} ||
  	   ($mon =~ /^\d\d?$/ && $mon >= 1 && $mon <= 12 && int($mon)) ||
             return;
  
      # If the year is missing, we assume first date before the current,
      # because of the formats we support such dates are mostly present
      # on "ls -l" listings.
      unless (defined $yr) {
  	my $cur_mon;
  	($cur_mon, $yr) = (localtime)[4, 5];
  	$yr += 1900;
  	$cur_mon++;
  	$yr-- if $mon > $cur_mon;
      }
      elsif (length($yr) < 3) {
  	# Find "obvious" year
  	my $cur_yr = (localtime)[5] + 1900;
  	my $m = $cur_yr % 100;
  	my $tmp = $yr;
  	$yr += $cur_yr - $m;
  	$m -= $tmp;
  	$yr += ($m > 0) ? 100 : -100
  	    if abs($m) > 50;
      }
  
      # Make sure clock elements are defined
      $hr  = 0 unless defined($hr);
      $min = 0 unless defined($min);
      $sec = 0 unless defined($sec);
  
      # Compensate for AM/PM
      if ($ampm) {
  	$ampm = uc $ampm;
  	$hr = 0 if $hr == 12 && $ampm eq 'AM';
  	$hr += 12 if $ampm eq 'PM' && $hr != 12;
      }
  
      return($yr, $mon, $day, $hr, $min, $sec, $tz)
  	if wantarray;
  
      if (defined $tz) {
  	$tz = "Z" if $tz =~ /^(GMT|UTC?|[-+]?0+)$/;
      }
      else {
  	$tz = "";
      }
      return sprintf("%04d-%02d-%02d %02d:%02d:%02d%s",
  		   $yr, $mon, $day, $hr, $min, $sec, $tz);
  }
  
  
  sub time2iso (;$)
  {
      my $time = shift;
      $time = time unless defined $time;
      my($sec,$min,$hour,$mday,$mon,$year) = localtime($time);
      sprintf("%04d-%02d-%02d %02d:%02d:%02d",
  	    $year+1900, $mon+1, $mday, $hour, $min, $sec);
  }
  
  
  sub time2isoz (;$)
  {
      my $time = shift;
      $time = time unless defined $time;
      my($sec,$min,$hour,$mday,$mon,$year) = gmtime($time);
      sprintf("%04d-%02d-%02d %02d:%02d:%02dZ",
              $year+1900, $mon+1, $mday, $hour, $min, $sec);
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  HTTP::Date - date conversion routines
  
  =head1 SYNOPSIS
  
   use HTTP::Date;
  
   $string = time2str($time);    # Format as GMT ASCII time
   $time = str2time($string);    # convert ASCII date to machine time
  
  =head1 DESCRIPTION
  
  This module provides functions that deal the date formats used by the
  HTTP protocol (and then some more).  Only the first two functions,
  time2str() and str2time(), are exported by default.
  
  =over 4
  
  =item time2str( [$time] )
  
  The time2str() function converts a machine time (seconds since epoch)
  to a string.  If the function is called without an argument or with an
  undefined argument, it will use the current time.
  
  The string returned is in the format preferred for the HTTP protocol.
  This is a fixed length subset of the format defined by RFC 1123,
  represented in Universal Time (GMT).  An example of a time stamp
  in this format is:
  
     Sun, 06 Nov 1994 08:49:37 GMT
  
  =item str2time( $str [, $zone] )
  
  The str2time() function converts a string to machine time.  It returns
  C<undef> if the format of $str is unrecognized, otherwise whatever the
  C<Time::Local> functions can make out of the parsed time.  Dates
  before the system's epoch may not work on all operating systems.  The
  time formats recognized are the same as for parse_date().
  
  The function also takes an optional second argument that specifies the
  default time zone to use when converting the date.  This parameter is
  ignored if the zone is found in the date string itself.  If this
  parameter is missing, and the date string format does not contain any
  zone specification, then the local time zone is assumed.
  
  If the zone is not "C<GMT>" or numerical (like "C<-0800>" or
  "C<+0100>"), then the C<Time::Zone> module must be installed in order
  to get the date recognized.
  
  =item parse_date( $str )
  
  This function will try to parse a date string, and then return it as a
  list of numerical values followed by a (possible undefined) time zone
  specifier; ($year, $month, $day, $hour, $min, $sec, $tz).  The $year
  returned will B<not> have the number 1900 subtracted from it and the
  $month numbers start with 1.
  
  In scalar context the numbers are interpolated in a string of the
  "YYYY-MM-DD hh:mm:ss TZ"-format and returned.
  
  If the date is unrecognized, then the empty list is returned.
  
  The function is able to parse the following formats:
  
   "Wed, 09 Feb 1994 22:23:32 GMT"       -- HTTP format
   "Thu Feb  3 17:03:55 GMT 1994"        -- ctime(3) format
   "Thu Feb  3 00:00:00 1994",           -- ANSI C asctime() format
   "Tuesday, 08-Feb-94 14:15:29 GMT"     -- old rfc850 HTTP format
   "Tuesday, 08-Feb-1994 14:15:29 GMT"   -- broken rfc850 HTTP format
  
   "03/Feb/1994:17:03:55 -0700"   -- common logfile format
   "09 Feb 1994 22:23:32 GMT"     -- HTTP format (no weekday)
   "08-Feb-94 14:15:29 GMT"       -- rfc850 format (no weekday)
   "08-Feb-1994 14:15:29 GMT"     -- broken rfc850 format (no weekday)
  
   "1994-02-03 14:15:29 -0100"    -- ISO 8601 format
   "1994-02-03 14:15:29"          -- zone is optional
   "1994-02-03"                   -- only date
   "1994-02-03T14:15:29"          -- Use T as separator
   "19940203T141529Z"             -- ISO 8601 compact format
   "19940203"                     -- only date
  
   "08-Feb-94"         -- old rfc850 HTTP format    (no weekday, no time)
   "08-Feb-1994"       -- broken rfc850 HTTP format (no weekday, no time)
   "09 Feb 1994"       -- proposed new HTTP format  (no weekday, no time)
   "03/Feb/1994"       -- common logfile format     (no time, no offset)
  
   "Feb  3  1994"      -- Unix 'ls -l' format
   "Feb  3 17:03"      -- Unix 'ls -l' format
  
   "11-15-96  03:52PM" -- Windows 'dir' format
  
  The parser ignores leading and trailing whitespace.  It also allow the
  seconds to be missing and the month to be numerical in most formats.
  
  If the year is missing, then we assume that the date is the first
  matching date I<before> current month.  If the year is given with only
  2 digits, then parse_date() will select the century that makes the
  year closest to the current date.
  
  =item time2iso( [$time] )
  
  Same as time2str(), but returns a "YYYY-MM-DD hh:mm:ss"-formatted
  string representing time in the local time zone.
  
  =item time2isoz( [$time] )
  
  Same as time2str(), but returns a "YYYY-MM-DD hh:mm:ssZ"-formatted
  string representing Universal Time.
  
  
  =back
  
  =head1 SEE ALSO
  
  L<perlfunc/time>, L<Time::Zone>
  
  =head1 COPYRIGHT
  
  Copyright 1995-1999, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
HTTP_DATE

$fatpacked{"HTTP/Headers.pm"} = <<'HTTP_HEADERS';
  package HTTP::Headers;
  
  use strict;
  use Carp ();
  
  use vars qw($VERSION $TRANSLATE_UNDERSCORE);
  $VERSION = "5.835";
  
  # The $TRANSLATE_UNDERSCORE variable controls whether '_' can be used
  # as a replacement for '-' in header field names.
  $TRANSLATE_UNDERSCORE = 1 unless defined $TRANSLATE_UNDERSCORE;
  
  # "Good Practice" order of HTTP message headers:
  #    - General-Headers
  #    - Request-Headers
  #    - Response-Headers
  #    - Entity-Headers
  
  my @general_headers = qw(
      Cache-Control Connection Date Pragma Trailer Transfer-Encoding Upgrade
      Via Warning
  );
  
  my @request_headers = qw(
      Accept Accept-Charset Accept-Encoding Accept-Language
      Authorization Expect From Host
      If-Match If-Modified-Since If-None-Match If-Range If-Unmodified-Since
      Max-Forwards Proxy-Authorization Range Referer TE User-Agent
  );
  
  my @response_headers = qw(
      Accept-Ranges Age ETag Location Proxy-Authenticate Retry-After Server
      Vary WWW-Authenticate
  );
  
  my @entity_headers = qw(
      Allow Content-Encoding Content-Language Content-Length Content-Location
      Content-MD5 Content-Range Content-Type Expires Last-Modified
  );
  
  my %entity_header = map { lc($_) => 1 } @entity_headers;
  
  my @header_order = (
      @general_headers,
      @request_headers,
      @response_headers,
      @entity_headers,
  );
  
  # Make alternative representations of @header_order.  This is used
  # for sorting and case matching.
  my %header_order;
  my %standard_case;
  
  {
      my $i = 0;
      for (@header_order) {
  	my $lc = lc $_;
  	$header_order{$lc} = ++$i;
  	$standard_case{$lc} = $_;
      }
  }
  
  
  
  sub new
  {
      my($class) = shift;
      my $self = bless {}, $class;
      $self->header(@_) if @_; # set up initial headers
      $self;
  }
  
  
  sub header
  {
      my $self = shift;
      Carp::croak('Usage: $h->header($field, ...)') unless @_;
      my(@old);
      my %seen;
      while (@_) {
  	my $field = shift;
          my $op = @_ ? ($seen{lc($field)}++ ? 'PUSH' : 'SET') : 'GET';
  	@old = $self->_header($field, shift, $op);
      }
      return @old if wantarray;
      return $old[0] if @old <= 1;
      join(", ", @old);
  }
  
  sub clear
  {
      my $self = shift;
      %$self = ();
  }
  
  
  sub push_header
  {
      my $self = shift;
      return $self->_header(@_, 'PUSH_H') if @_ == 2;
      while (@_) {
  	$self->_header(splice(@_, 0, 2), 'PUSH_H');
      }
  }
  
  
  sub init_header
  {
      Carp::croak('Usage: $h->init_header($field, $val)') if @_ != 3;
      shift->_header(@_, 'INIT');
  }
  
  
  sub remove_header
  {
      my($self, @fields) = @_;
      my $field;
      my @values;
      foreach $field (@fields) {
  	$field =~ tr/_/-/ if $field !~ /^:/ && $TRANSLATE_UNDERSCORE;
  	my $v = delete $self->{lc $field};
  	push(@values, ref($v) eq 'ARRAY' ? @$v : $v) if defined $v;
      }
      return @values;
  }
  
  sub remove_content_headers
  {
      my $self = shift;
      unless (defined(wantarray)) {
  	# fast branch that does not create return object
  	delete @$self{grep $entity_header{$_} || /^content-/, keys %$self};
  	return;
      }
  
      my $c = ref($self)->new;
      for my $f (grep $entity_header{$_} || /^content-/, keys %$self) {
  	$c->{$f} = delete $self->{$f};
      }
      $c;
  }
  
  
  sub _header
  {
      my($self, $field, $val, $op) = @_;
  
      unless ($field =~ /^:/) {
  	$field =~ tr/_/-/ if $TRANSLATE_UNDERSCORE;
  	my $old = $field;
  	$field = lc $field;
  	unless(defined $standard_case{$field}) {
  	    # generate a %standard_case entry for this field
  	    $old =~ s/\b(\w)/\u$1/g;
  	    $standard_case{$field} = $old;
  	}
      }
  
      $op ||= defined($val) ? 'SET' : 'GET';
      if ($op eq 'PUSH_H') {
  	# Like PUSH but where we don't care about the return value
  	if (exists $self->{$field}) {
  	    my $h = $self->{$field};
  	    if (ref($h) eq 'ARRAY') {
  		push(@$h, ref($val) eq "ARRAY" ? @$val : $val);
  	    }
  	    else {
  		$self->{$field} = [$h, ref($val) eq "ARRAY" ? @$val : $val]
  	    }
  	    return;
  	}
  	$self->{$field} = $val;
  	return;
      }
  
      my $h = $self->{$field};
      my @old = ref($h) eq 'ARRAY' ? @$h : (defined($h) ? ($h) : ());
  
      unless ($op eq 'GET' || ($op eq 'INIT' && @old)) {
  	if (defined($val)) {
  	    my @new = ($op eq 'PUSH') ? @old : ();
  	    if (ref($val) ne 'ARRAY') {
  		push(@new, $val);
  	    }
  	    else {
  		push(@new, @$val);
  	    }
  	    $self->{$field} = @new > 1 ? \@new : $new[0];
  	}
  	elsif ($op ne 'PUSH') {
  	    delete $self->{$field};
  	}
      }
      @old;
  }
  
  
  sub _sorted_field_names
  {
      my $self = shift;
      return [ sort {
          ($header_order{$a} || 999) <=> ($header_order{$b} || 999) ||
           $a cmp $b
      } keys %$self ];
  }
  
  
  sub header_field_names {
      my $self = shift;
      return map $standard_case{$_} || $_, @{ $self->_sorted_field_names },
  	if wantarray;
      return keys %$self;
  }
  
  
  sub scan
  {
      my($self, $sub) = @_;
      my $key;
      for $key (@{ $self->_sorted_field_names }) {
  	next if substr($key, 0, 1) eq '_';
  	my $vals = $self->{$key};
  	if (ref($vals) eq 'ARRAY') {
  	    my $val;
  	    for $val (@$vals) {
  		$sub->($standard_case{$key} || $key, $val);
  	    }
  	}
  	else {
  	    $sub->($standard_case{$key} || $key, $vals);
  	}
      }
  }
  
  
  sub as_string
  {
      my($self, $endl) = @_;
      $endl = "\n" unless defined $endl;
  
      my @result = ();
      for my $key (@{ $self->_sorted_field_names }) {
  	next if index($key, '_') == 0;
  	my $vals = $self->{$key};
  	if ( ref($vals) eq 'ARRAY' ) {
  	    for my $val (@$vals) {
  		my $field = $standard_case{$key} || $key;
  		$field =~ s/^://;
  		if ( index($val, "\n") >= 0 ) {
  		    $val = _process_newline($val, $endl);
  		}
  		push @result, $field . ': ' . $val;
  	    }
  	}
  	else {
  	    my $field = $standard_case{$key} || $key;
  	    $field =~ s/^://;
  	    if ( index($vals, "\n") >= 0 ) {
  		$vals = _process_newline($vals, $endl);
  	    }
  	    push @result, $field . ': ' . $vals;
  	}
      }
  
      join($endl, @result, '');
  }
  
  sub _process_newline {
      local $_ = shift;
      my $endl = shift;
      # must handle header values with embedded newlines with care
      s/\s+$//;        # trailing newlines and space must go
      s/\n(\x0d?\n)+/\n/g;     # no empty lines
      s/\n([^\040\t])/\n $1/g; # intial space for continuation
      s/\n/$endl/g;    # substitute with requested line ending
      $_;
  }
  
  
  
  if (eval { require Storable; 1 }) {
      *clone = \&Storable::dclone;
  } else {
      *clone = sub {
  	my $self = shift;
  	my $clone = HTTP::Headers->new;
  	$self->scan(sub { $clone->push_header(@_);} );
  	$clone;
      };
  }
  
  
  sub _date_header
  {
      require HTTP::Date;
      my($self, $header, $time) = @_;
      my($old) = $self->_header($header);
      if (defined $time) {
  	$self->_header($header, HTTP::Date::time2str($time));
      }
      $old =~ s/;.*// if defined($old);
      HTTP::Date::str2time($old);
  }
  
  
  sub date                { shift->_date_header('Date',                @_); }
  sub expires             { shift->_date_header('Expires',             @_); }
  sub if_modified_since   { shift->_date_header('If-Modified-Since',   @_); }
  sub if_unmodified_since { shift->_date_header('If-Unmodified-Since', @_); }
  sub last_modified       { shift->_date_header('Last-Modified',       @_); }
  
  # This is used as a private LWP extension.  The Client-Date header is
  # added as a timestamp to a response when it has been received.
  sub client_date         { shift->_date_header('Client-Date',         @_); }
  
  # The retry_after field is dual format (can also be a expressed as
  # number of seconds from now), so we don't provide an easy way to
  # access it until we have know how both these interfaces can be
  # addressed.  One possibility is to return a negative value for
  # relative seconds and a positive value for epoch based time values.
  #sub retry_after       { shift->_date_header('Retry-After',       @_); }
  
  sub content_type      {
      my $self = shift;
      my $ct = $self->{'content-type'};
      $self->{'content-type'} = shift if @_;
      $ct = $ct->[0] if ref($ct) eq 'ARRAY';
      return '' unless defined($ct) && length($ct);
      my @ct = split(/;\s*/, $ct, 2);
      for ($ct[0]) {
  	s/\s+//g;
  	$_ = lc($_);
      }
      wantarray ? @ct : $ct[0];
  }
  
  sub content_type_charset {
      my $self = shift;
      require HTTP::Headers::Util;
      my $h = $self->{'content-type'};
      $h = $h->[0] if ref($h);
      $h = "" unless defined $h;
      my @v = HTTP::Headers::Util::split_header_words($h);
      if (@v) {
  	my($ct, undef, %ct_param) = @{$v[0]};
  	my $charset = $ct_param{charset};
  	if ($ct) {
  	    $ct = lc($ct);
  	    $ct =~ s/\s+//;
  	}
  	if ($charset) {
  	    $charset = uc($charset);
  	    $charset =~ s/^\s+//;  $charset =~ s/\s+\z//;
  	    undef($charset) if $charset eq "";
  	}
  	return $ct, $charset if wantarray;
  	return $charset;
      }
      return undef, undef if wantarray;
      return undef;
  }
  
  sub content_is_text {
      my $self = shift;
      return $self->content_type =~ m,^text/,;
  }
  
  sub content_is_html {
      my $self = shift;
      return $self->content_type eq 'text/html' || $self->content_is_xhtml;
  }
  
  sub content_is_xhtml {
      my $ct = shift->content_type;
      return $ct eq "application/xhtml+xml" ||
             $ct eq "application/vnd.wap.xhtml+xml";
  }
  
  sub content_is_xml {
      my $ct = shift->content_type;
      return 1 if $ct eq "text/xml";
      return 1 if $ct eq "application/xml";
      return 1 if $ct =~ /\+xml$/;
      return 0;
  }
  
  sub referer           {
      my $self = shift;
      if (@_ && $_[0] =~ /#/) {
  	# Strip fragment per RFC 2616, section 14.36.
  	my $uri = shift;
  	if (ref($uri)) {
  	    $uri = $uri->clone;
  	    $uri->fragment(undef);
  	}
  	else {
  	    $uri =~ s/\#.*//;
  	}
  	unshift @_, $uri;
      }
      ($self->_header('Referer', @_))[0];
  }
  *referrer = \&referer;  # on tchrist's request
  
  sub title             { (shift->_header('Title',            @_))[0] }
  sub content_encoding  { (shift->_header('Content-Encoding', @_))[0] }
  sub content_language  { (shift->_header('Content-Language', @_))[0] }
  sub content_length    { (shift->_header('Content-Length',   @_))[0] }
  
  sub user_agent        { (shift->_header('User-Agent',       @_))[0] }
  sub server            { (shift->_header('Server',           @_))[0] }
  
  sub from              { (shift->_header('From',             @_))[0] }
  sub warning           { (shift->_header('Warning',          @_))[0] }
  
  sub www_authenticate  { (shift->_header('WWW-Authenticate', @_))[0] }
  sub authorization     { (shift->_header('Authorization',    @_))[0] }
  
  sub proxy_authenticate  { (shift->_header('Proxy-Authenticate',  @_))[0] }
  sub proxy_authorization { (shift->_header('Proxy-Authorization', @_))[0] }
  
  sub authorization_basic       { shift->_basic_auth("Authorization",       @_) }
  sub proxy_authorization_basic { shift->_basic_auth("Proxy-Authorization", @_) }
  
  sub _basic_auth {
      require MIME::Base64;
      my($self, $h, $user, $passwd) = @_;
      my($old) = $self->_header($h);
      if (defined $user) {
  	Carp::croak("Basic authorization user name can't contain ':'")
  	  if $user =~ /:/;
  	$passwd = '' unless defined $passwd;
  	$self->_header($h => 'Basic ' .
                               MIME::Base64::encode("$user:$passwd", ''));
      }
      if (defined $old && $old =~ s/^\s*Basic\s+//) {
  	my $val = MIME::Base64::decode($old);
  	return $val unless wantarray;
  	return split(/:/, $val, 2);
      }
      return;
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Headers - Class encapsulating HTTP Message headers
  
  =head1 SYNOPSIS
  
   require HTTP::Headers;
   $h = HTTP::Headers->new;
  
   $h->header('Content-Type' => 'text/plain');  # set
   $ct = $h->header('Content-Type');            # get
   $h->remove_header('Content-Type');           # delete
  
  =head1 DESCRIPTION
  
  The C<HTTP::Headers> class encapsulates HTTP-style message headers.
  The headers consist of attribute-value pairs also called fields, which
  may be repeated, and which are printed in a particular order.  The
  field names are cases insensitive.
  
  Instances of this class are usually created as member variables of the
  C<HTTP::Request> and C<HTTP::Response> classes, internal to the
  library.
  
  The following methods are available:
  
  =over 4
  
  =item $h = HTTP::Headers->new
  
  Constructs a new C<HTTP::Headers> object.  You might pass some initial
  attribute-value pairs as parameters to the constructor.  I<E.g.>:
  
   $h = HTTP::Headers->new(
         Date         => 'Thu, 03 Feb 1994 00:00:00 GMT',
         Content_Type => 'text/html; version=3.2',
         Content_Base => 'http://www.perl.org/');
  
  The constructor arguments are passed to the C<header> method which is
  described below.
  
  =item $h->clone
  
  Returns a copy of this C<HTTP::Headers> object.
  
  =item $h->header( $field )
  
  =item $h->header( $field => $value )
  
  =item $h->header( $f1 => $v1, $f2 => $v2, ... )
  
  Get or set the value of one or more header fields.  The header field
  name ($field) is not case sensitive.  To make the life easier for perl
  users who wants to avoid quoting before the => operator, you can use
  '_' as a replacement for '-' in header names.
  
  The header() method accepts multiple ($field => $value) pairs, which
  means that you can update several fields with a single invocation.
  
  The $value argument may be a plain string or a reference to an array
  of strings for a multi-valued field. If the $value is provided as
  C<undef> then the field is removed.  If the $value is not given, then
  that header field will remain unchanged.
  
  The old value (or values) of the last of the header fields is returned.
  If no such field exists C<undef> will be returned.
  
  A multi-valued field will be returned as separate values in list
  context and will be concatenated with ", " as separator in scalar
  context.  The HTTP spec (RFC 2616) promise that joining multiple
  values in this way will not change the semantic of a header field, but
  in practice there are cases like old-style Netscape cookies (see
  L<HTTP::Cookies>) where "," is used as part of the syntax of a single
  field value.
  
  Examples:
  
   $header->header(MIME_Version => '1.0',
  		 User_Agent   => 'My-Web-Client/0.01');
   $header->header(Accept => "text/html, text/plain, image/*");
   $header->header(Accept => [qw(text/html text/plain image/*)]);
   @accepts = $header->header('Accept');  # get multiple values
   $accepts = $header->header('Accept');  # get values as a single string
  
  =item $h->push_header( $field => $value )
  
  =item $h->push_header( $f1 => $v1, $f2 => $v2, ... )
  
  Add a new field value for the specified header field.  Previous values
  for the same field are retained.
  
  As for the header() method, the field name ($field) is not case
  sensitive and '_' can be used as a replacement for '-'.
  
  The $value argument may be a scalar or a reference to a list of
  scalars.
  
   $header->push_header(Accept => 'image/jpeg');
   $header->push_header(Accept => [map "image/$_", qw(gif png tiff)]);
  
  =item $h->init_header( $field => $value )
  
  Set the specified header to the given value, but only if no previous
  value for that field is set.
  
  The header field name ($field) is not case sensitive and '_'
  can be used as a replacement for '-'.
  
  The $value argument may be a scalar or a reference to a list of
  scalars.
  
  =item $h->remove_header( $field, ... )
  
  This function removes the header fields with the specified names.
  
  The header field names ($field) are not case sensitive and '_'
  can be used as a replacement for '-'.
  
  The return value is the values of the fields removed.  In scalar
  context the number of fields removed is returned.
  
  Note that if you pass in multiple field names then it is generally not
  possible to tell which of the returned values belonged to which field.
  
  =item $h->remove_content_headers
  
  This will remove all the header fields used to describe the content of
  a message.  All header field names prefixed with C<Content-> fall
  into this category, as well as C<Allow>, C<Expires> and
  C<Last-Modified>.  RFC 2616 denotes these fields as I<Entity Header
  Fields>.
  
  The return value is a new C<HTTP::Headers> object that contains the
  removed headers only.
  
  =item $h->clear
  
  This will remove all header fields.
  
  =item $h->header_field_names
  
  Returns the list of distinct names for the fields present in the
  header.  The field names have case as suggested by HTTP spec, and the
  names are returned in the recommended "Good Practice" order.
  
  In scalar context return the number of distinct field names.
  
  =item $h->scan( \&process_header_field )
  
  Apply a subroutine to each header field in turn.  The callback routine
  is called with two parameters; the name of the field and a single
  value (a string).  If a header field is multi-valued, then the
  routine is called once for each value.  The field name passed to the
  callback routine has case as suggested by HTTP spec, and the headers
  will be visited in the recommended "Good Practice" order.
  
  Any return values of the callback routine are ignored.  The loop can
  be broken by raising an exception (C<die>), but the caller of scan()
  would have to trap the exception itself.
  
  =item $h->as_string
  
  =item $h->as_string( $eol )
  
  Return the header fields as a formatted MIME header.  Since it
  internally uses the C<scan> method to build the string, the result
  will use case as suggested by HTTP spec, and it will follow
  recommended "Good Practice" of ordering the header fields.  Long header
  values are not folded.
  
  The optional $eol parameter specifies the line ending sequence to
  use.  The default is "\n".  Embedded "\n" characters in header field
  values will be substituted with this line ending sequence.
  
  =back
  
  =head1 CONVENIENCE METHODS
  
  The most frequently used headers can also be accessed through the
  following convenience methods.  Most of these methods can both be used to read
  and to set the value of a header.  The header value is set if you pass
  an argument to the method.  The old header value is always returned.
  If the given header did not exist then C<undef> is returned.
  
  Methods that deal with dates/times always convert their value to system
  time (seconds since Jan 1, 1970) and they also expect this kind of
  value when the header value is set.
  
  =over 4
  
  =item $h->date
  
  This header represents the date and time at which the message was
  originated. I<E.g.>:
  
    $h->date(time);  # set current date
  
  =item $h->expires
  
  This header gives the date and time after which the entity should be
  considered stale.
  
  =item $h->if_modified_since
  
  =item $h->if_unmodified_since
  
  These header fields are used to make a request conditional.  If the requested
  resource has (or has not) been modified since the time specified in this field,
  then the server will return a C<304 Not Modified> response instead of
  the document itself.
  
  =item $h->last_modified
  
  This header indicates the date and time at which the resource was last
  modified. I<E.g.>:
  
    # check if document is more than 1 hour old
    if (my $last_mod = $h->last_modified) {
        if ($last_mod < time - 60*60) {
  	  ...
        }
    }
  
  =item $h->content_type
  
  The Content-Type header field indicates the media type of the message
  content. I<E.g.>:
  
    $h->content_type('text/html');
  
  The value returned will be converted to lower case, and potential
  parameters will be chopped off and returned as a separate value if in
  an array context.  If there is no such header field, then the empty
  string is returned.  This makes it safe to do the following:
  
    if ($h->content_type eq 'text/html') {
       # we enter this place even if the real header value happens to
       # be 'TEXT/HTML; version=3.0'
       ...
    }
  
  =item $h->content_type_charset
  
  Returns the upper-cased charset specified in the Content-Type header.  In list
  context return the lower-cased bare content type followed by the upper-cased
  charset.  Both values will be C<undef> if not specified in the header.
  
  =item $h->content_is_text
  
  Returns TRUE if the Content-Type header field indicate that the
  content is textual.
  
  =item $h->content_is_html
  
  Returns TRUE if the Content-Type header field indicate that the
  content is some kind of HTML (including XHTML).  This method can't be
  used to set Content-Type.
  
  =item $h->content_is_xhtml
  
  Returns TRUE if the Content-Type header field indicate that the
  content is XHTML.  This method can't be used to set Content-Type.
  
  =item $h->content_is_xml
  
  Returns TRUE if the Content-Type header field indicate that the
  content is XML.  This method can't be used to set Content-Type.
  
  =item $h->content_encoding
  
  The Content-Encoding header field is used as a modifier to the
  media type.  When present, its value indicates what additional
  encoding mechanism has been applied to the resource.
  
  =item $h->content_length
  
  A decimal number indicating the size in bytes of the message content.
  
  =item $h->content_language
  
  The natural language(s) of the intended audience for the message
  content.  The value is one or more language tags as defined by RFC
  1766.  Eg. "no" for some kind of Norwegian and "en-US" for English the
  way it is written in the US.
  
  =item $h->title
  
  The title of the document.  In libwww-perl this header will be
  initialized automatically from the E<lt>TITLE>...E<lt>/TITLE> element
  of HTML documents.  I<This header is no longer part of the HTTP
  standard.>
  
  =item $h->user_agent
  
  This header field is used in request messages and contains information
  about the user agent originating the request.  I<E.g.>:
  
    $h->user_agent('Mozilla/5.0 (compatible; MSIE 7.0; Windows NT 6.0)');
  
  =item $h->server
  
  The server header field contains information about the software being
  used by the originating server program handling the request.
  
  =item $h->from
  
  This header should contain an Internet e-mail address for the human
  user who controls the requesting user agent.  The address should be
  machine-usable, as defined by RFC822.  E.g.:
  
    $h->from('King Kong <king@kong.com>');
  
  I<This header is no longer part of the HTTP standard.>
  
  =item $h->referer
  
  Used to specify the address (URI) of the document from which the
  requested resource address was obtained.
  
  The "Free On-line Dictionary of Computing" as this to say about the
  word I<referer>:
  
       <World-Wide Web> A misspelling of "referrer" which
       somehow made it into the {HTTP} standard.  A given {web
       page}'s referer (sic) is the {URL} of whatever web page
       contains the link that the user followed to the current
       page.  Most browsers pass this information as part of a
       request.
  
       (1998-10-19)
  
  By popular demand C<referrer> exists as an alias for this method so you
  can avoid this misspelling in your programs and still send the right
  thing on the wire.
  
  When setting the referrer, this method removes the fragment from the
  given URI if it is present, as mandated by RFC2616.  Note that
  the removal does I<not> happen automatically if using the header(),
  push_header() or init_header() methods to set the referrer.
  
  =item $h->www_authenticate
  
  This header must be included as part of a C<401 Unauthorized> response.
  The field value consist of a challenge that indicates the
  authentication scheme and parameters applicable to the requested URI.
  
  =item $h->proxy_authenticate
  
  This header must be included in a C<407 Proxy Authentication Required>
  response.
  
  =item $h->authorization
  
  =item $h->proxy_authorization
  
  A user agent that wishes to authenticate itself with a server or a
  proxy, may do so by including these headers.
  
  =item $h->authorization_basic
  
  This method is used to get or set an authorization header that use the
  "Basic Authentication Scheme".  In array context it will return two
  values; the user name and the password.  In scalar context it will
  return I<"uname:password"> as a single string value.
  
  When used to set the header value, it expects two arguments.  I<E.g.>:
  
    $h->authorization_basic($uname, $password);
  
  The method will croak if the $uname contains a colon ':'.
  
  =item $h->proxy_authorization_basic
  
  Same as authorization_basic() but will set the "Proxy-Authorization"
  header instead.
  
  =back
  
  =head1 NON-CANONICALIZED FIELD NAMES
  
  The header field name spelling is normally canonicalized including the
  '_' to '-' translation.  There are some application where this is not
  appropriate.  Prefixing field names with ':' allow you to force a
  specific spelling.  For example if you really want a header field name
  to show up as C<foo_bar> instead of "Foo-Bar", you might set it like
  this:
  
    $h->header(":foo_bar" => 1);
  
  These field names are returned with the ':' intact for
  $h->header_field_names and the $h->scan callback, but the colons do
  not show in $h->as_string.
  
  =head1 COPYRIGHT
  
  Copyright 1995-2005 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
HTTP_HEADERS

$fatpacked{"HTTP/Headers/Auth.pm"} = <<'HTTP_HEADERS_AUTH';
  package HTTP::Headers::Auth;
  
  use strict;
  use vars qw($VERSION);
  $VERSION = "5.817";
  
  use HTTP::Headers;
  
  package HTTP::Headers;
  
  BEGIN {
      # we provide a new (and better) implementations below
      undef(&www_authenticate);
      undef(&proxy_authenticate);
  }
  
  require HTTP::Headers::Util;
  
  sub _parse_authenticate
  {
      my @ret;
      for (HTTP::Headers::Util::split_header_words(@_)) {
  	if (!defined($_->[1])) {
  	    # this is a new auth scheme
  	    push(@ret, shift(@$_) => {});
  	    shift @$_;
  	}
  	if (@ret) {
  	    # this a new parameter pair for the last auth scheme
  	    while (@$_) {
  		my $k = shift @$_;
  		my $v = shift @$_;
  	        $ret[-1]{$k} = $v;
  	    }
  	}
  	else {
  	    # something wrong, parameter pair without any scheme seen
  	    # IGNORE
  	}
      }
      @ret;
  }
  
  sub _authenticate
  {
      my $self = shift;
      my $header = shift;
      my @old = $self->_header($header);
      if (@_) {
  	$self->remove_header($header);
  	my @new = @_;
  	while (@new) {
  	    my $a_scheme = shift(@new);
  	    if ($a_scheme =~ /\s/) {
  		# assume complete valid value, pass it through
  		$self->push_header($header, $a_scheme);
  	    }
  	    else {
  		my @param;
  		if (@new) {
  		    my $p = $new[0];
  		    if (ref($p) eq "ARRAY") {
  			@param = @$p;
  			shift(@new);
  		    }
  		    elsif (ref($p) eq "HASH") {
  			@param = %$p;
  			shift(@new);
  		    }
  		}
  		my $val = ucfirst(lc($a_scheme));
  		if (@param) {
  		    my $sep = " ";
  		    while (@param) {
  			my $k = shift @param;
  			my $v = shift @param;
  			if ($v =~ /[^0-9a-zA-Z]/ || lc($k) eq "realm") {
  			    # must quote the value
  			    $v =~ s,([\\\"]),\\$1,g;
  			    $v = qq("$v");
  			}
  			$val .= "$sep$k=$v";
  			$sep = ", ";
  		    }
  		}
  		$self->push_header($header, $val);
  	    }
  	}
      }
      return unless defined wantarray;
      wantarray ? _parse_authenticate(@old) : join(", ", @old);
  }
  
  
  sub www_authenticate    { shift->_authenticate("WWW-Authenticate", @_)   }
  sub proxy_authenticate  { shift->_authenticate("Proxy-Authenticate", @_) }
  
  1;
HTTP_HEADERS_AUTH

$fatpacked{"HTTP/Headers/ETag.pm"} = <<'HTTP_HEADERS_ETAG';
  package HTTP::Headers::ETag;
  
  use strict;
  use vars qw($VERSION);
  $VERSION = "5.810";
  
  require HTTP::Date;
  
  require HTTP::Headers;
  package HTTP::Headers;
  
  sub _etags
  {
      my $self = shift;
      my $header = shift;
      my @old = _split_etag_list($self->_header($header));
      if (@_) {
  	$self->_header($header => join(", ", _split_etag_list(@_)));
      }
      wantarray ? @old : join(", ", @old);
  }
  
  sub etag          { shift->_etags("ETag", @_); }
  sub if_match      { shift->_etags("If-Match", @_); }
  sub if_none_match { shift->_etags("If-None-Match", @_); }
  
  sub if_range {
      # Either a date or an entity-tag
      my $self = shift;
      my @old = $self->_header("If-Range");
      if (@_) {
  	my $new = shift;
  	if (!defined $new) {
  	    $self->remove_header("If-Range");
  	}
  	elsif ($new =~ /^\d+$/) {
  	    $self->_date_header("If-Range", $new);
  	}
  	else {
  	    $self->_etags("If-Range", $new);
  	}
      }
      return unless defined(wantarray);
      for (@old) {
  	my $t = HTTP::Date::str2time($_);
  	$_ = $t if $t;
      }
      wantarray ? @old : join(", ", @old);
  }
  
  
  # Split a list of entity tag values.  The return value is a list
  # consisting of one element per entity tag.  Suitable for parsing
  # headers like C<If-Match>, C<If-None-Match>.  You might even want to
  # use it on C<ETag> and C<If-Range> entity tag values, because it will
  # normalize them to the common form.
  #
  #  entity-tag	  = [ weak ] opaque-tag
  #  weak		  = "W/"
  #  opaque-tag	  = quoted-string
  
  
  sub _split_etag_list
  {
      my(@val) = @_;
      my @res;
      for (@val) {
          while (length) {
              my $weak = "";
  	    $weak = "W/" if s,^\s*[wW]/,,;
              my $etag = "";
  	    if (s/^\s*(\"[^\"\\]*(?:\\.[^\"\\]*)*\")//) {
  		push(@res, "$weak$1");
              }
              elsif (s/^\s*,//) {
                  push(@res, qq(W/"")) if $weak;
              }
              elsif (s/^\s*([^,\s]+)//) {
                  $etag = $1;
  		$etag =~ s/([\"\\])/\\$1/g;
  	        push(@res, qq($weak"$etag"));
              }
              elsif (s/^\s+// || !length) {
                  push(@res, qq(W/"")) if $weak;
              }
              else {
  	 	die "This should not happen: '$_'";
              }
          }
     }
     @res;
  }
  
  1;
HTTP_HEADERS_ETAG

$fatpacked{"HTTP/Headers/Util.pm"} = <<'HTTP_HEADERS_UTIL';
  package HTTP::Headers::Util;
  
  use strict;
  use vars qw($VERSION @ISA @EXPORT_OK);
  
  $VERSION = "5.817";
  
  require Exporter;
  @ISA=qw(Exporter);
  
  @EXPORT_OK=qw(split_header_words _split_header_words join_header_words);
  
  
  
  sub split_header_words {
      my @res = &_split_header_words;
      for my $arr (@res) {
  	for (my $i = @$arr - 2; $i >= 0; $i -= 2) {
  	    $arr->[$i] = lc($arr->[$i]);
  	}
      }
      return @res;
  }
  
  sub _split_header_words
  {
      my(@val) = @_;
      my @res;
      for (@val) {
  	my @cur;
  	while (length) {
  	    if (s/^\s*(=*[^\s=;,]+)//) {  # 'token' or parameter 'attribute'
  		push(@cur, $1);
  		# a quoted value
  		if (s/^\s*=\s*\"([^\"\\]*(?:\\.[^\"\\]*)*)\"//) {
  		    my $val = $1;
  		    $val =~ s/\\(.)/$1/g;
  		    push(@cur, $val);
  		# some unquoted value
  		}
  		elsif (s/^\s*=\s*([^;,\s]*)//) {
  		    my $val = $1;
  		    $val =~ s/\s+$//;
  		    push(@cur, $val);
  		# no value, a lone token
  		}
  		else {
  		    push(@cur, undef);
  		}
  	    }
  	    elsif (s/^\s*,//) {
  		push(@res, [@cur]) if @cur;
  		@cur = ();
  	    }
  	    elsif (s/^\s*;// || s/^\s+//) {
  		# continue
  	    }
  	    else {
  		die "This should not happen: '$_'";
  	    }
  	}
  	push(@res, \@cur) if @cur;
      }
      @res;
  }
  
  
  sub join_header_words
  {
      @_ = ([@_]) if @_ && !ref($_[0]);
      my @res;
      for (@_) {
  	my @cur = @$_;
  	my @attr;
  	while (@cur) {
  	    my $k = shift @cur;
  	    my $v = shift @cur;
  	    if (defined $v) {
  		if ($v =~ /[\x00-\x20()<>@,;:\\\"\/\[\]?={}\x7F-\xFF]/ || !length($v)) {
  		    $v =~ s/([\"\\])/\\$1/g;  # escape " and \
  		    $k .= qq(="$v");
  		}
  		else {
  		    # token
  		    $k .= "=$v";
  		}
  	    }
  	    push(@attr, $k);
  	}
  	push(@res, join("; ", @attr)) if @attr;
      }
      join(", ", @res);
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Headers::Util - Header value parsing utility functions
  
  =head1 SYNOPSIS
  
    use HTTP::Headers::Util qw(split_header_words);
    @values = split_header_words($h->header("Content-Type"));
  
  =head1 DESCRIPTION
  
  This module provides a few functions that helps parsing and
  construction of valid HTTP header values.  None of the functions are
  exported by default.
  
  The following functions are available:
  
  =over 4
  
  
  =item split_header_words( @header_values )
  
  This function will parse the header values given as argument into a
  list of anonymous arrays containing key/value pairs.  The function
  knows how to deal with ",", ";" and "=" as well as quoted values after
  "=".  A list of space separated tokens are parsed as if they were
  separated by ";".
  
  If the @header_values passed as argument contains multiple values,
  then they are treated as if they were a single value separated by
  comma ",".
  
  This means that this function is useful for parsing header fields that
  follow this syntax (BNF as from the HTTP/1.1 specification, but we relax
  the requirement for tokens).
  
    headers           = #header
    header            = (token | parameter) *( [";"] (token | parameter))
  
    token             = 1*<any CHAR except CTLs or separators>
    separators        = "(" | ")" | "<" | ">" | "@"
                      | "," | ";" | ":" | "\" | <">
                      | "/" | "[" | "]" | "?" | "="
                      | "{" | "}" | SP | HT
  
    quoted-string     = ( <"> *(qdtext | quoted-pair ) <"> )
    qdtext            = <any TEXT except <">>
    quoted-pair       = "\" CHAR
  
    parameter         = attribute "=" value
    attribute         = token
    value             = token | quoted-string
  
  Each I<header> is represented by an anonymous array of key/value
  pairs.  The keys will be all be forced to lower case.
  The value for a simple token (not part of a parameter) is C<undef>.
  Syntactically incorrect headers will not necessary be parsed as you
  would want.
  
  This is easier to describe with some examples:
  
     split_header_words('foo="bar"; port="80,81"; DISCARD, BAR=baz');
     split_header_words('text/html; charset="iso-8859-1"');
     split_header_words('Basic realm="\\"foo\\\\bar\\""');
  
  will return
  
     [foo=>'bar', port=>'80,81', discard=> undef], [bar=>'baz' ]
     ['text/html' => undef, charset => 'iso-8859-1']
     [basic => undef, realm => "\"foo\\bar\""]
  
  If you don't want the function to convert tokens and attribute keys to
  lower case you can call it as C<_split_header_words> instead (with a
  leading underscore).
  
  =item join_header_words( @arrays )
  
  This will do the opposite of the conversion done by split_header_words().
  It takes a list of anonymous arrays as arguments (or a list of
  key/value pairs) and produces a single header value.  Attribute values
  are quoted if needed.
  
  Example:
  
     join_header_words(["text/plain" => undef, charset => "iso-8859/1"]);
     join_header_words("text/plain" => undef, charset => "iso-8859/1");
  
  will both return the string:
  
     text/plain; charset="iso-8859/1"
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 1997-1998, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
HTTP_HEADERS_UTIL

$fatpacked{"HTTP/Message.pm"} = <<'HTTP_MESSAGE';
  package HTTP::Message;
  
  use strict;
  use vars qw($VERSION $AUTOLOAD);
  $VERSION = "5.835";
  
  require HTTP::Headers;
  require Carp;
  
  my $CRLF = "\015\012";   # "\r\n" is not portable
  $HTTP::URI_CLASS ||= $ENV{PERL_HTTP_URI_CLASS} || "URI";
  eval "require $HTTP::URI_CLASS"; die $@ if $@;
  
  *_utf8_downgrade = defined(&utf8::downgrade) ?
      sub {
          utf8::downgrade($_[0], 1) or
              Carp::croak("HTTP::Message content must be bytes")
      }
      :
      sub {
      };
  
  sub new
  {
      my($class, $header, $content) = @_;
      if (defined $header) {
  	Carp::croak("Bad header argument") unless ref $header;
          if (ref($header) eq "ARRAY") {
  	    $header = HTTP::Headers->new(@$header);
  	}
  	else {
  	    $header = $header->clone;
  	}
      }
      else {
  	$header = HTTP::Headers->new;
      }
      if (defined $content) {
          _utf8_downgrade($content);
      }
      else {
          $content = '';
      }
  
      bless {
  	'_headers' => $header,
  	'_content' => $content,
      }, $class;
  }
  
  
  sub parse
  {
      my($class, $str) = @_;
  
      my @hdr;
      while (1) {
  	if ($str =~ s/^([^\s:]+)[ \t]*: ?(.*)\n?//) {
  	    push(@hdr, $1, $2);
  	    $hdr[-1] =~ s/\r\z//;
  	}
  	elsif (@hdr && $str =~ s/^([ \t].*)\n?//) {
  	    $hdr[-1] .= "\n$1";
  	    $hdr[-1] =~ s/\r\z//;
  	}
  	else {
  	    $str =~ s/^\r?\n//;
  	    last;
  	}
      }
      local $HTTP::Headers::TRANSLATE_UNDERSCORE;
      new($class, \@hdr, $str);
  }
  
  
  sub clone
  {
      my $self  = shift;
      my $clone = HTTP::Message->new($self->headers,
  				   $self->content);
      $clone->protocol($self->protocol);
      $clone;
  }
  
  
  sub clear {
      my $self = shift;
      $self->{_headers}->clear;
      $self->content("");
      delete $self->{_parts};
      return;
  }
  
  
  sub protocol {
      shift->_elem('_protocol',  @_);
  }
  
  sub headers {
      my $self = shift;
  
      # recalculation of _content might change headers, so we
      # need to force it now
      $self->_content unless exists $self->{_content};
  
      $self->{_headers};
  }
  
  sub headers_as_string {
      shift->headers->as_string(@_);
  }
  
  
  sub content  {
  
      my $self = $_[0];
      if (defined(wantarray)) {
  	$self->_content unless exists $self->{_content};
  	my $old = $self->{_content};
  	$old = $$old if ref($old) eq "SCALAR";
  	&_set_content if @_ > 1;
  	return $old;
      }
  
      if (@_ > 1) {
  	&_set_content;
      }
      else {
  	Carp::carp("Useless content call in void context") if $^W;
      }
  }
  
  
  sub _set_content {
      my $self = $_[0];
      _utf8_downgrade($_[1]);
      if (!ref($_[1]) && ref($self->{_content}) eq "SCALAR") {
  	${$self->{_content}} = $_[1];
      }
      else {
  	die "Can't set content to be a scalar reference" if ref($_[1]) eq "SCALAR";
  	$self->{_content} = $_[1];
  	delete $self->{_content_ref};
      }
      delete $self->{_parts} unless $_[2];
  }
  
  
  sub add_content
  {
      my $self = shift;
      $self->_content unless exists $self->{_content};
      my $chunkref = \$_[0];
      $chunkref = $$chunkref if ref($$chunkref);  # legacy
  
      _utf8_downgrade($$chunkref);
  
      my $ref = ref($self->{_content});
      if (!$ref) {
  	$self->{_content} .= $$chunkref;
      }
      elsif ($ref eq "SCALAR") {
  	${$self->{_content}} .= $$chunkref;
      }
      else {
  	Carp::croak("Can't append to $ref content");
      }
      delete $self->{_parts};
  }
  
  sub add_content_utf8 {
      my($self, $buf)  = @_;
      utf8::upgrade($buf);
      utf8::encode($buf);
      $self->add_content($buf);
  }
  
  sub content_ref
  {
      my $self = shift;
      $self->_content unless exists $self->{_content};
      delete $self->{_parts};
      my $old = \$self->{_content};
      my $old_cref = $self->{_content_ref};
      if (@_) {
  	my $new = shift;
  	Carp::croak("Setting content_ref to a non-ref") unless ref($new);
  	delete $self->{_content};  # avoid modifying $$old
  	$self->{_content} = $new;
  	$self->{_content_ref}++;
      }
      $old = $$old if $old_cref;
      return $old;
  }
  
  
  sub content_charset
  {
      my $self = shift;
      if (my $charset = $self->content_type_charset) {
  	return $charset;
      }
  
      # time to start guessing
      my $cref = $self->decoded_content(ref => 1, charset => "none");
  
      # Unicode BOM
      for ($$cref) {
  	return "UTF-8"     if /^\xEF\xBB\xBF/;
  	return "UTF-32-LE" if /^\xFF\xFE\x00\x00/;
  	return "UTF-32-BE" if /^\x00\x00\xFE\xFF/;
  	return "UTF-16-LE" if /^\xFF\xFE/;
  	return "UTF-16-BE" if /^\xFE\xFF/;
      }
  
      if ($self->content_is_xml) {
  	# http://www.w3.org/TR/2006/REC-xml-20060816/#sec-guessing
  	# XML entity not accompanied by external encoding information and not
  	# in UTF-8 or UTF-16 encoding must begin with an XML encoding declaration,
  	# in which the first characters must be '<?xml'
  	for ($$cref) {
  	    return "UTF-32-BE" if /^\x00\x00\x00</;
  	    return "UTF-32-LE" if /^<\x00\x00\x00/;
  	    return "UTF-16-BE" if /^(?:\x00\s)*\x00</;
  	    return "UTF-16-LE" if /^(?:\s\x00)*<\x00/;
  	    if (/^\s*(<\?xml[^\x00]*?\?>)/) {
  		if ($1 =~ /\sencoding\s*=\s*(["'])(.*?)\1/) {
  		    my $enc = $2;
  		    $enc =~ s/^\s+//; $enc =~ s/\s+\z//;
  		    return $enc if $enc;
  		}
  	    }
  	}
  	return "UTF-8";
      }
      elsif ($self->content_is_html) {
  	# look for <META charset="..."> or <META content="...">
  	# http://dev.w3.org/html5/spec/Overview.html#determining-the-character-encoding
  	my $charset;
  	require HTML::Parser;
  	my $p = HTML::Parser->new(
  	    start_h => [sub {
  		my($tag, $attr, $self) = @_;
  		$charset = $attr->{charset};
  		unless ($charset) {
  		    # look at $attr->{content} ...
  		    if (my $c = $attr->{content}) {
  			require HTTP::Headers::Util;
  			my @v = HTTP::Headers::Util::split_header_words($c);
  			return unless @v;
  			my($ct, undef, %ct_param) = @{$v[0]};
  			$charset = $ct_param{charset};
  		    }
  		    return unless $charset;
  		}
  		if ($charset =~ /^utf-?16/i) {
  		    # converted document, assume UTF-8
  		    $charset = "UTF-8";
  		}
  		$self->eof;
  	    }, "tagname, attr, self"],
  	    report_tags => [qw(meta)],
  	    utf8_mode => 1,
  	);
  	$p->parse($$cref);
  	return $charset if $charset;
      }
      if ($self->content_type =~ /^text\//) {
  	for ($$cref) {
  	    if (length) {
  		return "US-ASCII" unless /[\x80-\xFF]/;
  		require Encode;
  		eval {
  		    Encode::decode_utf8($_, Encode::FB_CROAK());
  		};
  		return "UTF-8" unless $@;
  		return "ISO-8859-1";
  	    }
  	}
      }
  
      return undef;
  }
  
  
  sub decoded_content
  {
      my($self, %opt) = @_;
      my $content_ref;
      my $content_ref_iscopy;
  
      eval {
  	$content_ref = $self->content_ref;
  	die "Can't decode ref content" if ref($content_ref) ne "SCALAR";
  
  	if (my $h = $self->header("Content-Encoding")) {
  	    $h =~ s/^\s+//;
  	    $h =~ s/\s+$//;
  	    for my $ce (reverse split(/\s*,\s*/, lc($h))) {
  		next unless $ce;
  		next if $ce eq "identity";
  		if ($ce eq "gzip" || $ce eq "x-gzip") {
  		    require IO::Uncompress::Gunzip;
  		    my $output;
  		    IO::Uncompress::Gunzip::gunzip($content_ref, \$output, Transparent => 0)
  			or die "Can't gunzip content: $IO::Uncompress::Gunzip::GunzipError";
  		    $content_ref = \$output;
  		    $content_ref_iscopy++;
  		}
  		elsif ($ce eq "x-bzip2") {
  		    require IO::Uncompress::Bunzip2;
  		    my $output;
  		    IO::Uncompress::Bunzip2::bunzip2($content_ref, \$output, Transparent => 0)
  			or die "Can't bunzip content: $IO::Uncompress::Bunzip2::Bunzip2Error";
  		    $content_ref = \$output;
  		    $content_ref_iscopy++;
  		}
  		elsif ($ce eq "deflate") {
  		    require IO::Uncompress::Inflate;
  		    my $output;
  		    my $status = IO::Uncompress::Inflate::inflate($content_ref, \$output, Transparent => 0);
  		    my $error = $IO::Uncompress::Inflate::InflateError;
  		    unless ($status) {
  			# "Content-Encoding: deflate" is supposed to mean the
  			# "zlib" format of RFC 1950, but Microsoft got that
  			# wrong, so some servers sends the raw compressed
  			# "deflate" data.  This tries to inflate this format.
  			$output = undef;
  			require IO::Uncompress::RawInflate;
  			unless (IO::Uncompress::RawInflate::rawinflate($content_ref, \$output)) {
  			    $self->push_header("Client-Warning" =>
  				"Could not raw inflate content: $IO::Uncompress::RawInflate::RawInflateError");
  			    $output = undef;
  			}
  		    }
  		    die "Can't inflate content: $error" unless defined $output;
  		    $content_ref = \$output;
  		    $content_ref_iscopy++;
  		}
  		elsif ($ce eq "compress" || $ce eq "x-compress") {
  		    die "Can't uncompress content";
  		}
  		elsif ($ce eq "base64") {  # not really C-T-E, but should be harmless
  		    require MIME::Base64;
  		    $content_ref = \MIME::Base64::decode($$content_ref);
  		    $content_ref_iscopy++;
  		}
  		elsif ($ce eq "quoted-printable") { # not really C-T-E, but should be harmless
  		    require MIME::QuotedPrint;
  		    $content_ref = \MIME::QuotedPrint::decode($$content_ref);
  		    $content_ref_iscopy++;
  		}
  		else {
  		    die "Don't know how to decode Content-Encoding '$ce'";
  		}
  	    }
  	}
  
  	if ($self->content_is_text || (my $is_xml = $self->content_is_xml)) {
  	    my $charset = lc(
  	        $opt{charset} ||
  		$self->content_type_charset ||
  		$opt{default_charset} ||
  		$self->content_charset ||
  		"ISO-8859-1"
  	    );
  	    unless ($charset =~ /^(?:none|us-ascii|iso-8859-1)\z/) {
  		require Encode;
  		if (do{my $v = $Encode::VERSION; $v =~ s/_//g; $v} < 2.0901 &&
  		    !$content_ref_iscopy)
  		{
  		    # LEAVE_SRC did not work before Encode-2.0901
  		    my $copy = $$content_ref;
  		    $content_ref = \$copy;
  		    $content_ref_iscopy++;
  		}
  		eval {
  		    $content_ref = \Encode::decode($charset, $$content_ref,
  			 ($opt{charset_strict} ? Encode::FB_CROAK() : 0) | Encode::LEAVE_SRC());
  		};
  		if ($@) {
  		    my $retried;
  		    if ($@ =~ /^Unknown encoding/) {
  			my $alt_charset = lc($opt{alt_charset} || "");
  			if ($alt_charset && $charset ne $alt_charset) {
  			    # Retry decoding with the alternative charset
  			    $content_ref = \Encode::decode($alt_charset, $$content_ref,
  				 ($opt{charset_strict} ? Encode::FB_CROAK() : 0) | Encode::LEAVE_SRC())
  			        unless $alt_charset =~ /^(?:none|us-ascii|iso-8859-1)\z/;
  			    $retried++;
  			}
  		    }
  		    die unless $retried;
  		}
  		die "Encode::decode() returned undef improperly" unless defined $$content_ref;
  		if ($is_xml) {
  		    # Get rid of the XML encoding declaration if present
  		    $$content_ref =~ s/^\x{FEFF}//;
  		    if ($$content_ref =~ /^(\s*<\?xml[^\x00]*?\?>)/) {
  			substr($$content_ref, 0, length($1)) =~ s/\sencoding\s*=\s*(["']).*?\1//;
  		    }
  		}
  	    }
  	}
      };
      if ($@) {
  	Carp::croak($@) if $opt{raise_error};
  	return undef;
      }
  
      return $opt{ref} ? $content_ref : $$content_ref;
  }
  
  
  sub decodable
  {
      # should match the Content-Encoding values that decoded_content can deal with
      my $self = shift;
      my @enc;
      # XXX preferably we should determine if the modules are available without loading
      # them here
      eval {
          require IO::Uncompress::Gunzip;
          push(@enc, "gzip", "x-gzip");
      };
      eval {
          require IO::Uncompress::Inflate;
          require IO::Uncompress::RawInflate;
          push(@enc, "deflate");
      };
      eval {
          require IO::Uncompress::Bunzip2;
          push(@enc, "x-bzip2");
      };
      # we don't care about announcing the 'identity', 'base64' and
      # 'quoted-printable' stuff
      return wantarray ? @enc : join(", ", @enc);
  }
  
  
  sub decode
  {
      my $self = shift;
      return 1 unless $self->header("Content-Encoding");
      if (defined(my $content = $self->decoded_content(charset => "none"))) {
  	$self->remove_header("Content-Encoding", "Content-Length", "Content-MD5");
  	$self->content($content);
  	return 1;
      }
      return 0;
  }
  
  
  sub encode
  {
      my($self, @enc) = @_;
  
      Carp::croak("Can't encode multipart/* messages") if $self->content_type =~ m,^multipart/,;
      Carp::croak("Can't encode message/* messages") if $self->content_type =~ m,^message/,;
  
      return 1 unless @enc;  # nothing to do
  
      my $content = $self->content;
      for my $encoding (@enc) {
  	if ($encoding eq "identity") {
  	    # nothing to do
  	}
  	elsif ($encoding eq "base64") {
  	    require MIME::Base64;
  	    $content = MIME::Base64::encode($content);
  	}
  	elsif ($encoding eq "gzip" || $encoding eq "x-gzip") {
  	    require IO::Compress::Gzip;
  	    my $output;
  	    IO::Compress::Gzip::gzip(\$content, \$output, Minimal => 1)
  		or die "Can't gzip content: $IO::Compress::Gzip::GzipError";
  	    $content = $output;
  	}
  	elsif ($encoding eq "deflate") {
  	    require IO::Compress::Deflate;
  	    my $output;
  	    IO::Compress::Deflate::deflate(\$content, \$output)
  		or die "Can't deflate content: $IO::Compress::Deflate::DeflateError";
  	    $content = $output;
  	}
  	elsif ($encoding eq "x-bzip2") {
  	    require IO::Compress::Bzip2;
  	    my $output;
  	    IO::Compress::Bzip2::bzip2(\$content, \$output)
  		or die "Can't bzip2 content: $IO::Compress::Bzip2::Bzip2Error";
  	    $content = $output;
  	}
  	elsif ($encoding eq "rot13") {  # for the fun of it
  	    $content =~ tr/A-Za-z/N-ZA-Mn-za-m/;
  	}
  	else {
  	    return 0;
  	}
      }
      my $h = $self->header("Content-Encoding");
      unshift(@enc, $h) if $h;
      $self->header("Content-Encoding", join(", ", @enc));
      $self->remove_header("Content-Length", "Content-MD5");
      $self->content($content);
      return 1;
  }
  
  
  sub as_string
  {
      my($self, $eol) = @_;
      $eol = "\n" unless defined $eol;
  
      # The calculation of content might update the headers
      # so we need to do that first.
      my $content = $self->content;
  
      return join("", $self->{'_headers'}->as_string($eol),
  		    $eol,
  		    $content,
  		    (@_ == 1 && length($content) &&
  		     $content !~ /\n\z/) ? "\n" : "",
  		);
  }
  
  
  sub dump
  {
      my($self, %opt) = @_;
      my $content = $self->content;
      my $chopped = 0;
      if (!ref($content)) {
  	my $maxlen = $opt{maxlength};
  	$maxlen = 512 unless defined($maxlen);
  	if ($maxlen && length($content) > $maxlen * 1.1 + 3) {
  	    $chopped = length($content) - $maxlen;
  	    $content = substr($content, 0, $maxlen) . "...";
  	}
  
  	$content =~ s/\\/\\\\/g;
  	$content =~ s/\t/\\t/g;
  	$content =~ s/\r/\\r/g;
  
  	# no need for 3 digits in escape for these
  	$content =~ s/([\0-\11\13-\037])(?!\d)/sprintf('\\%o',ord($1))/eg;
  
  	$content =~ s/([\0-\11\13-\037\177-\377])/sprintf('\\x%02X',ord($1))/eg;
  	$content =~ s/([^\12\040-\176])/sprintf('\\x{%X}',ord($1))/eg;
  
  	# remaining whitespace
  	$content =~ s/( +)\n/("\\40" x length($1)) . "\n"/eg;
  	$content =~ s/(\n+)\n/("\\n" x length($1)) . "\n"/eg;
  	$content =~ s/\n\z/\\n/;
  
  	my $no_content = "(no content)";
  	if ($content eq $no_content) {
  	    # escape our $no_content marker
  	    $content =~ s/^(.)/sprintf('\\x%02X',ord($1))/eg;
  	}
  	elsif ($content eq "") {
  	    $content = "(no content)";
  	}
      }
  
      my @dump;
      push(@dump, $opt{preheader}) if $opt{preheader};
      push(@dump, $self->{_headers}->as_string, $content);
      push(@dump, "(+ $chopped more bytes not shown)") if $chopped;
  
      my $dump = join("\n", @dump, "");
      $dump =~ s/^/$opt{prefix}/gm if $opt{prefix};
  
      print $dump unless defined wantarray;
      return $dump;
  }
  
  
  sub parts {
      my $self = shift;
      if (defined(wantarray) && (!exists $self->{_parts} || ref($self->{_content}) eq "SCALAR")) {
  	$self->_parts;
      }
      my $old = $self->{_parts};
      if (@_) {
  	my @parts = map { ref($_) eq 'ARRAY' ? @$_ : $_ } @_;
  	my $ct = $self->content_type || "";
  	if ($ct =~ m,^message/,) {
  	    Carp::croak("Only one part allowed for $ct content")
  		if @parts > 1;
  	}
  	elsif ($ct !~ m,^multipart/,) {
  	    $self->remove_content_headers;
  	    $self->content_type("multipart/mixed");
  	}
  	$self->{_parts} = \@parts;
  	_stale_content($self);
      }
      return @$old if wantarray;
      return $old->[0];
  }
  
  sub add_part {
      my $self = shift;
      if (($self->content_type || "") !~ m,^multipart/,) {
  	my $p = HTTP::Message->new($self->remove_content_headers,
  				   $self->content(""));
  	$self->content_type("multipart/mixed");
  	$self->{_parts} = [];
          if ($p->headers->header_field_names || $p->content ne "") {
              push(@{$self->{_parts}}, $p);
          }
      }
      elsif (!exists $self->{_parts} || ref($self->{_content}) eq "SCALAR") {
  	$self->_parts;
      }
  
      push(@{$self->{_parts}}, @_);
      _stale_content($self);
      return;
  }
  
  sub _stale_content {
      my $self = shift;
      if (ref($self->{_content}) eq "SCALAR") {
  	# must recalculate now
  	$self->_content;
      }
      else {
  	# just invalidate cache
  	delete $self->{_content};
  	delete $self->{_content_ref};
      }
  }
  
  
  # delegate all other method calls the the headers object.
  sub AUTOLOAD
  {
      my $method = substr($AUTOLOAD, rindex($AUTOLOAD, '::')+2);
  
      # We create the function here so that it will not need to be
      # autoloaded the next time.
      no strict 'refs';
      *$method = sub { shift->headers->$method(@_) };
      goto &$method;
  }
  
  
  sub DESTROY {}  # avoid AUTOLOADing it
  
  
  # Private method to access members in %$self
  sub _elem
  {
      my $self = shift;
      my $elem = shift;
      my $old = $self->{$elem};
      $self->{$elem} = $_[0] if @_;
      return $old;
  }
  
  
  # Create private _parts attribute from current _content
  sub _parts {
      my $self = shift;
      my $ct = $self->content_type;
      if ($ct =~ m,^multipart/,) {
  	require HTTP::Headers::Util;
  	my @h = HTTP::Headers::Util::split_header_words($self->header("Content-Type"));
  	die "Assert" unless @h;
  	my %h = @{$h[0]};
  	if (defined(my $b = $h{boundary})) {
  	    my $str = $self->content;
  	    $str =~ s/\r?\n--\Q$b\E--\r?\n.*//s;
  	    if ($str =~ s/(^|.*?\r?\n)--\Q$b\E\r?\n//s) {
  		$self->{_parts} = [map HTTP::Message->parse($_),
  				   split(/\r?\n--\Q$b\E\r?\n/, $str)]
  	    }
  	}
      }
      elsif ($ct eq "message/http") {
  	require HTTP::Request;
  	require HTTP::Response;
  	my $content = $self->content;
  	my $class = ($content =~ m,^(HTTP/.*)\n,) ?
  	    "HTTP::Response" : "HTTP::Request";
  	$self->{_parts} = [$class->parse($content)];
      }
      elsif ($ct =~ m,^message/,) {
  	$self->{_parts} = [ HTTP::Message->parse($self->content) ];
      }
  
      $self->{_parts} ||= [];
  }
  
  
  # Create private _content attribute from current _parts
  sub _content {
      my $self = shift;
      my $ct = $self->{_headers}->header("Content-Type") || "multipart/mixed";
      if ($ct =~ m,^\s*message/,i) {
  	_set_content($self, $self->{_parts}[0]->as_string($CRLF), 1);
  	return;
      }
  
      require HTTP::Headers::Util;
      my @v = HTTP::Headers::Util::split_header_words($ct);
      Carp::carp("Multiple Content-Type headers") if @v > 1;
      @v = @{$v[0]};
  
      my $boundary;
      my $boundary_index;
      for (my @tmp = @v; @tmp;) {
  	my($k, $v) = splice(@tmp, 0, 2);
  	if ($k eq "boundary") {
  	    $boundary = $v;
  	    $boundary_index = @v - @tmp - 1;
  	    last;
  	}
      }
  
      my @parts = map $_->as_string($CRLF), @{$self->{_parts}};
  
      my $bno = 0;
      $boundary = _boundary() unless defined $boundary;
   CHECK_BOUNDARY:
      {
  	for (@parts) {
  	    if (index($_, $boundary) >= 0) {
  		# must have a better boundary
  		$boundary = _boundary(++$bno);
  		redo CHECK_BOUNDARY;
  	    }
  	}
      }
  
      if ($boundary_index) {
  	$v[$boundary_index] = $boundary;
      }
      else {
  	push(@v, boundary => $boundary);
      }
  
      $ct = HTTP::Headers::Util::join_header_words(@v);
      $self->{_headers}->header("Content-Type", $ct);
  
      _set_content($self, "--$boundary$CRLF" .
  	                join("$CRLF--$boundary$CRLF", @parts) .
  			"$CRLF--$boundary--$CRLF",
                          1);
  }
  
  
  sub _boundary
  {
      my $size = shift || return "xYzZY";
      require MIME::Base64;
      my $b = MIME::Base64::encode(join("", map chr(rand(256)), 1..$size*3), "");
      $b =~ s/[\W]/X/g;  # ensure alnum only
      $b;
  }
  
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  HTTP::Message - HTTP style message (base class)
  
  =head1 SYNOPSIS
  
   use base 'HTTP::Message';
  
  =head1 DESCRIPTION
  
  An C<HTTP::Message> object contains some headers and a content body.
  The following methods are available:
  
  =over 4
  
  =item $mess = HTTP::Message->new
  
  =item $mess = HTTP::Message->new( $headers )
  
  =item $mess = HTTP::Message->new( $headers, $content )
  
  This constructs a new message object.  Normally you would want
  construct C<HTTP::Request> or C<HTTP::Response> objects instead.
  
  The optional $header argument should be a reference to an
  C<HTTP::Headers> object or a plain array reference of key/value pairs.
  If an C<HTTP::Headers> object is provided then a copy of it will be
  embedded into the constructed message, i.e. it will not be owned and
  can be modified afterwards without affecting the message.
  
  The optional $content argument should be a string of bytes.
  
  =item $mess = HTTP::Message->parse( $str )
  
  This constructs a new message object by parsing the given string.
  
  =item $mess->headers
  
  Returns the embedded C<HTTP::Headers> object.
  
  =item $mess->headers_as_string
  
  =item $mess->headers_as_string( $eol )
  
  Call the as_string() method for the headers in the
  message.  This will be the same as
  
      $mess->headers->as_string
  
  but it will make your program a whole character shorter :-)
  
  =item $mess->content
  
  =item $mess->content( $bytes )
  
  The content() method sets the raw content if an argument is given.  If no
  argument is given the content is not touched.  In either case the
  original raw content is returned.
  
  Note that the content should be a string of bytes.  Strings in perl
  can contain characters outside the range of a byte.  The C<Encode>
  module can be used to turn such strings into a string of bytes.
  
  =item $mess->add_content( $bytes )
  
  The add_content() methods appends more data bytes to the end of the
  current content buffer.
  
  =item $mess->add_content_utf8( $string )
  
  The add_content_utf8() method appends the UTF-8 bytes representing the
  string to the end of the current content buffer.
  
  =item $mess->content_ref
  
  =item $mess->content_ref( \$bytes )
  
  The content_ref() method will return a reference to content buffer string.
  It can be more efficient to access the content this way if the content
  is huge, and it can even be used for direct manipulation of the content,
  for instance:
  
    ${$res->content_ref} =~ s/\bfoo\b/bar/g;
  
  This example would modify the content buffer in-place.
  
  If an argument is passed it will setup the content to reference some
  external source.  The content() and add_content() methods
  will automatically dereference scalar references passed this way.  For
  other references content() will return the reference itself and
  add_content() will refuse to do anything.
  
  =item $mess->content_charset
  
  This returns the charset used by the content in the message.  The
  charset is either found as the charset attribute of the
  C<Content-Type> header or by guessing.
  
  See L<http://www.w3.org/TR/REC-html40/charset.html#spec-char-encoding>
  for details about how charset is determined.
  
  =item $mess->decoded_content( %options )
  
  Returns the content with any C<Content-Encoding> undone and the raw
  content encoded to perl's Unicode strings.  If the C<Content-Encoding>
  or C<charset> of the message is unknown this method will fail by
  returning C<undef>.
  
  The following options can be specified.
  
  =over
  
  =item C<charset>
  
  This override the charset parameter for text content.  The value
  C<none> can used to suppress decoding of the charset.
  
  =item C<default_charset>
  
  This override the default charset guessed by content_charset() or
  if that fails "ISO-8859-1".
  
  =item C<alt_charset>
  
  If decoding fails because the charset specified in the Content-Type header
  isn't recognized by Perl's Encode module, then try decoding using this charset
  instead of failing.  The C<alt_charset> might be specified as C<none> to simply
  return the string without any decoding of charset as alternative.
  
  =item C<charset_strict>
  
  Abort decoding if malformed characters is found in the content.  By
  default you get the substitution character ("\x{FFFD}") in place of
  malformed characters.
  
  =item C<raise_error>
  
  If TRUE then raise an exception if not able to decode content.  Reason
  might be that the specified C<Content-Encoding> or C<charset> is not
  supported.  If this option is FALSE, then decoded_content() will return
  C<undef> on errors, but will still set $@.
  
  =item C<ref>
  
  If TRUE then a reference to decoded content is returned.  This might
  be more efficient in cases where the decoded content is identical to
  the raw content as no data copying is required in this case.
  
  =back
  
  =item $mess->decodable
  
  =item HTTP::Message::decodable()
  
  This returns the encoding identifiers that decoded_content() can
  process.  In scalar context returns a comma separated string of
  identifiers.
  
  This value is suitable for initializing the C<Accept-Encoding> request
  header field.
  
  =item $mess->decode
  
  This method tries to replace the content of the message with the
  decoded version and removes the C<Content-Encoding> header.  Returns
  TRUE if successful and FALSE if not.
  
  If the message does not have a C<Content-Encoding> header this method
  does nothing and returns TRUE.
  
  Note that the content of the message is still bytes after this method
  has been called and you still need to call decoded_content() if you
  want to process its content as a string.
  
  =item $mess->encode( $encoding, ... )
  
  Apply the given encodings to the content of the message.  Returns TRUE
  if successful. The "identity" (non-)encoding is always supported; other
  currently supported encodings, subject to availability of required
  additional modules, are "gzip", "deflate", "x-bzip2" and "base64".
  
  A successful call to this function will set the C<Content-Encoding>
  header.
  
  Note that C<multipart/*> or C<message/*> messages can't be encoded and
  this method will croak if you try.
  
  =item $mess->parts
  
  =item $mess->parts( @parts )
  
  =item $mess->parts( \@parts )
  
  Messages can be composite, i.e. contain other messages.  The composite
  messages have a content type of C<multipart/*> or C<message/*>.  This
  method give access to the contained messages.
  
  The argumentless form will return a list of C<HTTP::Message> objects.
  If the content type of $msg is not C<multipart/*> or C<message/*> then
  this will return the empty list.  In scalar context only the first
  object is returned.  The returned message parts should be regarded as
  read-only (future versions of this library might make it possible
  to modify the parent by modifying the parts).
  
  If the content type of $msg is C<message/*> then there will only be
  one part returned.
  
  If the content type is C<message/http>, then the return value will be
  either an C<HTTP::Request> or an C<HTTP::Response> object.
  
  If an @parts argument is given, then the content of the message will be
  modified. The array reference form is provided so that an empty list
  can be provided.  The @parts array should contain C<HTTP::Message>
  objects.  The @parts objects are owned by $mess after this call and
  should not be modified or made part of other messages.
  
  When updating the message with this method and the old content type of
  $mess is not C<multipart/*> or C<message/*>, then the content type is
  set to C<multipart/mixed> and all other content headers are cleared.
  
  This method will croak if the content type is C<message/*> and more
  than one part is provided.
  
  =item $mess->add_part( $part )
  
  This will add a part to a message.  The $part argument should be
  another C<HTTP::Message> object.  If the previous content type of
  $mess is not C<multipart/*> then the old content (together with all
  content headers) will be made part #1 and the content type made
  C<multipart/mixed> before the new part is added.  The $part object is
  owned by $mess after this call and should not be modified or made part
  of other messages.
  
  There is no return value.
  
  =item $mess->clear
  
  Will clear the headers and set the content to the empty string.  There
  is no return value
  
  =item $mess->protocol
  
  =item $mess->protocol( $proto )
  
  Sets the HTTP protocol used for the message.  The protocol() is a string
  like C<HTTP/1.0> or C<HTTP/1.1>.
  
  =item $mess->clone
  
  Returns a copy of the message object.
  
  =item $mess->as_string
  
  =item $mess->as_string( $eol )
  
  Returns the message formatted as a single string.
  
  The optional $eol parameter specifies the line ending sequence to use.
  The default is "\n".  If no $eol is given then as_string will ensure
  that the returned string is newline terminated (even when the message
  content is not).  No extra newline is appended if an explicit $eol is
  passed.
  
  =item $mess->dump( %opt )
  
  Returns the message formatted as a string.  In void context print the string.
  
  This differs from C<< $mess->as_string >> in that it escapes the bytes
  of the content so that it's safe to print them and it limits how much
  content to print.  The escapes syntax used is the same as for Perl's
  double quoted strings.  If there is no content the string "(no
  content)" is shown in its place.
  
  Options to influence the output can be passed as key/value pairs. The
  following options are recognized:
  
  =over
  
  =item maxlength => $num
  
  How much of the content to show.  The default is 512.  Set this to 0
  for unlimited.
  
  If the content is longer then the string is chopped at the limit and
  the string "...\n(### more bytes not shown)" appended.
  
  =item prefix => $str
  
  A string that will be prefixed to each line of the dump.
  
  =back
  
  =back
  
  All methods unknown to C<HTTP::Message> itself are delegated to the
  C<HTTP::Headers> object that is part of every message.  This allows
  convenient access to these methods.  Refer to L<HTTP::Headers> for
  details of these methods:
  
      $mess->header( $field => $val )
      $mess->push_header( $field => $val )
      $mess->init_header( $field => $val )
      $mess->remove_header( $field )
      $mess->remove_content_headers
      $mess->header_field_names
      $mess->scan( \&doit )
  
      $mess->date
      $mess->expires
      $mess->if_modified_since
      $mess->if_unmodified_since
      $mess->last_modified
      $mess->content_type
      $mess->content_encoding
      $mess->content_length
      $mess->content_language
      $mess->title
      $mess->user_agent
      $mess->server
      $mess->from
      $mess->referer
      $mess->www_authenticate
      $mess->authorization
      $mess->proxy_authorization
      $mess->authorization_basic
      $mess->proxy_authorization_basic
  
  =head1 COPYRIGHT
  
  Copyright 1995-2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
HTTP_MESSAGE

$fatpacked{"HTTP/Message/PSGI.pm"} = <<'HTTP_MESSAGE_PSGI';
  package HTTP::Message::PSGI;
  use strict;
  use warnings;
  use parent qw(Exporter);
  our @EXPORT = qw( req_to_psgi res_from_psgi );
  
  use Carp ();
  use URI::Escape ();
  use Plack::Util;
  use Try::Tiny;
  
  my $TRUE  = (1 == 1);
  my $FALSE = !$TRUE;
  
  sub req_to_psgi {
      my $req = shift;
  
      unless (try { $req->isa('HTTP::Request') }) {
          Carp::croak("Request is not HTTP::Request: $req");
      }
  
      # from HTTP::Request::AsCGI
      my $host = $req->header('Host');
      my $uri  = $req->uri->clone;
      $uri->scheme('http')    unless $uri->scheme;
      $uri->host('localhost') unless $uri->host;
      $uri->port(80)          unless $uri->port;
      $uri->host_port($host)  unless !$host || ( $host eq $uri->host_port );
  
      # STUPID: If the request URI is utf-8 decoded, methods like ->path
      # and ->host returns decoded strings in ascii, which causes double
      # encoded strings in uri_unescape and URI concatenation in
      # Plack::Request :/
      utf8::downgrade $$uri;
  
      my $input;
      my $content = $req->content;
      if (ref $content eq 'CODE') {
          if (defined $req->content_length) {
              $input = HTTP::Message::PSGI::ChunkedInput->new($content);
          } else {
              $req->header("Transfer-Encoding" => "chunked");
              $input = HTTP::Message::PSGI::ChunkedInput->new($content, 1);
          }
      } else {
          open $input, "<", \$content;
      }
  
      my $env = {
          PATH_INFO         => URI::Escape::uri_unescape($uri->path),
          QUERY_STRING      => $uri->query || '',
          SCRIPT_NAME       => '',
          SERVER_NAME       => $uri->host,
          SERVER_PORT       => $uri->port,
          SERVER_PROTOCOL   => $req->protocol || 'HTTP/1.1',
          REMOTE_ADDR       => '127.0.0.1',
          REMOTE_HOST       => 'localhost',
          REMOTE_PORT       => int( rand(64000) + 1000 ),                   # not in RFC 3875
          REQUEST_URI       => $uri->path_query,                            # not in RFC 3875
          REQUEST_METHOD    => $req->method,
          'psgi.version'      => [ 1, 1 ],
          'psgi.url_scheme'   => $uri->scheme eq 'https' ? 'https' : 'http',
          'psgi.input'        => $input,
          'psgi.errors'       => *STDERR,
          'psgi.multithread'  => $FALSE,
          'psgi.multiprocess' => $FALSE,
          'psgi.run_once'     => $TRUE,
          'psgi.streaming'    => $TRUE,
          'psgi.nonblocking'  => $FALSE,
          @_,
      };
  
      for my $field ( $req->headers->header_field_names ) {
          my $key = uc("HTTP_$field");
          $key =~ tr/-/_/;
          $key =~ s/^HTTP_// if $field =~ /^Content-(Length|Type)$/;
  
          unless ( exists $env->{$key} ) {
              $env->{$key} = $req->headers->header($field);
          }
      }
  
      if ($env->{SCRIPT_NAME}) {
          $env->{PATH_INFO} =~ s/^\Q$env->{SCRIPT_NAME}\E/\//;
          $env->{PATH_INFO} =~ s/^\/+/\//;
      }
  
      return $env;
  }
  
  sub res_from_psgi {
      my ($psgi_res) = @_;
  
      my $res;
      if (ref $psgi_res eq 'ARRAY') {
          _res_from_psgi($psgi_res, \$res);
      }
      elsif (ref $psgi_res eq 'CODE') {
          $psgi_res->(sub {
              _res_from_psgi($_[0], \$res);
          });
      }
  
      return $res;
  }
  
  sub _res_from_psgi {
      my ($status, $headers, $body) = @{+shift};
      my $res_ref = shift;
  
      my $convert_resp = sub {
          my $res = HTTP::Response->new($status);
          $res->headers->header(@$headers) if @$headers;
  
          if (ref $body eq 'ARRAY') {
              $res->content(join '', grep defined, @$body);
          } else {
              local $/ = \4096;
              my $content;
              while (defined(my $buf = $body->getline)) {
                  $content .= $buf;
              }
              $body->close;
              $res->content($content);
          }
  
          ${ $res_ref } = $res;
  
          return;
      };
  
      if (!defined $body) {
          my $o = Plack::Util::inline_object
              write => sub { push @{ $body ||= [] }, @_ },
              close => $convert_resp;
  
          return $o;
      }
  
      $convert_resp->();
  }
  
  sub HTTP::Request::to_psgi {
      req_to_psgi(@_);
  }
  
  sub HTTP::Response::from_psgi {
      my $class = shift;
      res_from_psgi(@_);
  }
  
  package
      HTTP::Message::PSGI::ChunkedInput;
  
  sub new {
      my($class, $content, $chunked) = @_;
  
      my $content_cb;
      if ($chunked) {
          my $done;
          $content_cb = sub {
              my $chunk = $content->();
              return if $done;
              unless (defined $chunk) {
                  $done = 1;
                  return "0\015\012\015\012";
              }
              return '' unless length $chunk;
              return sprintf('%x', length $chunk) . "\015\012$chunk\015\012";
          };
      } else {
          $content_cb = $content;
      }
  
      bless { content => $content_cb }, $class;
  }
  
  sub read {
      my $self = shift;
  
      my $chunk = $self->{content}->();
      return 0 unless defined $chunk;
  
      $_[0] = '';
      substr($_[0], $_[2] || 0, length $chunk) = $chunk;
  
      return length $chunk;
  }
  
  sub close { }
  
  package HTTP::Message::PSGI;
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Message::PSGI - Converts HTTP::Request and HTTP::Response from/to PSGI env and response
  
  =head1 SYNOPSIS
  
    use HTTP::Message::PSGI;
  
    # $req is HTTP::Request, $res is HTTP::Response
    my $env = req_to_psgi($req);
    my $res = res_from_psgi([ $status, $headers, $body ]);
  
    # Adds methods to HTTP::Request/Response class as well
    my $env = $req->to_psgi;
    my $res = HTTP::Response->from_psgi([ $status, $headers, $body ]);
  
  =head1 DESCRIPTION
  
  HTTP::Message::PSGI gives you convenient methods convert HTTP::Request
  object to PSGI env hash and convert PSGI response array ref to
  HTTP::Response object.
  
  If you want the other way round, see L<Plack::Request> and
  L<Plack::Response>.
  
  =head1 METHODS
  
  =over 4
  
  =item req_to_psgi
  
    my $env = req_to_psgi($req [, $key => $val ... ]);
  
  Converts HTTP::Request object into PSGI env hash reference.
  
  =item HTTP::Request::to_psgi
  
    my $env = $req->to_psgi;
  
  Same as C<req_to_psgi> but an instance method in L<HTTP::Request>.
  
  =item res_from_psgi
  
    my $res = res_from_psgi([ $status, $headers, $body ]);
  
  Creates HTTP::Response object from PSGI response array ref.
  
  =item HTTP::Response->from_psgi
  
    my $res = HTTP::Response->from_psgi([ $status, $headers, $body ]);
  
  Same as C<res_from_psgi> but a class method in L<HTTP::Response>.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<HTTP::Request::AsCGI> L<HTTP::Message> L<Plack::Test>
  
  =cut
  
HTTP_MESSAGE_PSGI

$fatpacked{"HTTP/Negotiate.pm"} = <<'HTTP_NEGOTIATE';
  package HTTP::Negotiate;
  
  $VERSION = "5.835";
  sub Version { $VERSION; }
  
  require 5.002;
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT = qw(choose);
  
  require HTTP::Headers;
  
  $DEBUG = 0;
  
  sub choose ($;$)
  {
      my($variants, $request) = @_;
      my(%accept);
  
      unless (defined $request) {
  	# Create a request object from the CGI environment variables
  	$request = HTTP::Headers->new;
  	$request->header('Accept', $ENV{HTTP_ACCEPT})
  	  if $ENV{HTTP_ACCEPT};
  	$request->header('Accept-Charset', $ENV{HTTP_ACCEPT_CHARSET})
  	  if $ENV{HTTP_ACCEPT_CHARSET};
  	$request->header('Accept-Encoding', $ENV{HTTP_ACCEPT_ENCODING})
  	  if $ENV{HTTP_ACCEPT_ENCODING};
  	$request->header('Accept-Language', $ENV{HTTP_ACCEPT_LANGUAGE})
  	  if $ENV{HTTP_ACCEPT_LANGUAGE};
      }
  
      # Get all Accept values from the request.  Build a hash initialized
      # like this:
      #
      #   %accept = ( type =>     { 'audio/*'     => { q => 0.2, mbx => 20000 },
      #                             'audio/basic' => { q => 1 },
      #                           },
      #               language => { 'no'          => { q => 1 },
      #                           }
      #             );
  
      $request->scan(sub {
  	my($key, $val) = @_;
  
  	my $type;
  	if ($key =~ s/^Accept-//) {
  	    $type = lc($key);
  	}
  	elsif ($key eq "Accept") {
  	    $type = "type";
  	}
  	else {
  	    return;
  	}
  
  	$val =~ s/\s+//g;
  	my $default_q = 1;
  	for my $name (split(/,/, $val)) {
  	    my(%param, $param);
  	    if ($name =~ s/;(.*)//) {
  		for $param (split(/;/, $1)) {
  		    my ($pk, $pv) = split(/=/, $param, 2);
  		    $param{lc $pk} = $pv;
  		}
  	    }
  	    $name = lc $name;
  	    if (defined $param{'q'}) {
  		$param{'q'} = 1 if $param{'q'} > 1;
  		$param{'q'} = 0 if $param{'q'} < 0;
  	    }
  	    else {
  		$param{'q'} = $default_q;
  
  		# This makes sure that the first ones are slightly better off
  		# and therefore more likely to be chosen.
  		$default_q -= 0.0001;
  	    }
  	    $accept{$type}{$name} = \%param;
  	}
      });
  
      # Check if any of the variants specify a language.  We do this
      # because it influences how we treat those without (they default to
      # 0.5 instead of 1).
      my $any_lang = 0;
      for $var (@$variants) {
  	if ($var->[5]) {
  	    $any_lang = 1;
  	    last;
  	}
      }
  
      if ($DEBUG) {
  	print "Negotiation parameters in the request\n";
  	for $type (keys %accept) {
  	    print " $type:\n";
  	    for $name (keys %{$accept{$type}}) {
  		print "    $name\n";
  		for $pv (keys %{$accept{$type}{$name}}) {
  		    print "      $pv = $accept{$type}{$name}{$pv}\n";
  		}
  	    }
  	}
      }
  
      my @Q = ();  # This is where we collect the results of the
  		 # quality calculations
  
      # Calculate quality for all the variants that are available.
      for (@$variants) {
  	my($id, $qs, $ct, $enc, $cs, $lang, $bs) = @$_;
  	$qs = 1 unless defined $qs;
          $ct = '' unless defined $ct;
  	$bs = 0 unless defined $bs;
  	$lang = lc($lang) if $lang; # lg tags are always case-insensitive
  	if ($DEBUG) {
  	    print "\nEvaluating $id (ct='$ct')\n";
  	    printf "  qs   = %.3f\n", $qs;
  	    print  "  enc  = $enc\n"  if $enc && !ref($enc);
  	    print  "  enc  = @$enc\n" if $enc && ref($enc);
  	    print  "  cs   = $cs\n"   if $cs;
  	    print  "  lang = $lang\n" if $lang;
  	    print  "  bs   = $bs\n"   if $bs;
  	}
  
  	# Calculate encoding quality
  	my $qe = 1;
  	# If the variant has no assigned Content-Encoding, or if no
  	# Accept-Encoding field is present, then the value assigned
  	# is "qe=1".  If *all* of the variant's content encodings
  	# are listed in the Accept-Encoding field, then the value
  	# assigned is "qw=1".  If *any* of the variant's content
  	# encodings are not listed in the provided Accept-Encoding
  	# field, then the value assigned is "qe=0"
  	if (exists $accept{'encoding'} && $enc) {
  	    my @enc = ref($enc) ? @$enc : ($enc);
  	    for (@enc) {
  		print "Is encoding $_ accepted? " if $DEBUG;
  		unless(exists $accept{'encoding'}{$_}) {
  		    print "no\n" if $DEBUG;
  		    $qe = 0;
  		    last;
  		}
  		else {
  		    print "yes\n" if $DEBUG;
  		}
  	    }
  	}
  
  	# Calculate charset quality
  	my $qc  = 1;
  	# If the variant's media-type has no charset parameter,
  	# or the variant's charset is US-ASCII, or if no Accept-Charset
  	# field is present, then the value assigned is "qc=1".  If the
  	# variant's charset is listed in the Accept-Charset field,
  	# then the value assigned is "qc=1.  Otherwise, if the variant's
  	# charset is not listed in the provided Accept-Encoding field,
  	# then the value assigned is "qc=0".
  	if (exists $accept{'charset'} && $cs && $cs ne 'us-ascii' ) {
  	    $qc = 0 unless $accept{'charset'}{$cs};
  	}
  
  	# Calculate language quality
  	my $ql  = 1;
  	if ($lang && exists $accept{'language'}) {
  	    my @lang = ref($lang) ? @$lang : ($lang);
  	    # If any of the variant's content languages are listed
  	    # in the Accept-Language field, the the value assigned is
  	    # the largest of the "q" parameter values for those language
  	    # tags.
  	    my $q = undef;
  	    for (@lang) {
  		next unless exists $accept{'language'}{$_};
  		my $this_q = $accept{'language'}{$_}{'q'};
  		$q = $this_q unless defined $q;
  		$q = $this_q if $this_q > $q;
  	    }
  	    if(defined $q) {
  	        $DEBUG and print " -- Exact language match at q=$q\n";
  	    }
  	    else {
  		# If there was no exact match and at least one of
  		# the Accept-Language field values is a complete
  		# subtag prefix of the content language tag(s), then
  		# the "q" parameter value of the largest matching
  		# prefix is used.
  		$DEBUG and print " -- No exact language match\n";
  		my $selected = undef;
  		for $al (keys %{ $accept{'language'} }) {
  		    if (index($al, "$lang-") == 0) {
  		        # $lang starting with $al isn't enough, or else
  		        #  Accept-Language: hu (Hungarian) would seem
  		        #  to accept a document in hup (Hupa)
  		        $DEBUG and print " -- $al ISA $lang\n";
  			$selected = $al unless defined $selected;
  			$selected = $al if length($al) > length($selected);
  		    }
  		    else {
  		        $DEBUG and print " -- $lang  isn't a $al\n";
  		    }
  		}
  		$q = $accept{'language'}{$selected}{'q'} if $selected;
  
  		# If none of the variant's content language tags or
  		# tag prefixes are listed in the provided
  		# Accept-Language field, then the value assigned
  		# is "ql=0.001"
  		$q = 0.001 unless defined $q;
  	    }
  	    $ql = $q;
  	}
  	else {
  	    $ql = 0.5 if $any_lang && exists $accept{'language'};
  	}
  
  	my $q   = 1;
  	my $mbx = undef;
  	# If no Accept field is given, then the value assigned is "q=1".
  	# If at least one listed media range matches the variant's media
  	# type, then the "q" parameter value assigned to the most specific
  	# of those matched is used (e.g. "text/html;version=3.0" is more
  	# specific than "text/html", which is more specific than "text/*",
  	# which in turn is more specific than "*/*"). If not media range
  	# in the provided Accept field matches the variant's media type,
  	# then the value assigned is "q=0".
  	if (exists $accept{'type'} && $ct) {
  	    # First we clean up our content-type
  	    $ct =~ s/\s+//g;
  	    my $params = "";
  	    $params = $1 if $ct =~ s/;(.*)//;
  	    my($type, $subtype) = split("/", $ct, 2);
  	    my %param = ();
  	    for $param (split(/;/, $params)) {
  		my($pk,$pv) = split(/=/, $param, 2);
  		$param{$pk} = $pv;
  	    }
  
  	    my $sel_q = undef;
  	    my $sel_mbx = undef;
  	    my $sel_specificness = 0;
  
  	    ACCEPT_TYPE:
  	    for $at (keys %{ $accept{'type'} }) {
  		print "Consider $at...\n" if $DEBUG;
  		my($at_type, $at_subtype) = split("/", $at, 2);
  		# Is it a match on the type
  		next if $at_type    ne '*' && $at_type    ne $type;
  		next if $at_subtype ne '*' && $at_subtype ne $subtype;
  		my $specificness = 0;
  		$specificness++ if $at_type ne '*';
  		$specificness++ if $at_subtype ne '*';
  		# Let's see if content-type parameters also match
  		while (($pk, $pv) = each %param) {
  		    print "Check if $pk = $pv is true\n" if $DEBUG;
  		    next unless exists $accept{'type'}{$at}{$pk};
  		    next ACCEPT_TYPE
  		      unless $accept{'type'}{$at}{$pk} eq $pv;
  		    print "yes it is!!\n" if $DEBUG;
  		    $specificness++;
  		}
  		print "Hurray, type match with specificness = $specificness\n"
  		  if $DEBUG;
  
  		if (!defined($sel_q) || $sel_specificness < $specificness) {
  		    $sel_q   = $accept{'type'}{$at}{'q'};
  		    $sel_mbx = $accept{'type'}{$at}{'mbx'};
  		    $sel_specificness = $specificness;
  		}
  	    }
  	    $q   = $sel_q || 0;
  	    $mbx = $sel_mbx;
  	}
  
  	my $Q;
  	if (!defined($mbx) || $mbx >= $bs) {
  	    $Q = $qs * $qe * $qc * $ql * $q;
  	}
  	else {
  	    $Q = 0;
  	    print "Variant's size is too large ==> Q=0\n" if $DEBUG;
  	}
  
  	if ($DEBUG) {
  	    $mbx = "undef" unless defined $mbx;
  	    printf "Q=%.4f", $Q;
  	    print "  (q=$q, mbx=$mbx, qe=$qe, qc=$qc, ql=$ql, qs=$qs)\n";
  	}
  
  	push(@Q, [$id, $Q, $bs]);
      }
  
  
      @Q = sort { $b->[1] <=> $a->[1] || $a->[2] <=> $b->[2] } @Q;
  
      return @Q if wantarray;
      return undef unless @Q;
      return undef if $Q[0][1] == 0;
      $Q[0][0];
  }
  
  1;
  
  __END__
  
  
  =head1 NAME
  
  HTTP::Negotiate - choose a variant to serve
  
  =head1 SYNOPSIS
  
   use HTTP::Negotiate qw(choose);
  
   #  ID       QS     Content-Type   Encoding Char-Set        Lang   Size
   $variants =
    [['var1',  1.000, 'text/html',   undef,   'iso-8859-1',   'en',   3000],
     ['var2',  0.950, 'text/plain',  'gzip',  'us-ascii',     'no',    400],
     ['var3',  0.3,   'image/gif',   undef,   undef,          undef, 43555],
    ];
  
   @preferred = choose($variants, $request_headers);
   $the_one   = choose($variants);
  
  =head1 DESCRIPTION
  
  This module provides a complete implementation of the HTTP content
  negotiation algorithm specified in F<draft-ietf-http-v11-spec-00.ps>
  chapter 12.  Content negotiation allows for the selection of a
  preferred content representation based upon attributes of the
  negotiable variants and the value of the various Accept* header fields
  in the request.
  
  The variants are ordered by preference by calling the function
  choose().
  
  The first parameter is reference to an array of the variants to
  choose among.
  Each element in this array is an array with the values [$id, $qs,
  $content_type, $content_encoding, $charset, $content_language,
  $content_length] whose meanings are described
  below. The $content_encoding and $content_language can be either a
  single scalar value or an array reference if there are several values.
  
  The second optional parameter is either a HTTP::Headers or a HTTP::Request
  object which is searched for "Accept*" headers.  If this
  parameter is missing, then the accept specification is initialized
  from the CGI environment variables HTTP_ACCEPT, HTTP_ACCEPT_CHARSET,
  HTTP_ACCEPT_ENCODING and HTTP_ACCEPT_LANGUAGE.
  
  In an array context, choose() returns a list of [variant
  identifier, calculated quality, size] tuples.  The values are sorted by
  quality, highest quality first.  If the calculated quality is the same
  for two variants, then they are sorted by size (smallest first). I<E.g.>:
  
    (['var1', 1, 2000], ['var2', 0.3, 512], ['var3', 0.3, 1024]);
  
  Note that also zero quality variants are included in the return list
  even if these should never be served to the client.
  
  In a scalar context, it returns the identifier of the variant with the
  highest score or C<undef> if none have non-zero quality.
  
  If the $HTTP::Negotiate::DEBUG variable is set to TRUE, then a lot of
  noise is generated on STDOUT during evaluation of choose().
  
  =head1 VARIANTS
  
  A variant is described by a list of the following values.  If the
  attribute does not make sense or is unknown for a variant, then use
  C<undef> instead.
  
  =over 3
  
  =item identifier
  
  This is a string that you use as the name for the variant.  This
  identifier for the preferred variants returned by choose().
  
  =item qs
  
  This is a number between 0.000 and 1.000 that describes the "source
  quality".  This is what F<draft-ietf-http-v11-spec-00.ps> says about this
  value:
  
  Source quality is measured by the content provider as representing the
  amount of degradation from the original source.  For example, a
  picture in JPEG form would have a lower qs when translated to the XBM
  format, and much lower qs when translated to an ASCII-art
  representation.  Note, however, that this is a function of the source
  - an original piece of ASCII-art may degrade in quality if it is
  captured in JPEG form.  The qs values should be assigned to each
  variant by the content provider; if no qs value has been assigned, the
  default is generally "qs=1".
  
  =item content-type
  
  This is the media type of the variant.  The media type does not
  include a charset attribute, but might contain other parameters.
  Examples are:
  
    text/html
    text/html;version=2.0
    text/plain
    image/gif
    image/jpg
  
  =item content-encoding
  
  This is one or more content encodings that has been applied to the
  variant.  The content encoding is generally used as a modifier to the
  content media type.  The most common content encodings are:
  
    gzip
    compress
  
  =item content-charset
  
  This is the character set used when the variant contains text.
  The charset value should generally be C<undef> or one of these:
  
    us-ascii
    iso-8859-1 ... iso-8859-9
    iso-2022-jp
    iso-2022-jp-2
    iso-2022-kr
    unicode-1-1
    unicode-1-1-utf-7
    unicode-1-1-utf-8
  
  =item content-language
  
  This describes one or more languages that are used in the variant.
  Language is described like this in F<draft-ietf-http-v11-spec-00.ps>: A
  language is in this context a natural language spoken, written, or
  otherwise conveyed by human beings for communication of information to
  other human beings.  Computer languages are explicitly excluded.
  
  The language tags are defined by RFC 3066.  Examples
  are:
  
    no               Norwegian
    en               International English
    en-US            US English
    en-cockney
  
  =item content-length
  
  This is the number of bytes used to represent the content.
  
  =back
  
  =head1 ACCEPT HEADERS
  
  The following Accept* headers can be used for describing content
  preferences in a request (This description is an edited extract from
  F<draft-ietf-http-v11-spec-00.ps>):
  
  =over 3
  
  =item Accept
  
  This header can be used to indicate a list of media ranges which are
  acceptable as a response to the request.  The "*" character is used to
  group media types into ranges, with "*/*" indicating all media types
  and "type/*" indicating all subtypes of that type.
  
  The parameter q is used to indicate the quality factor, which
  represents the user's preference for that range of media types.  The
  parameter mbx gives the maximum acceptable size of the response
  content. The default values are: q=1 and mbx=infinity. If no Accept
  header is present, then the client accepts all media types with q=1.
  
  For example:
  
    Accept: audio/*;q=0.2;mbx=200000, audio/basic
  
  would mean: "I prefer audio/basic (of any size), but send me any audio
  type if it is the best available after an 80% mark-down in quality and
  its size is less than 200000 bytes"
  
  
  =item Accept-Charset
  
  Used to indicate what character sets are acceptable for the response.
  The "us-ascii" character set is assumed to be acceptable for all user
  agents.  If no Accept-Charset field is given, the default is that any
  charset is acceptable.  Example:
  
    Accept-Charset: iso-8859-1, unicode-1-1
  
  
  =item Accept-Encoding
  
  Restricts the Content-Encoding values which are acceptable in the
  response.  If no Accept-Encoding field is present, the server may
  assume that the client will accept any content encoding.  An empty
  Accept-Encoding means that no content encoding is acceptable.  Example:
  
    Accept-Encoding: compress, gzip
  
  
  =item Accept-Language
  
  This field is similar to Accept, but restricts the set of natural
  languages that are preferred in a response.  Each language may be
  given an associated quality value which represents an estimate of the
  user's comprehension of that language.  For example:
  
    Accept-Language: no, en-gb;q=0.8, de;q=0.55
  
  would mean: "I prefer Norwegian, but will accept British English (with
  80% comprehension) or German (with 55% comprehension).
  
  =back
  
  
  =head1 COPYRIGHT
  
  Copyright 1996,2001 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =head1 AUTHOR
  
  Gisle Aas <gisle@aas.no>
  
  =cut
HTTP_NEGOTIATE

$fatpacked{"HTTP/Request.pm"} = <<'HTTP_REQUEST';
  package HTTP::Request;
  
  require HTTP::Message;
  @ISA = qw(HTTP::Message);
  $VERSION = "5.827";
  
  use strict;
  
  
  
  sub new
  {
      my($class, $method, $uri, $header, $content) = @_;
      my $self = $class->SUPER::new($header, $content);
      $self->method($method);
      $self->uri($uri);
      $self;
  }
  
  
  sub parse
  {
      my($class, $str) = @_;
      my $request_line;
      if ($str =~ s/^(.*)\n//) {
  	$request_line = $1;
      }
      else {
  	$request_line = $str;
  	$str = "";
      }
  
      my $self = $class->SUPER::parse($str);
      my($method, $uri, $protocol) = split(' ', $request_line);
      $self->method($method) if defined($method);
      $self->uri($uri) if defined($uri);
      $self->protocol($protocol) if $protocol;
      $self;
  }
  
  
  sub clone
  {
      my $self = shift;
      my $clone = bless $self->SUPER::clone, ref($self);
      $clone->method($self->method);
      $clone->uri($self->uri);
      $clone;
  }
  
  
  sub method
  {
      shift->_elem('_method', @_);
  }
  
  
  sub uri
  {
      my $self = shift;
      my $old = $self->{'_uri'};
      if (@_) {
  	my $uri = shift;
  	if (!defined $uri) {
  	    # that's ok
  	}
  	elsif (ref $uri) {
  	    Carp::croak("A URI can't be a " . ref($uri) . " reference")
  		if ref($uri) eq 'HASH' or ref($uri) eq 'ARRAY';
  	    Carp::croak("Can't use a " . ref($uri) . " object as a URI")
  		unless $uri->can('scheme');
  	    $uri = $uri->clone;
  	    unless ($HTTP::URI_CLASS eq "URI") {
  		# Argh!! Hate this... old LWP legacy!
  		eval { local $SIG{__DIE__}; $uri = $uri->abs; };
  		die $@ if $@ && $@ !~ /Missing base argument/;
  	    }
  	}
  	else {
  	    $uri = $HTTP::URI_CLASS->new($uri);
  	}
  	$self->{'_uri'} = $uri;
          delete $self->{'_uri_canonical'};
      }
      $old;
  }
  
  *url = \&uri;  # legacy
  
  sub uri_canonical
  {
      my $self = shift;
      return $self->{'_uri_canonical'} ||= $self->{'_uri'}->canonical;
  }
  
  
  sub accept_decodable
  {
      my $self = shift;
      $self->header("Accept-Encoding", scalar($self->decodable));
  }
  
  sub as_string
  {
      my $self = shift;
      my($eol) = @_;
      $eol = "\n" unless defined $eol;
  
      my $req_line = $self->method || "-";
      my $uri = $self->uri;
      $uri = (defined $uri) ? $uri->as_string : "-";
      $req_line .= " $uri";
      my $proto = $self->protocol;
      $req_line .= " $proto" if $proto;
  
      return join($eol, $req_line, $self->SUPER::as_string(@_));
  }
  
  sub dump
  {
      my $self = shift;
      my @pre = ($self->method || "-", $self->uri || "-");
      if (my $prot = $self->protocol) {
  	push(@pre, $prot);
      }
  
      return $self->SUPER::dump(
          preheader => join(" ", @pre),
  	@_,
      );
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Request - HTTP style request message
  
  =head1 SYNOPSIS
  
   require HTTP::Request;
   $request = HTTP::Request->new(GET => 'http://www.example.com/');
  
  and usually used like this:
  
   $ua = LWP::UserAgent->new;
   $response = $ua->request($request);
  
  =head1 DESCRIPTION
  
  C<HTTP::Request> is a class encapsulating HTTP style requests,
  consisting of a request line, some headers, and a content body. Note
  that the LWP library uses HTTP style requests even for non-HTTP
  protocols.  Instances of this class are usually passed to the
  request() method of an C<LWP::UserAgent> object.
  
  C<HTTP::Request> is a subclass of C<HTTP::Message> and therefore
  inherits its methods.  The following additional methods are available:
  
  =over 4
  
  =item $r = HTTP::Request->new( $method, $uri )
  
  =item $r = HTTP::Request->new( $method, $uri, $header )
  
  =item $r = HTTP::Request->new( $method, $uri, $header, $content )
  
  Constructs a new C<HTTP::Request> object describing a request on the
  object $uri using method $method.  The $method argument must be a
  string.  The $uri argument can be either a string, or a reference to a
  C<URI> object.  The optional $header argument should be a reference to
  an C<HTTP::Headers> object or a plain array reference of key/value
  pairs.  The optional $content argument should be a string of bytes.
  
  =item $r = HTTP::Request->parse( $str )
  
  This constructs a new request object by parsing the given string.
  
  =item $r->method
  
  =item $r->method( $val )
  
  This is used to get/set the method attribute.  The method should be a
  short string like "GET", "HEAD", "PUT" or "POST".
  
  =item $r->uri
  
  =item $r->uri( $val )
  
  This is used to get/set the uri attribute.  The $val can be a
  reference to a URI object or a plain string.  If a string is given,
  then it should be parseable as an absolute URI.
  
  =item $r->header( $field )
  
  =item $r->header( $field => $value )
  
  This is used to get/set header values and it is inherited from
  C<HTTP::Headers> via C<HTTP::Message>.  See L<HTTP::Headers> for
  details and other similar methods that can be used to access the
  headers.
  
  =item $r->accept_decodable
  
  This will set the C<Accept-Encoding> header to the list of encodings
  that decoded_content() can decode.
  
  =item $r->content
  
  =item $r->content( $bytes )
  
  This is used to get/set the content and it is inherited from the
  C<HTTP::Message> base class.  See L<HTTP::Message> for details and
  other methods that can be used to access the content.
  
  Note that the content should be a string of bytes.  Strings in perl
  can contain characters outside the range of a byte.  The C<Encode>
  module can be used to turn such strings into a string of bytes.
  
  =item $r->as_string
  
  =item $r->as_string( $eol )
  
  Method returning a textual representation of the request.
  
  =back
  
  =head1 SEE ALSO
  
  L<HTTP::Headers>, L<HTTP::Message>, L<HTTP::Request::Common>,
  L<HTTP::Response>
  
  =head1 COPYRIGHT
  
  Copyright 1995-2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
HTTP_REQUEST

$fatpacked{"HTTP/Request/Common.pm"} = <<'HTTP_REQUEST_COMMON';
  package HTTP::Request::Common;
  
  use strict;
  use vars qw(@EXPORT @EXPORT_OK $VERSION $DYNAMIC_FILE_UPLOAD);
  
  $DYNAMIC_FILE_UPLOAD ||= 0;  # make it defined (don't know why)
  
  require Exporter;
  *import = \&Exporter::import;
  @EXPORT =qw(GET HEAD PUT POST);
  @EXPORT_OK = qw($DYNAMIC_FILE_UPLOAD DELETE);
  
  require HTTP::Request;
  use Carp();
  
  $VERSION = "5.824";
  
  my $CRLF = "\015\012";   # "\r\n" is not portable
  
  sub GET  { _simple_req('GET',  @_); }
  sub HEAD { _simple_req('HEAD', @_); }
  sub PUT  { _simple_req('PUT' , @_); }
  sub DELETE { _simple_req('DELETE', @_); }
  
  sub POST
  {
      my $url = shift;
      my $req = HTTP::Request->new(POST => $url);
      my $content;
      $content = shift if @_ and ref $_[0];
      my($k, $v);
      while (($k,$v) = splice(@_, 0, 2)) {
  	if (lc($k) eq 'content') {
  	    $content = $v;
  	}
  	else {
  	    $req->push_header($k, $v);
  	}
      }
      my $ct = $req->header('Content-Type');
      unless ($ct) {
  	$ct = 'application/x-www-form-urlencoded';
      }
      elsif ($ct eq 'form-data') {
  	$ct = 'multipart/form-data';
      }
  
      if (ref $content) {
  	if ($ct =~ m,^multipart/form-data\s*(;|$),i) {
  	    require HTTP::Headers::Util;
  	    my @v = HTTP::Headers::Util::split_header_words($ct);
  	    Carp::carp("Multiple Content-Type headers") if @v > 1;
  	    @v = @{$v[0]};
  
  	    my $boundary;
  	    my $boundary_index;
  	    for (my @tmp = @v; @tmp;) {
  		my($k, $v) = splice(@tmp, 0, 2);
  		if ($k eq "boundary") {
  		    $boundary = $v;
  		    $boundary_index = @v - @tmp - 1;
  		    last;
  		}
  	    }
  
  	    ($content, $boundary) = form_data($content, $boundary, $req);
  
  	    if ($boundary_index) {
  		$v[$boundary_index] = $boundary;
  	    }
  	    else {
  		push(@v, boundary => $boundary);
  	    }
  
  	    $ct = HTTP::Headers::Util::join_header_words(@v);
  	}
  	else {
  	    # We use a temporary URI object to format
  	    # the application/x-www-form-urlencoded content.
  	    require URI;
  	    my $url = URI->new('http:');
  	    $url->query_form(ref($content) eq "HASH" ? %$content : @$content);
  	    $content = $url->query;
  	}
      }
  
      $req->header('Content-Type' => $ct);  # might be redundant
      if (defined($content)) {
  	$req->header('Content-Length' =>
  		     length($content)) unless ref($content);
  	$req->content($content);
      }
      else {
          $req->header('Content-Length' => 0);
      }
      $req;
  }
  
  
  sub _simple_req
  {
      my($method, $url) = splice(@_, 0, 2);
      my $req = HTTP::Request->new($method => $url);
      my($k, $v);
      my $content;
      while (($k,$v) = splice(@_, 0, 2)) {
  	if (lc($k) eq 'content') {
  	    $req->add_content($v);
              $content++;
  	}
  	else {
  	    $req->push_header($k, $v);
  	}
      }
      if ($content && !defined($req->header("Content-Length"))) {
          $req->header("Content-Length", length(${$req->content_ref}));
      }
      $req;
  }
  
  
  sub form_data   # RFC1867
  {
      my($data, $boundary, $req) = @_;
      my @data = ref($data) eq "HASH" ? %$data : @$data;  # copy
      my $fhparts;
      my @parts;
      my($k,$v);
      while (($k,$v) = splice(@data, 0, 2)) {
  	if (!ref($v)) {
  	    $k =~ s/([\\\"])/\\$1/g;  # escape quotes and backslashes
  	    push(@parts,
  		 qq(Content-Disposition: form-data; name="$k"$CRLF$CRLF$v));
  	}
  	else {
  	    my($file, $usename, @headers) = @$v;
  	    unless (defined $usename) {
  		$usename = $file;
  		$usename =~ s,.*/,, if defined($usename);
  	    }
              $k =~ s/([\\\"])/\\$1/g;
  	    my $disp = qq(form-data; name="$k");
              if (defined($usename) and length($usename)) {
                  $usename =~ s/([\\\"])/\\$1/g;
                  $disp .= qq(; filename="$usename");
              }
  	    my $content = "";
  	    my $h = HTTP::Headers->new(@headers);
  	    if ($file) {
  		open(my $fh, "<", $file) or Carp::croak("Can't open file $file: $!");
  		binmode($fh);
  		if ($DYNAMIC_FILE_UPLOAD) {
  		    # will read file later, close it now in order to
                      # not accumulate to many open file handles
                      close($fh);
  		    $content = \$file;
  		}
  		else {
  		    local($/) = undef; # slurp files
  		    $content = <$fh>;
  		    close($fh);
  		}
  		unless ($h->header("Content-Type")) {
  		    require LWP::MediaTypes;
  		    LWP::MediaTypes::guess_media_type($file, $h);
  		}
  	    }
  	    if ($h->header("Content-Disposition")) {
  		# just to get it sorted first
  		$disp = $h->header("Content-Disposition");
  		$h->remove_header("Content-Disposition");
  	    }
  	    if ($h->header("Content")) {
  		$content = $h->header("Content");
  		$h->remove_header("Content");
  	    }
  	    my $head = join($CRLF, "Content-Disposition: $disp",
  			           $h->as_string($CRLF),
  			           "");
  	    if (ref $content) {
  		push(@parts, [$head, $$content]);
  		$fhparts++;
  	    }
  	    else {
  		push(@parts, $head . $content);
  	    }
  	}
      }
      return ("", "none") unless @parts;
  
      my $content;
      if ($fhparts) {
  	$boundary = boundary(10) # hopefully enough randomness
  	    unless $boundary;
  
  	# add the boundaries to the @parts array
  	for (1..@parts-1) {
  	    splice(@parts, $_*2-1, 0, "$CRLF--$boundary$CRLF");
  	}
  	unshift(@parts, "--$boundary$CRLF");
  	push(@parts, "$CRLF--$boundary--$CRLF");
  
  	# See if we can generate Content-Length header
  	my $length = 0;
  	for (@parts) {
  	    if (ref $_) {
  	 	my ($head, $f) = @$_;
  		my $file_size;
  		unless ( -f $f && ($file_size = -s _) ) {
  		    # The file is either a dynamic file like /dev/audio
  		    # or perhaps a file in the /proc file system where
  		    # stat may return a 0 size even though reading it
  		    # will produce data.  So we cannot make
  		    # a Content-Length header.  
  		    undef $length;
  		    last;
  		}
  	    	$length += $file_size + length $head;
  	    }
  	    else {
  		$length += length;
  	    }
          }
          $length && $req->header('Content-Length' => $length);
  
  	# set up a closure that will return content piecemeal
  	$content = sub {
  	    for (;;) {
  		unless (@parts) {
  		    defined $length && $length != 0 &&
  		    	Carp::croak "length of data sent did not match calculated Content-Length header.  Probably because uploaded file changed in size during transfer.";
  		    return;
  		}
  		my $p = shift @parts;
  		unless (ref $p) {
  		    $p .= shift @parts while @parts && !ref($parts[0]);
  		    defined $length && ($length -= length $p);
  		    return $p;
  		}
  		my($buf, $fh) = @$p;
                  unless (ref($fh)) {
                      my $file = $fh;
                      undef($fh);
                      open($fh, "<", $file) || Carp::croak("Can't open file $file: $!");
                      binmode($fh);
                  }
  		my $buflength = length $buf;
  		my $n = read($fh, $buf, 2048, $buflength);
  		if ($n) {
  		    $buflength += $n;
  		    unshift(@parts, ["", $fh]);
  		}
  		else {
  		    close($fh);
  		}
  		if ($buflength) {
  		    defined $length && ($length -= $buflength);
  		    return $buf 
  	    	}
  	    }
  	};
  
      }
      else {
  	$boundary = boundary() unless $boundary;
  
  	my $bno = 0;
        CHECK_BOUNDARY:
  	{
  	    for (@parts) {
  		if (index($_, $boundary) >= 0) {
  		    # must have a better boundary
  		    $boundary = boundary(++$bno);
  		    redo CHECK_BOUNDARY;
  		}
  	    }
  	    last;
  	}
  	$content = "--$boundary$CRLF" .
  	           join("$CRLF--$boundary$CRLF", @parts) .
  		   "$CRLF--$boundary--$CRLF";
      }
  
      wantarray ? ($content, $boundary) : $content;
  }
  
  
  sub boundary
  {
      my $size = shift || return "xYzZY";
      require MIME::Base64;
      my $b = MIME::Base64::encode(join("", map chr(rand(256)), 1..$size*3), "");
      $b =~ s/[\W]/X/g;  # ensure alnum only
      $b;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Request::Common - Construct common HTTP::Request objects
  
  =head1 SYNOPSIS
  
    use HTTP::Request::Common;
    $ua = LWP::UserAgent->new;
    $ua->request(GET 'http://www.sn.no/');
    $ua->request(POST 'http://somewhere/foo', [foo => bar, bar => foo]);
  
  =head1 DESCRIPTION
  
  This module provide functions that return newly created C<HTTP::Request>
  objects.  These functions are usually more convenient to use than the
  standard C<HTTP::Request> constructor for the most common requests.  The
  following functions are provided:
  
  =over 4
  
  =item GET $url
  
  =item GET $url, Header => Value,...
  
  The GET() function returns an C<HTTP::Request> object initialized with
  the "GET" method and the specified URL.  It is roughly equivalent to the
  following call
  
    HTTP::Request->new(
       GET => $url,
       HTTP::Headers->new(Header => Value,...),
    )
  
  but is less cluttered.  What is different is that a header named
  C<Content> will initialize the content part of the request instead of
  setting a header field.  Note that GET requests should normally not
  have a content, so this hack makes more sense for the PUT() and POST()
  functions described below.
  
  The get(...) method of C<LWP::UserAgent> exists as a shortcut for
  $ua->request(GET ...).
  
  =item HEAD $url
  
  =item HEAD $url, Header => Value,...
  
  Like GET() but the method in the request is "HEAD".
  
  The head(...)  method of "LWP::UserAgent" exists as a shortcut for
  $ua->request(HEAD ...).
  
  =item PUT $url
  
  =item PUT $url, Header => Value,...
  
  =item PUT $url, Header => Value,..., Content => $content
  
  Like GET() but the method in the request is "PUT".
  
  The content of the request can be specified using the "Content"
  pseudo-header.  This steals a bit of the header field namespace as
  there is no way to directly specify a header that is actually called
  "Content".  If you really need this you must update the request
  returned in a separate statement.
  
  =item DELETE $url
  
  =item DELETE $url, Header => Value,...
  
  Like GET() but the method in the request is "DELETE".  This function
  is not exported by default.
  
  =item POST $url
  
  =item POST $url, Header => Value,...
  
  =item POST $url, $form_ref, Header => Value,...
  
  =item POST $url, Header => Value,..., Content => $form_ref
  
  =item POST $url, Header => Value,..., Content => $content
  
  This works mostly like PUT() with "POST" as the method, but this
  function also takes a second optional array or hash reference
  parameter $form_ref.  As for PUT() the content can also be specified
  directly using the "Content" pseudo-header, and you may also provide
  the $form_ref this way.
  
  The $form_ref argument can be used to pass key/value pairs for the
  form content.  By default we will initialize a request using the
  C<application/x-www-form-urlencoded> content type.  This means that
  you can emulate a HTML E<lt>form> POSTing like this:
  
    POST 'http://www.perl.org/survey.cgi',
         [ name   => 'Gisle Aas',
           email  => 'gisle@aas.no',
           gender => 'M',
           born   => '1964',
           perc   => '3%',
         ];
  
  This will create a HTTP::Request object that looks like this:
  
    POST http://www.perl.org/survey.cgi
    Content-Length: 66
    Content-Type: application/x-www-form-urlencoded
  
    name=Gisle%20Aas&email=gisle%40aas.no&gender=M&born=1964&perc=3%25
  
  Multivalued form fields can be specified by either repeating the field
  name or by passing the value as an array reference.
  
  The POST method also supports the C<multipart/form-data> content used
  for I<Form-based File Upload> as specified in RFC 1867.  You trigger
  this content format by specifying a content type of C<'form-data'> as
  one of the request headers.  If one of the values in the $form_ref is
  an array reference, then it is treated as a file part specification
  with the following interpretation:
  
    [ $file, $filename, Header => Value... ]
    [ undef, $filename, Header => Value,..., Content => $content ]
  
  The first value in the array ($file) is the name of a file to open.
  This file will be read and its content placed in the request.  The
  routine will croak if the file can't be opened.  Use an C<undef> as
  $file value if you want to specify the content directly with a
  C<Content> header.  The $filename is the filename to report in the
  request.  If this value is undefined, then the basename of the $file
  will be used.  You can specify an empty string as $filename if you
  want to suppress sending the filename when you provide a $file value.
  
  If a $file is provided by no C<Content-Type> header, then C<Content-Type>
  and C<Content-Encoding> will be filled in automatically with the values
  returned by LWP::MediaTypes::guess_media_type()
  
  Sending my F<~/.profile> to the survey used as example above can be
  achieved by this:
  
    POST 'http://www.perl.org/survey.cgi',
         Content_Type => 'form-data',
         Content      => [ name  => 'Gisle Aas',
                           email => 'gisle@aas.no',
                           gender => 'M',
                           born   => '1964',
                           init   => ["$ENV{HOME}/.profile"],
                         ]
  
  This will create a HTTP::Request object that almost looks this (the
  boundary and the content of your F<~/.profile> is likely to be
  different):
  
    POST http://www.perl.org/survey.cgi
    Content-Length: 388
    Content-Type: multipart/form-data; boundary="6G+f"
  
    --6G+f
    Content-Disposition: form-data; name="name"
  
    Gisle Aas
    --6G+f
    Content-Disposition: form-data; name="email"
  
    gisle@aas.no
    --6G+f
    Content-Disposition: form-data; name="gender"
  
    M
    --6G+f
    Content-Disposition: form-data; name="born"
  
    1964
    --6G+f
    Content-Disposition: form-data; name="init"; filename=".profile"
    Content-Type: text/plain
  
    PATH=/local/perl/bin:$PATH
    export PATH
  
    --6G+f--
  
  If you set the $DYNAMIC_FILE_UPLOAD variable (exportable) to some TRUE
  value, then you get back a request object with a subroutine closure as
  the content attribute.  This subroutine will read the content of any
  files on demand and return it in suitable chunks.  This allow you to
  upload arbitrary big files without using lots of memory.  You can even
  upload infinite files like F</dev/audio> if you wish; however, if
  the file is not a plain file, there will be no Content-Length header
  defined for the request.  Not all servers (or server
  applications) like this.  Also, if the file(s) change in size between
  the time the Content-Length is calculated and the time that the last
  chunk is delivered, the subroutine will C<Croak>.
  
  The post(...)  method of "LWP::UserAgent" exists as a shortcut for
  $ua->request(POST ...).
  
  =back
  
  =head1 SEE ALSO
  
  L<HTTP::Request>, L<LWP::UserAgent>
  
  
  =head1 COPYRIGHT
  
  Copyright 1997-2004, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
HTTP_REQUEST_COMMON

$fatpacked{"HTTP/Response.pm"} = <<'HTTP_RESPONSE';
  package HTTP::Response;
  
  require HTTP::Message;
  @ISA = qw(HTTP::Message);
  $VERSION = "5.836";
  
  use strict;
  use HTTP::Status ();
  
  
  
  sub new
  {
      my($class, $rc, $msg, $header, $content) = @_;
      my $self = $class->SUPER::new($header, $content);
      $self->code($rc);
      $self->message($msg);
      $self;
  }
  
  
  sub parse
  {
      my($class, $str) = @_;
      my $status_line;
      if ($str =~ s/^(.*)\n//) {
  	$status_line = $1;
      }
      else {
  	$status_line = $str;
  	$str = "";
      }
  
      my $self = $class->SUPER::parse($str);
      my($protocol, $code, $message);
      if ($status_line =~ /^\d{3} /) {
         # Looks like a response created by HTTP::Response->new
         ($code, $message) = split(' ', $status_line, 2);
      } else {
         ($protocol, $code, $message) = split(' ', $status_line, 3);
      }
      $self->protocol($protocol) if $protocol;
      $self->code($code) if defined($code);
      $self->message($message) if defined($message);
      $self;
  }
  
  
  sub clone
  {
      my $self = shift;
      my $clone = bless $self->SUPER::clone, ref($self);
      $clone->code($self->code);
      $clone->message($self->message);
      $clone->request($self->request->clone) if $self->request;
      # we don't clone previous
      $clone;
  }
  
  
  sub code      { shift->_elem('_rc',      @_); }
  sub message   { shift->_elem('_msg',     @_); }
  sub previous  { shift->_elem('_previous',@_); }
  sub request   { shift->_elem('_request', @_); }
  
  
  sub status_line
  {
      my $self = shift;
      my $code = $self->{'_rc'}  || "000";
      my $mess = $self->{'_msg'} || HTTP::Status::status_message($code) || "Unknown code";
      return "$code $mess";
  }
  
  
  sub base
  {
      my $self = shift;
      my $base = (
  	$self->header('Content-Base'),        # used to be HTTP/1.1
  	$self->header('Content-Location'),    # HTTP/1.1
  	$self->header('Base'),                # HTTP/1.0
      )[0];
      if ($base && $base =~ /^$URI::scheme_re:/o) {
  	# already absolute
  	return $HTTP::URI_CLASS->new($base);
      }
  
      my $req = $self->request;
      if ($req) {
          # if $base is undef here, the return value is effectively
          # just a copy of $self->request->uri.
          return $HTTP::URI_CLASS->new_abs($base, $req->uri);
      }
  
      # can't find an absolute base
      return undef;
  }
  
  
  sub redirects {
      my $self = shift;
      my @r;
      my $r = $self;
      while (my $p = $r->previous) {
          push(@r, $p);
          $r = $p;
      }
      return @r unless wantarray;
      return reverse @r;
  }
  
  
  sub filename
  {
      my $self = shift;
      my $file;
  
      my $cd = $self->header('Content-Disposition');
      if ($cd) {
  	require HTTP::Headers::Util;
  	if (my @cd = HTTP::Headers::Util::split_header_words($cd)) {
  	    my ($disposition, undef, %cd_param) = @{$cd[-1]};
  	    $file = $cd_param{filename};
  
  	    # RFC 2047 encoded?
  	    if ($file && $file =~ /^=\?(.+?)\?(.+?)\?(.+)\?=$/) {
  		my $charset = $1;
  		my $encoding = uc($2);
  		my $encfile = $3;
  
  		if ($encoding eq 'Q' || $encoding eq 'B') {
  		    local($SIG{__DIE__});
  		    eval {
  			if ($encoding eq 'Q') {
  			    $encfile =~ s/_/ /g;
  			    require MIME::QuotedPrint;
  			    $encfile = MIME::QuotedPrint::decode($encfile);
  			}
  			else { # $encoding eq 'B'
  			    require MIME::Base64;
  			    $encfile = MIME::Base64::decode($encfile);
  			}
  
  			require Encode;
  			require encoding;
  			# This is ugly use of non-public API, but is there
  			# a better way to accomplish what we want (locally
  			# as-is usable filename string)?
  			my $locale_charset = encoding::_get_locale_encoding();
  			Encode::from_to($encfile, $charset, $locale_charset);
  		    };
  
  		    $file = $encfile unless $@;
  		}
  	    }
  	}
      }
  
      unless (defined($file) && length($file)) {
  	my $uri;
  	if (my $cl = $self->header('Content-Location')) {
  	    $uri = URI->new($cl);
  	}
  	elsif (my $request = $self->request) {
  	    $uri = $request->uri;
  	}
  
  	if ($uri) {
  	    $file = ($uri->path_segments)[-1];
  	}
      }
  
      if ($file) {
  	$file =~ s,.*[\\/],,;  # basename
      }
  
      if ($file && !length($file)) {
  	$file = undef;
      }
  
      $file;
  }
  
  
  sub as_string
  {
      require HTTP::Status;
      my $self = shift;
      my($eol) = @_;
      $eol = "\n" unless defined $eol;
  
      my $status_line = $self->status_line;
      my $proto = $self->protocol;
      $status_line = "$proto $status_line" if $proto;
  
      return join($eol, $status_line, $self->SUPER::as_string(@_));
  }
  
  
  sub dump
  {
      my $self = shift;
  
      my $status_line = $self->status_line;
      my $proto = $self->protocol;
      $status_line = "$proto $status_line" if $proto;
  
      return $self->SUPER::dump(
  	preheader => $status_line,
          @_,
      );
  }
  
  
  sub is_info     { HTTP::Status::is_info     (shift->{'_rc'}); }
  sub is_success  { HTTP::Status::is_success  (shift->{'_rc'}); }
  sub is_redirect { HTTP::Status::is_redirect (shift->{'_rc'}); }
  sub is_error    { HTTP::Status::is_error    (shift->{'_rc'}); }
  
  
  sub error_as_HTML
  {
      require HTML::Entities;
      my $self = shift;
      my $title = 'An Error Occurred';
      my $body  = HTML::Entities::encode($self->status_line);
      return <<EOM;
  <html>
  <head><title>$title</title></head>
  <body>
  <h1>$title</h1>
  <p>$body</p>
  </body>
  </html>
  EOM
  }
  
  
  sub current_age
  {
      my $self = shift;
      my $time = shift;
  
      # Implementation of RFC 2616 section 13.2.3
      # (age calculations)
      my $response_time = $self->client_date;
      my $date = $self->date;
  
      my $age = 0;
      if ($response_time && $date) {
  	$age = $response_time - $date;  # apparent_age
  	$age = 0 if $age < 0;
      }
  
      my $age_v = $self->header('Age');
      if ($age_v && $age_v > $age) {
  	$age = $age_v;   # corrected_received_age
      }
  
      if ($response_time) {
  	my $request = $self->request;
  	if ($request) {
  	    my $request_time = $request->date;
  	    if ($request_time && $request_time < $response_time) {
  		# Add response_delay to age to get 'corrected_initial_age'
  		$age += $response_time - $request_time;
  	    }
  	}
  	$age += ($time || time) - $response_time;
      }
      return $age;
  }
  
  
  sub freshness_lifetime
  {
      my($self, %opt) = @_;
  
      # First look for the Cache-Control: max-age=n header
      for my $cc ($self->header('Cache-Control')) {
  	for my $cc_dir (split(/\s*,\s*/, $cc)) {
  	    return $1 if $cc_dir =~ /^max-age\s*=\s*(\d+)/i;
  	}
      }
  
      # Next possibility is to look at the "Expires" header
      my $date = $self->date || $self->client_date || $opt{time} || time;
      if (my $expires = $self->expires) {
  	return $expires - $date;
      }
  
      # Must apply heuristic expiration
      return undef if exists $opt{heuristic_expiry} && !$opt{heuristic_expiry};
  
      # Default heuristic expiration parameters
      $opt{h_min} ||= 60;
      $opt{h_max} ||= 24 * 3600;
      $opt{h_lastmod_fraction} ||= 0.10; # 10% since last-mod suggested by RFC2616
      $opt{h_default} ||= 3600;
  
      # Should give a warning if more than 24 hours according to
      # RFC 2616 section 13.2.4.  Here we just make this the default
      # maximum value.
  
      if (my $last_modified = $self->last_modified) {
  	my $h_exp = ($date - $last_modified) * $opt{h_lastmod_fraction};
  	return $opt{h_min} if $h_exp < $opt{h_min};
  	return $opt{h_max} if $h_exp > $opt{h_max};
  	return $h_exp;
      }
  
      # default when all else fails
      return $opt{h_min} if $opt{h_min} > $opt{h_default};
      return $opt{h_default};
  }
  
  
  sub is_fresh
  {
      my($self, %opt) = @_;
      $opt{time} ||= time;
      my $f = $self->freshness_lifetime(%opt);
      return undef unless defined($f);
      return $f > $self->current_age($opt{time});
  }
  
  
  sub fresh_until
  {
      my($self, %opt) = @_;
      $opt{time} ||= time;
      my $f = $self->freshness_lifetime(%opt);
      return undef unless defined($f);
      return $f - $self->current_age($opt{time}) + $opt{time};
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  HTTP::Response - HTTP style response message
  
  =head1 SYNOPSIS
  
  Response objects are returned by the request() method of the C<LWP::UserAgent>:
  
      # ...
      $response = $ua->request($request)
      if ($response->is_success) {
          print $response->decoded_content;
      }
      else {
          print STDERR $response->status_line, "\n";
      }
  
  =head1 DESCRIPTION
  
  The C<HTTP::Response> class encapsulates HTTP style responses.  A
  response consists of a response line, some headers, and a content
  body. Note that the LWP library uses HTTP style responses even for
  non-HTTP protocol schemes.  Instances of this class are usually
  created and returned by the request() method of an C<LWP::UserAgent>
  object.
  
  C<HTTP::Response> is a subclass of C<HTTP::Message> and therefore
  inherits its methods.  The following additional methods are available:
  
  =over 4
  
  =item $r = HTTP::Response->new( $code )
  
  =item $r = HTTP::Response->new( $code, $msg )
  
  =item $r = HTTP::Response->new( $code, $msg, $header )
  
  =item $r = HTTP::Response->new( $code, $msg, $header, $content )
  
  Constructs a new C<HTTP::Response> object describing a response with
  response code $code and optional message $msg.  The optional $header
  argument should be a reference to an C<HTTP::Headers> object or a
  plain array reference of key/value pairs.  The optional $content
  argument should be a string of bytes.  The meaning these arguments are
  described below.
  
  =item $r = HTTP::Response->parse( $str )
  
  This constructs a new response object by parsing the given string.
  
  =item $r->code
  
  =item $r->code( $code )
  
  This is used to get/set the code attribute.  The code is a 3 digit
  number that encode the overall outcome of a HTTP response.  The
  C<HTTP::Status> module provide constants that provide mnemonic names
  for the code attribute.
  
  =item $r->message
  
  =item $r->message( $message )
  
  This is used to get/set the message attribute.  The message is a short
  human readable single line string that explains the response code.
  
  =item $r->header( $field )
  
  =item $r->header( $field => $value )
  
  This is used to get/set header values and it is inherited from
  C<HTTP::Headers> via C<HTTP::Message>.  See L<HTTP::Headers> for
  details and other similar methods that can be used to access the
  headers.
  
  =item $r->content
  
  =item $r->content( $bytes )
  
  This is used to get/set the raw content and it is inherited from the
  C<HTTP::Message> base class.  See L<HTTP::Message> for details and
  other methods that can be used to access the content.
  
  =item $r->decoded_content( %options )
  
  This will return the content after any C<Content-Encoding> and
  charsets have been decoded.  See L<HTTP::Message> for details.
  
  =item $r->request
  
  =item $r->request( $request )
  
  This is used to get/set the request attribute.  The request attribute
  is a reference to the the request that caused this response.  It does
  not have to be the same request passed to the $ua->request() method,
  because there might have been redirects and authorization retries in
  between.
  
  =item $r->previous
  
  =item $r->previous( $response )
  
  This is used to get/set the previous attribute.  The previous
  attribute is used to link together chains of responses.  You get
  chains of responses if the first response is redirect or unauthorized.
  The value is C<undef> if this is the first response in a chain.
  
  Note that the method $r->redirects is provided as a more convenient
  way to access the response chain.
  
  =item $r->status_line
  
  Returns the string "E<lt>code> E<lt>message>".  If the message attribute
  is not set then the official name of E<lt>code> (see L<HTTP::Status>)
  is substituted.
  
  =item $r->base
  
  Returns the base URI for this response.  The return value will be a
  reference to a URI object.
  
  The base URI is obtained from one the following sources (in priority
  order):
  
  =over 4
  
  =item 1.
  
  Embedded in the document content, for instance <BASE HREF="...">
  in HTML documents.
  
  =item 2.
  
  A "Content-Base:" or a "Content-Location:" header in the response.
  
  For backwards compatibility with older HTTP implementations we will
  also look for the "Base:" header.
  
  =item 3.
  
  The URI used to request this response. This might not be the original
  URI that was passed to $ua->request() method, because we might have
  received some redirect responses first.
  
  =back
  
  If none of these sources provide an absolute URI, undef is returned.
  
  When the LWP protocol modules produce the HTTP::Response object, then
  any base URI embedded in the document (step 1) will already have
  initialized the "Content-Base:" header. This means that this method
  only performs the last 2 steps (the content is not always available
  either).
  
  =item $r->filename
  
  Returns a filename for this response.  Note that doing sanity checks
  on the returned filename (eg. removing characters that cannot be used
  on the target filesystem where the filename would be used, and
  laundering it for security purposes) are the caller's responsibility;
  the only related thing done by this method is that it makes a simple
  attempt to return a plain filename with no preceding path segments.
  
  The filename is obtained from one the following sources (in priority
  order):
  
  =over 4
  
  =item 1.
  
  A "Content-Disposition:" header in the response.  Proper decoding of
  RFC 2047 encoded filenames requires the C<MIME::QuotedPrint> (for "Q"
  encoding), C<MIME::Base64> (for "B" encoding), and C<Encode> modules.
  
  =item 2.
  
  A "Content-Location:" header in the response.
  
  =item 3.
  
  The URI used to request this response. This might not be the original
  URI that was passed to $ua->request() method, because we might have
  received some redirect responses first.
  
  =back
  
  If a filename cannot be derived from any of these sources, undef is
  returned.
  
  =item $r->as_string
  
  =item $r->as_string( $eol )
  
  Returns a textual representation of the response.
  
  =item $r->is_info
  
  =item $r->is_success
  
  =item $r->is_redirect
  
  =item $r->is_error
  
  These methods indicate if the response was informational, successful, a
  redirection, or an error.  See L<HTTP::Status> for the meaning of these.
  
  =item $r->error_as_HTML
  
  Returns a string containing a complete HTML document indicating what
  error occurred.  This method should only be called when $r->is_error
  is TRUE.
  
  =item $r->redirects
  
  Returns the list of redirect responses that lead up to this response
  by following the $r->previous chain.  The list order is oldest first.
  
  In scalar context return the number of redirect responses leading up
  to this one.
  
  =item $r->current_age
  
  Calculates the "current age" of the response as specified by RFC 2616
  section 13.2.3.  The age of a response is the time since it was sent
  by the origin server.  The returned value is a number representing the
  age in seconds.
  
  =item $r->freshness_lifetime( %opt )
  
  Calculates the "freshness lifetime" of the response as specified by
  RFC 2616 section 13.2.4.  The "freshness lifetime" is the length of
  time between the generation of a response and its expiration time.
  The returned value is the number of seconds until expiry.
  
  If the response does not contain an "Expires" or a "Cache-Control"
  header, then this function will apply some simple heuristic based on
  the "Last-Modified" header to determine a suitable lifetime.  The
  following options might be passed to control the heuristics:
  
  =over
  
  =item heuristic_expiry => $bool
  
  If passed as a FALSE value, don't apply heuristics and just return
  C<undef> when "Expires" or "Cache-Control" is lacking.
  
  =item h_lastmod_fraction => $num
  
  This number represent the fraction of the difference since the
  "Last-Modified" timestamp to make the expiry time.  The default is
  C<0.10>, the suggested typical setting of 10% in RFC 2616.
  
  =item h_min => $sec
  
  This is the lower limit of the heuristic expiry age to use.  The
  default is C<60> (1 minute).
  
  =item h_max => $sec
  
  This is the upper limit of the heuristic expiry age to use.  The
  default is C<86400> (24 hours).
  
  =item h_default => $sec
  
  This is the expiry age to use when nothing else applies.  The default
  is C<3600> (1 hour) or "h_min" if greater.
  
  =back
  
  =item $r->is_fresh( %opt )
  
  Returns TRUE if the response is fresh, based on the values of
  freshness_lifetime() and current_age().  If the response is no longer
  fresh, then it has to be re-fetched or re-validated by the origin
  server.
  
  Options might be passed to control expiry heuristics, see the
  description of freshness_lifetime().
  
  =item $r->fresh_until( %opt )
  
  Returns the time (seconds since epoch) when this entity is no longer fresh.
  
  Options might be passed to control expiry heuristics, see the
  description of freshness_lifetime().
  
  =back
  
  =head1 SEE ALSO
  
  L<HTTP::Headers>, L<HTTP::Message>, L<HTTP::Status>, L<HTTP::Request>
  
  =head1 COPYRIGHT
  
  Copyright 1995-2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
HTTP_RESPONSE

$fatpacked{"HTTP/Server/PSGI.pm"} = <<'HTTP_SERVER_PSGI';
  package HTTP::Server::PSGI;
  use strict;
  use warnings;
  
  use Carp ();
  use Plack;
  use Plack::HTTPParser qw( parse_http_request );
  use IO::Socket::INET;
  use HTTP::Date;
  use HTTP::Status;
  use List::Util qw(max sum);
  use Plack::Util;
  use Plack::TempBuffer;
  use Plack::Middleware::ContentLength;
  use POSIX qw(EINTR);
  use Socket qw(IPPROTO_TCP TCP_NODELAY);
  
  use Try::Tiny;
  use Time::HiRes qw(time);
  
  my $alarm_interval;
  BEGIN {
      if ($^O eq 'MSWin32') {
          $alarm_interval = 1;
      } else {
          Time::HiRes->import('alarm');
          $alarm_interval = 0.1;
      }
  }
  
  use constant MAX_REQUEST_SIZE => 131072;
  use constant MSWin32          => $^O eq 'MSWin32';
  
  sub new {
      my($class, %args) = @_;
  
      my $self = bless {
          host               => $args{host} || 0,
          port               => $args{port} || 8080,
          timeout            => $args{timeout} || 300,
          server_software    => $args{server_software} || $class,
          server_ready       => $args{server_ready} || sub {},
          max_reqs_per_child => $args{max_reqs_per_child} || 100,
      }, $class;
  
      if ($args{max_workers} && $args{max_workers} > 1) {
          Carp::carp(
              "Preforking in $class is deprecated. Falling back to the non-forking mode. ",
              "If you need preforking, use Starman or Starlet instead and run like `plackup -s Starlet`",
          );
      }
  
      $self;
  }
  
  sub run {
      my($self, $app) = @_;
      $self->setup_listener();
      $self->accept_loop($app);
  }
  
  sub setup_listener {
      my $self = shift;
      $self->{listen_sock} ||= IO::Socket::INET->new(
          Listen    => SOMAXCONN,
          LocalPort => $self->{port},
          LocalAddr => $self->{host},
          Proto     => 'tcp',
          ReuseAddr => 1,
      ) or die "failed to listen to port $self->{port}:$!";
  
      $self->{server_ready}->($self);
  }
  
  sub accept_loop {
      # TODO handle $max_reqs_per_child
      my($self, $app, $max_reqs_per_child) = @_;
      my $proc_req_count = 0;
  
      $app = Plack::Middleware::ContentLength->wrap($app);
  
      while (! defined $max_reqs_per_child || $proc_req_count < $max_reqs_per_child) {
          local $SIG{PIPE} = 'IGNORE';
          if (my $conn = $self->{listen_sock}->accept) {
              $conn->setsockopt(IPPROTO_TCP, TCP_NODELAY, 1)
                  or die "setsockopt(TCP_NODELAY) failed:$!";
              ++$proc_req_count;
              my $env = {
                  SERVER_PORT => $self->{port},
                  SERVER_NAME => $self->{host},
                  SCRIPT_NAME => '',
                  REMOTE_ADDR => $conn->peerhost,
                  'psgi.version' => [ 1, 1 ],
                  'psgi.errors'  => *STDERR,
                  'psgi.url_scheme' => 'http',
                  'psgi.run_once'     => Plack::Util::FALSE,
                  'psgi.multithread'  => Plack::Util::FALSE,
                  'psgi.multiprocess' => Plack::Util::FALSE,
                  'psgi.streaming'    => Plack::Util::TRUE,
                  'psgi.nonblocking'  => Plack::Util::FALSE,
                  'psgix.input.buffered' => Plack::Util::TRUE,
                  'psgix.io'          => $conn,
              };
  
              $self->handle_connection($env, $conn, $app);
              $conn->close;
          }
      }
  }
  
  sub handle_connection {
      my($self, $env, $conn, $app) = @_;
  
      my $buf = '';
      my $res = [ 400, [ 'Content-Type' => 'text/plain' ], [ 'Bad Request' ] ];
  
      while (1) {
          my $rlen = $self->read_timeout(
              $conn, \$buf, MAX_REQUEST_SIZE - length($buf), length($buf),
              $self->{timeout},
          ) or return;
          my $reqlen = parse_http_request($buf, $env);
          if ($reqlen >= 0) {
              $buf = substr $buf, $reqlen;
              if (my $cl = $env->{CONTENT_LENGTH}) {
                  my $buffer = Plack::TempBuffer->new($cl);
                  while ($cl > 0) {
                      my $chunk;
                      if (length $buf) {
                          $chunk = $buf;
                          $buf = '';
                      } else {
                          $self->read_timeout($conn, \$chunk, $cl, 0, $self->{timeout});
                      }
                      $buffer->print($chunk);
                      $cl -= length $chunk;
                  }
                  $env->{'psgi.input'} = $buffer->rewind;
              } else {
                  open my $input, "<", \$buf;
                  $env->{'psgi.input'} = $input;
              }
  
              $res = Plack::Util::run_app $app, $env;
              last;
          }
          if ($reqlen == -2) {
              # request is incomplete, do nothing
          } elsif ($reqlen == -1) {
              # error, close conn
              last;
          }
      }
  
      if (ref $res eq 'ARRAY') {
          $self->_handle_response($res, $conn);
      } elsif (ref $res eq 'CODE') {
          $res->(sub {
              $self->_handle_response($_[0], $conn);
          });
      } else {
          die "Bad response $res";
      }
  
      return;
  }
  
  sub _handle_response {
      my($self, $res, $conn) = @_;
  
      my @lines = (
          "Date: @{[HTTP::Date::time2str()]}\015\012",
          "Server: $self->{server_software}\015\012",
      );
  
      Plack::Util::header_iter($res->[1], sub {
          my ($k, $v) = @_;
          push @lines, "$k: $v\015\012";
      });
  
      unshift @lines, "HTTP/1.0 $res->[0] @{[ HTTP::Status::status_message($res->[0]) ]}\015\012";
      push @lines, "\015\012";
  
      $self->write_all($conn, join('', @lines), $self->{timeout})
          or return;
  
      if (defined $res->[2]) {
          my $err;
          my $done;
          {
              local $@;
              eval {
                  Plack::Util::foreach(
                      $res->[2],
                      sub {
                          $self->write_all($conn, $_[0], $self->{timeout})
                              or die "failed to send all data\n";
                      },
                  );
                  $done = 1;
              };
              $err = $@;
          };
          unless ($done) {
              if ($err =~ /^failed to send all data\n/) {
                  return;
              } else {
                  die $err;
              }
          }
      } else {
          return Plack::Util::inline_object
              write => sub { $self->write_all($conn, $_[0], $self->{timeout}) },
              close => sub { };
      }
  }
  
  # returns 1 if socket is ready, undef on timeout
  sub do_timeout {
      my ($self, $cb, $timeout) = @_;
      local $SIG{ALRM} = sub {};
      my $wait_until = time + $timeout;
      alarm($timeout);
      my $ret;
      while (1) {
          if ($ret = $cb->()) {
              last;
          } elsif (! (! defined($ret) && $! == EINTR)) {
              undef $ret;
              last;
          }
          # got EINTR
          my $left = $wait_until - time;
          last if $left <= 0;
          alarm($left + $alarm_interval);
      }
      alarm(0);
      $ret;
  }
  
  # returns (positive) number of bytes read, or undef if the socket is to be closed
  sub read_timeout {
      my ($self, $sock, $buf, $len, $off, $timeout) = @_;
      $self->do_timeout(sub { $sock->sysread($$buf, $len, $off) }, $timeout);
  }
  
  # returns (positive) number of bytes written, or undef if the socket is to be closed
  sub write_timeout {
      my ($self, $sock, $buf, $len, $off, $timeout) = @_;
      $self->do_timeout(sub { $sock->syswrite($buf, $len, $off) }, $timeout);
  }
  
  # writes all data in buf and returns number of bytes written or undef if failed
  sub write_all {
      my ($self, $sock, $buf, $timeout) = @_;
      my $off = 0;
      while (my $len = length($buf) - $off) {
          my $ret = $self->write_timeout($sock, $buf, $len, $off, $timeout)
              or return;
          $off += $ret;
      }
      return length $buf;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  HTTP::Server::PSGI - Standalone PSGI compatible HTTP server
  
  =head1 SYNOPSIS
  
    use HTTP::Server::PSGI;
  
    my $server = HTTP::Server::PSGI->new(
        host => "127.0.0.1",
        port => 9091,
        timeout => 120,
    );
  
    $server->run($app);
  
  =head1 DESCRIPTION
  
  HTTP::Server::PSGI is a standalone, single-process and PSGI compatible
  HTTP server implementations.
  
  This server should be great for the development and testig, but might
  not be suitable for production.
  
  Some features in HTTP/1.1, notably chunked requests, responses and
  pipeline requests are B<NOT> supported yet.
  
  =head1 PREFORKING
  
  L<HTTP::Server::PSGI> does B<NOT> support preforking. See L<Starman>
  or L<Starlet> if you want a multi-process prefork web servers.
  
  =head1 AUTHOR
  
  Kazuho Oku
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Handler::Standalone> L<Starman> L<Starlet>
  
  =cut
HTTP_SERVER_PSGI

$fatpacked{"HTTP/Status.pm"} = <<'HTTP_STATUS';
  package HTTP::Status;
  
  use strict;
  require 5.002;   # because we use prototypes
  
  use vars qw(@ISA @EXPORT @EXPORT_OK %EXPORT_TAGS $VERSION);
  
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT = qw(is_info is_success is_redirect is_error status_message);
  @EXPORT_OK = qw(is_client_error is_server_error);
  $VERSION = "5.817";
  
  # Note also addition of mnemonics to @EXPORT below
  
  # Unmarked codes are from RFC 2616
  # See also: http://en.wikipedia.org/wiki/List_of_HTTP_status_codes
  
  my %StatusCode = (
      100 => 'Continue',
      101 => 'Switching Protocols',
      102 => 'Processing',                      # RFC 2518 (WebDAV)
      200 => 'OK',
      201 => 'Created',
      202 => 'Accepted',
      203 => 'Non-Authoritative Information',
      204 => 'No Content',
      205 => 'Reset Content',
      206 => 'Partial Content',
      207 => 'Multi-Status',                    # RFC 2518 (WebDAV)
      300 => 'Multiple Choices',
      301 => 'Moved Permanently',
      302 => 'Found',
      303 => 'See Other',
      304 => 'Not Modified',
      305 => 'Use Proxy',
      307 => 'Temporary Redirect',
      400 => 'Bad Request',
      401 => 'Unauthorized',
      402 => 'Payment Required',
      403 => 'Forbidden',
      404 => 'Not Found',
      405 => 'Method Not Allowed',
      406 => 'Not Acceptable',
      407 => 'Proxy Authentication Required',
      408 => 'Request Timeout',
      409 => 'Conflict',
      410 => 'Gone',
      411 => 'Length Required',
      412 => 'Precondition Failed',
      413 => 'Request Entity Too Large',
      414 => 'Request-URI Too Large',
      415 => 'Unsupported Media Type',
      416 => 'Request Range Not Satisfiable',
      417 => 'Expectation Failed',
      422 => 'Unprocessable Entity',            # RFC 2518 (WebDAV)
      423 => 'Locked',                          # RFC 2518 (WebDAV)
      424 => 'Failed Dependency',               # RFC 2518 (WebDAV)
      425 => 'No code',                         # WebDAV Advanced Collections
      426 => 'Upgrade Required',                # RFC 2817
      449 => 'Retry with',                      # unofficial Microsoft
      500 => 'Internal Server Error',
      501 => 'Not Implemented',
      502 => 'Bad Gateway',
      503 => 'Service Unavailable',
      504 => 'Gateway Timeout',
      505 => 'HTTP Version Not Supported',
      506 => 'Variant Also Negotiates',         # RFC 2295
      507 => 'Insufficient Storage',            # RFC 2518 (WebDAV)
      509 => 'Bandwidth Limit Exceeded',        # unofficial
      510 => 'Not Extended',                    # RFC 2774
  );
  
  my $mnemonicCode = '';
  my ($code, $message);
  while (($code, $message) = each %StatusCode) {
      # create mnemonic subroutines
      $message =~ tr/a-z \-/A-Z__/;
      $mnemonicCode .= "sub HTTP_$message () { $code }\n";
      $mnemonicCode .= "*RC_$message = \\&HTTP_$message;\n";  # legacy
      $mnemonicCode .= "push(\@EXPORT_OK, 'HTTP_$message');\n";
      $mnemonicCode .= "push(\@EXPORT, 'RC_$message');\n";
  }
  eval $mnemonicCode; # only one eval for speed
  die if $@;
  
  # backwards compatibility
  *RC_MOVED_TEMPORARILY = \&RC_FOUND;  # 302 was renamed in the standard
  push(@EXPORT, "RC_MOVED_TEMPORARILY");
  
  %EXPORT_TAGS = (
     constants => [grep /^HTTP_/, @EXPORT_OK],
     is => [grep /^is_/, @EXPORT, @EXPORT_OK],
  );
  
  
  sub status_message  ($) { $StatusCode{$_[0]}; }
  
  sub is_info         ($) { $_[0] >= 100 && $_[0] < 200; }
  sub is_success      ($) { $_[0] >= 200 && $_[0] < 300; }
  sub is_redirect     ($) { $_[0] >= 300 && $_[0] < 400; }
  sub is_error        ($) { $_[0] >= 400 && $_[0] < 600; }
  sub is_client_error ($) { $_[0] >= 400 && $_[0] < 500; }
  sub is_server_error ($) { $_[0] >= 500 && $_[0] < 600; }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  HTTP::Status - HTTP Status code processing
  
  =head1 SYNOPSIS
  
   use HTTP::Status qw(:constants :is status_message);
  
   if ($rc != HTTP_OK) {
       print status_message($rc), "\n";
   }
  
   if (is_success($rc)) { ... }
   if (is_error($rc)) { ... }
   if (is_redirect($rc)) { ... }
  
  =head1 DESCRIPTION
  
  I<HTTP::Status> is a library of routines for defining and
  classifying HTTP status codes for libwww-perl.  Status codes are
  used to encode the overall outcome of a HTTP response message.  Codes
  correspond to those defined in RFC 2616 and RFC 2518.
  
  =head1 CONSTANTS
  
  The following constant functions can be used as mnemonic status code
  names.  None of these are exported by default.  Use the C<:constants>
  tag to import them all.
  
     HTTP_CONTINUE                        (100)
     HTTP_SWITCHING_PROTOCOLS             (101)
     HTTP_PROCESSING                      (102)
  
     HTTP_OK                              (200)
     HTTP_CREATED                         (201)
     HTTP_ACCEPTED                        (202)
     HTTP_NON_AUTHORITATIVE_INFORMATION   (203)
     HTTP_NO_CONTENT                      (204)
     HTTP_RESET_CONTENT                   (205)
     HTTP_PARTIAL_CONTENT                 (206)
     HTTP_MULTI_STATUS                    (207)
  
     HTTP_MULTIPLE_CHOICES                (300)
     HTTP_MOVED_PERMANENTLY               (301)
     HTTP_FOUND                           (302)
     HTTP_SEE_OTHER                       (303)
     HTTP_NOT_MODIFIED                    (304)
     HTTP_USE_PROXY                       (305)
     HTTP_TEMPORARY_REDIRECT              (307)
  
     HTTP_BAD_REQUEST                     (400)
     HTTP_UNAUTHORIZED                    (401)
     HTTP_PAYMENT_REQUIRED                (402)
     HTTP_FORBIDDEN                       (403)
     HTTP_NOT_FOUND                       (404)
     HTTP_METHOD_NOT_ALLOWED              (405)
     HTTP_NOT_ACCEPTABLE                  (406)
     HTTP_PROXY_AUTHENTICATION_REQUIRED   (407)
     HTTP_REQUEST_TIMEOUT                 (408)
     HTTP_CONFLICT                        (409)
     HTTP_GONE                            (410)
     HTTP_LENGTH_REQUIRED                 (411)
     HTTP_PRECONDITION_FAILED             (412)
     HTTP_REQUEST_ENTITY_TOO_LARGE        (413)
     HTTP_REQUEST_URI_TOO_LARGE           (414)
     HTTP_UNSUPPORTED_MEDIA_TYPE          (415)
     HTTP_REQUEST_RANGE_NOT_SATISFIABLE   (416)
     HTTP_EXPECTATION_FAILED              (417)
     HTTP_UNPROCESSABLE_ENTITY            (422)
     HTTP_LOCKED                          (423)
     HTTP_FAILED_DEPENDENCY               (424)
     HTTP_NO_CODE                         (425)
     HTTP_UPGRADE_REQUIRED                (426)
     HTTP_RETRY_WITH                      (449)
  
     HTTP_INTERNAL_SERVER_ERROR           (500)
     HTTP_NOT_IMPLEMENTED                 (501)
     HTTP_BAD_GATEWAY                     (502)
     HTTP_SERVICE_UNAVAILABLE             (503)
     HTTP_GATEWAY_TIMEOUT                 (504)
     HTTP_HTTP_VERSION_NOT_SUPPORTED      (505)
     HTTP_VARIANT_ALSO_NEGOTIATES         (506)
     HTTP_INSUFFICIENT_STORAGE            (507)
     HTTP_BANDWIDTH_LIMIT_EXCEEDED        (509)
     HTTP_NOT_EXTENDED                    (510)
  
  =head1 FUNCTIONS
  
  The following additional functions are provided.  Most of them are
  exported by default.  The C<:is> import tag can be used to import all
  the classification functions.
  
  =over 4
  
  =item status_message( $code )
  
  The status_message() function will translate status codes to human
  readable strings. The string is the same as found in the constant
  names above.  If the $code is unknown, then C<undef> is returned.
  
  =item is_info( $code )
  
  Return TRUE if C<$code> is an I<Informational> status code (1xx).  This
  class of status code indicates a provisional response which can't have
  any content.
  
  =item is_success( $code )
  
  Return TRUE if C<$code> is a I<Successful> status code (2xx).
  
  =item is_redirect( $code )
  
  Return TRUE if C<$code> is a I<Redirection> status code (3xx). This class of
  status code indicates that further action needs to be taken by the
  user agent in order to fulfill the request.
  
  =item is_error( $code )
  
  Return TRUE if C<$code> is an I<Error> status code (4xx or 5xx).  The function
  return TRUE for both client error or a server error status codes.
  
  =item is_client_error( $code )
  
  Return TRUE if C<$code> is an I<Client Error> status code (4xx). This class
  of status code is intended for cases in which the client seems to have
  erred.
  
  This function is B<not> exported by default.
  
  =item is_server_error( $code )
  
  Return TRUE if C<$code> is an I<Server Error> status code (5xx). This class
  of status codes is intended for cases in which the server is aware
  that it has erred or is incapable of performing the request.
  
  This function is B<not> exported by default.
  
  =back
  
  =head1 BUGS
  
  For legacy reasons all the C<HTTP_> constants are exported by default
  with the prefix C<RC_>.  It's recommended to use explict imports and
  the C<:constants> tag instead of relying on this.
HTTP_STATUS

$fatpacked{"Hash/MultiValue.pm"} = <<'HASH_MULTIVALUE';
  package Hash::MultiValue;
  
  use strict;
  use 5.008_001;
  our $VERSION = '0.08';
  
  use Carp ();
  use Scalar::Util qw(refaddr);
  
  my %keys;
  my %values;
  
  if (defined &UNIVERSAL::ref::import) {
      UNIVERSAL::ref->import;
  }
  
  sub ref { 'HASH' }
  
  sub create {
      my $class = shift;
      my $self = bless {}, $class;
      my $this = refaddr $self;
      $keys{$this} = [];
      $values{$this} = [];
      $self;
  }
  
  sub new {
      my $class = shift;
      my $self = $class->create;
      unshift @_, $self;
      goto &{ $self->can('merge_flat') };
  }
  
  sub from_mixed {
      my $class = shift;
      my $self = $class->create;
      unshift @_, $self;
      goto &{ $self->can('merge_mixed') };
  }
  
  sub DESTROY {
      my $this = refaddr shift;
      delete $keys{$this};
      delete $values{$this};
  }
  
  sub get {
      my($self, $key) = @_;
      $self->{$key};
  }
  
  sub get_all {
      my($self, $key) = @_;
      my $this = refaddr $self;
      my $k = $keys{$this};
      (@{$values{$this}}[grep { $key eq $k->[$_] } 0 .. $#$k]);
  }
  
  sub get_one {
      my ($self, $key) = @_;
      my @v = $self->get_all($key);
      return $v[0] if @v == 1;
      Carp::croak "Key not found: $key" if not @v;
      Carp::croak "Multiple values match: $key";
  }
  
  sub add {
      my $self = shift;
      my $key = shift;
      $self->merge_mixed( $key => \@_ );
      $self;
  }
  
  sub merge_flat {
      my $self = shift;
      my $this = refaddr $self;
      my $k = $keys{$this};
      my $v = $values{$this};
      push @{ $_ & 1 ? $v : $k }, $_[$_] for 0 .. $#_;
      @{$self}{@$k} = @$v;
      $self;
  }
  
  sub merge_mixed {
      my $self = shift;
      my $this = refaddr $self;
      my $k = $keys{$this};
      my $v = $values{$this};
  
      my $hash;
      $hash = shift if @_ == 1;
  
      while ( my ($key, $value) = @_ ? splice @_, 0, 2 : each %$hash ) {
          my @value = CORE::ref($value) eq 'ARRAY' ? @$value : $value;
          next if not @value;
          $self->{$key} = $value[-1];
          push @$k, ($key) x @value;
          push @$v, @value;
      }
  
      $self;
  }
  
  sub remove {
      my ($self, $key) = @_;
      delete $self->{$key};
  
      my $this = refaddr $self;
      my $k = $keys{$this};
      my $v = $values{$this};
      my @keep = grep { $key ne $k->[$_] } 0 .. $#$k;
      @$k = @$k[@keep];
      @$v = @$v[@keep];
      $self;
  }
  
  sub clear {
      my $self = shift;
      %$self = ();
      my $this = refaddr $self;
      $keys{$this} = [];
      $values{$this} = [];
      $self;
  }
  
  sub clone {
      my $self = shift;
      CORE::ref($self)->new($self->flatten);
  }
  
  sub keys {
      my $self = shift;
      return @{$keys{refaddr $self}};
  }
  
  sub values {
      my $self = shift;
      return @{$values{refaddr $self}};
  }
  
  sub flatten {
      my $self = shift;
      my $this = refaddr $self;
      my $k = $keys{$this};
      my $v = $values{$this};
      map { $k->[$_], $v->[$_] } 0 .. $#$k;
  }
  
  sub each {
      my ($self, $code) = @_;
      my $this = refaddr $self;
      my $k = $keys{$this};
      my $v = $values{$this};
      for (0 .. $#$k) {
          $code->($k->[$_], $v->[$_]);
      }
      return $self;
  }
  
  sub as_hashref {
      my $self = shift;
      my %hash = %$self;
      \%hash;
  }
  
  sub as_hashref_mixed {
      my $self = shift;
      my $this = refaddr $self;
      my $k = $keys{$this};
      my $v = $values{$this};
  
      my %hash;
      push @{$hash{$k->[$_]}}, $v->[$_] for 0 .. $#$k;
      for (CORE::values %hash) {
          $_ = $_->[0] if 1 == @$_;
      }
  
      \%hash;
  }
  
  sub mixed { $_[0]->as_hashref_mixed }
  
  sub as_hashref_multi {
      my $self = shift;
      my $this = refaddr $self;
      my $k = $keys{$this};
      my $v = $values{$this};
  
      my %hash;
      push @{$hash{$k->[$_]}}, $v->[$_] for 0 .. $#$k;
  
      \%hash;
  }
  
  sub multi { $_[0]->as_hashref_multi }
  
  1;
  __END__
  
  =encoding utf-8
  
  =for stopwords
  
  =head1 NAME
  
  Hash::MultiValue - Store multiple values per key
  
  =head1 SYNOPSIS
  
    use Hash::MultiValue;
  
    my $hash = Hash::MultiValue->new(
        foo => 'a',
        foo => 'b',
        bar => 'baz',
    );
  
    # $hash is an object, but can be used as a hashref and DWIMs!
    my $foo = $hash->{foo};         # 'b' (the last entry)
    my $foo = $hash->get('foo');    # 'b' (always, regardless of context)
    my @foo = $hash->get_all('foo'); # ('a', 'b')
  
    keys %$hash; # ('foo', 'bar')    not guaranteed to be ordered
    $hash->keys; # ('foo', 'foo', 'bar') guaranteed to be ordered
  
  =head1 DESCRIPTION
  
  Hash::MultiValue is an object (and a plain hash reference) that may
  contain multiple values per key, inspired by MultiDict of WebOb.
  
  =head1 WHY THIS MODULE
  
  In a typical web application, the request parameters (a.k.a CGI
  parameters) can be single value or multi values. Using CGI.pm style
  C<param> is one way to deal with this problem (and it is good, as long
  as you're aware of its list context gotcha), but there's another
  approach to convert parameters into a hash reference, like Catalyst's
  C<< $c->req->parameters >> does, and it B<sucks>.
  
  Why? Because the value could be just a scalar if there is one value
  and an array ref if there are multiple, depending on I<user input>
  rather than I<how you code it>. So your code should always be like
  this to be defensive:
  
    my $p = $c->req->parameters;
    my @maybe_multi = ref $p->{m} eq 'ARRAY' ? @{$p->{m}} : ($p->{m});
    my $must_single = ref $p->{m} eq 'ARRAY' ? $p->{m}->[0] : $p->{m};
  
  Otherwise you'll get a random runtime exception of I<Can't use string
  as an ARRAY ref> or get stringified array I<ARRAY(0xXXXXXXXXX)> as a
  string, I<depending on user input> and that is miserable and
  insecure.
  
  This module provides a solution to this by making it behave like a
  single value hash reference, but also has an API to get multiple
  values on demand, explicitly.
  
  =head1 HOW THIS WORKS
  
  The object returned by C<new> is a blessed hash reference that
  contains the last entry of the same key if there are multiple values,
  but it also keeps the original pair state in the object tracker (a.k.a
  inside out objects) and allows you to access the original pairs and
  multiple values via the method calls, such as C<get_all> or C<flatten>.
  
  This module does not use C<tie> or L<overload> and is quite fast.
  
  Yes, there is L<Tie::Hash::MultiValue> and this module tries to solve
  exactly the same problem, but using a different implementation.
  
  =head1 UPDATING CONTENTS
  
  When you update the content of the hash, B<DO NOT UPDATE> using the
  hash reference interface: this won't write through to the tracking
  object.
  
    my $hash = Hash::MultiValue->new(...);
  
    # WRONG
    $hash->{foo} = 'bar';
    delete $hash->{foo};
  
    # Correct
    $hash->add(foo => 'bar');
    $hash->remove('foo');
  
  See below for the list of updating methods.
  
  =head1 METHODS
  
  =over 4
  
  =item new
  
    $hash = Hash::MultiValue->new(@pairs);
  
  Creates a new object that can be treated as a plain hash reference as well.
  
  =item get
  
    $value = $hash->get($key);
    $value = $hash->{$key};
  
  Returns a single value for the given C<$key>. If there are multiple
  values, the last one (not first one) is returned. See below for why.
  
  Note that this B<always> returns the single element as a scalar,
  regardless of its context, unlike CGI.pm's C<param> method etc.
  
  =item get_one
  
    $value = $hash->get_one($key);
  
  Returns a single value for the given C<$key>. This method B<croaks> if
  there is no value or multiple values associated with the key, so you
  should wrap it with eval or modules like L<Try::Tiny>.
  
  =item get_all
  
    @values = $hash->get_all($key);
  
  Returns a list of values for the given C<$key>. This method B<always>
  returns a list regardless of its context. If there is no value
  attached, the result will be an empty list.
  
  =item keys
  
    @keys = $hash->keys;
  
  Returns a list of all keys, including duplicates (see the example in the
  L</SYNOPSIS>).
  
  If you want only unique keys, use C<< keys %$hash >>, as normal.
  
  =item values
  
    @values = $hash->values;
  
  Returns a list of all values, in the same order as C<< $hash->keys >>.
  
  =item add
  
    $hash->add($key, $value [, $value ... ]);
  
  Appends a new value to the given C<$key>. This updates the value of
  C<< $hash->{$key} >> as well so it always points to the last value.
  
  =item remove
  
    $hash->remove($key);
  
  Removes a key and associated values for the given C<$key>.
  
  =item clear
  
    $hash->clear;
  
  Clears the hash to be an empty hash reference.
  
  =item flatten
  
    @pairs = $hash->flatten;
  
  Gets pairs of keys and values. This should be exactly the same pairs
  which are given to C<new> method unless you updated the data.
  
  =item each
  
    $hash->each($code);
  
    # e.g.
    $hash->each(sub { print "$_[0] = $_[1]\n" });
  
  Calls C<$code> once for each C<($key, $value)> pair.  This is a more convenient
  alternative to calling C<flatten> and then iterating over it two items at a
  time.
  
  Inside C<$code>, C<$_> contains the current iteration through the loop,
  starting at 0.  For example:
  
    $hash = Hash::MultiValue->new(a => 1, b => 2, c => 3, a => 4);
  
    $hash->each(sub { print "$_: $_[0] = $_[1]\n" });
    # 0: a = 1
    # 1: b = 2
    # 2: c = 3
    # 3: a = 4
  
  Be careful not to change C<@_> inside your coderef!  It will update the
  tracking object but not the plain hash.  In the future, this limitation may be
  removed.
  
  =item clone
  
    $new = $hash->clone;
  
  Creates a new Hash::MultiValue object that represents the same data,
  but obviously not sharing the reference. It's identical to:
  
    $new = Hash::MultiValue->new($hash->flatten);
  
  =item as_hashref
  
    $copy = $hash->as_hashref;
  
  Creates a new plain (unblessed) hash reference where a value is a
  single scalar. It's identical to:
  
    $copy = +{%$hash};
  
  =item as_hashref_mixed, mixed
  
    $mixed = $hash->as_hashref_mixed;
    $mixed = $hash->mixed;
  
  Creates a new plain (unblessed) hash reference where the value is a
  single scalar, or an array ref when there are multiple values for a
  same key. Handy to create a hash reference that is often used in web
  application frameworks request objects such as L<Catalyst>. Ths method
  does exactly the opposite of C<from_mixed>.
  
  =item as_hashref_multi, multi
  
    $multi = $hash->as_hashref_multi
    $multi = $hash->multi
  
  Creates a new plain (unblessed) hash reference where values are all
  array references, regardless of there are single or multiple values
  for a same key.
  
  =item from_mixed
  
    $hash = Hash::MultiValue->from_mixed({
        foo => [ 'a', 'b' ],
        bar => 'c',
    });
  
  Creates a new object out of a hash reference where the value is single
  or an array ref depending on the number of elements. Handy to convert
  from those request objects used in web frameworks such as L<Catalyst>.
  This method does exactly the opposite of C<as_hashref_mixed>.
  
  =back
  
  =head1 WHY LAST NOT FIRST?
  
  You might wonder why this module uses the I<last> value of the same
  key instead of I<first>. There's no strong reasoning on this decision
  since one is as arbitrary as the other, but this is more consistent to
  what Perl does:
  
    sub x {
        return ('a', 'b', 'c');
    }
  
    my $x = x(); # $x = 'c'
  
    my %a = ( a => 1 );
    my %b = ( a => 2 );
  
    my %m = (%a, %b); # $m{a} = 2
  
  When perl gets a list in a scalar context it gets the last entry. Also
  if you merge hashes having a same key, the last one wins.
  
  =head1 NOTES ON ref
  
  If you pass this MultiValue hash object to some upstream functions
  that you can't control and does things like:
  
    if (ref $args eq 'HASH') {
        ...
    }
  
  because this is a blessed hash reference it doesn't match and would
  fail. To avoid that you should call C<as_hashref> to get a
  I<finalized> (= non-blessed) hash reference.
  
  You can also use UNIVERSAL::ref to make it work magically:
  
    use UNIVERSAL::ref;    # before loading Hash::MultiValue
    use Hash::MultiValue;
  
  and then all C<ref> calls to Hash::MultiValue objects will return I<HASH>.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa E<lt>miyagawa@bulknews.netE<gt>
  
  Aristotle Pagaltzis
  
  Hans Dieter Pearcey
  
  Thanks to Michael Peters for the suggestion to use inside-out objects
  instead of tie.
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item * L<http://pythonpaste.org/webob/#multidict>
  
  =item * L<Tie::Hash::MultiValue>
  
  =back
  
  =cut
HASH_MULTIVALUE

$fatpacked{"Hitagi.pm"} = <<'HITAGI';
  package Hitagi;
  use strict;
  use warnings;
  our $VERSION = '0.01';
  use Data::Section::Simple;
  use Plack::Request;
  use Plack::Response;
  use Router::Simple;
  use Text::MicroTemplate;
  use File::Slurp qw/slurp/;
  use File::Basename qw/dirname/;
  
  my $_ROUTER = Router::Simple->new;
  my ( $_DATA, $_BASE, $_DB, $_BASE_DIR );
  
  sub app {
      sub {
          my $env = shift;
          my $req = Plack::Request->new($env);
          $_BASE = $req->base unless $_BASE;
          if ( my $p = $_ROUTER->match($env) ) {
              my $code = $p->{action};
              if ( ref $code eq 'CODE' ) {
                  my $res = &$code( $req, $p );
                  return $res if ref $res eq 'ARRAY';
                  return handle_html($res);
              }
              render($code);
          }
          else {
              [ 404, [], ['Not Found'] ];
          }
      };
  }
  
  sub set {
      my ( $name, $args ) = @_;
      set_db($args) if $name eq 'db';
  }
  
  sub any {
      my ( $pattern, $code, $method ) = @_;
      $_ROUTER->connect( $pattern, { action => $code } , { method => $method } );
  }
  
  sub get {
      any( $_[0], $_[1] , 'GET' );
  }
  
  sub post {
      any( $_[0], $_[1] , 'POST' );
  }
  
  sub render {
      my ( $name, $args ) = @_;
      $args ||= {};
      my $template = code($name) or return [ 500, [], ['Internal Server Error'] ];
      my $code = $template;
      if( my $layout = code('layout') ){
          $code .= ";sub content { Text::MicroTemplate::encoded_string $template->() };";
          $code .=  $layout;
      }
      $args->{base} = $_BASE;
      my $args_string = args_string($args);
      no warnings; #XXX
      local $@;
      my $renderer = eval <<  "..." or die $@; ## no critic
  sub {
      my \$args = shift; $args_string;
      $code->();
  };
  ...
      handle_html( $renderer->($args), $args->{content_type} || 'text/html' );
  }
  
  sub template {
      my $name = shift;
      my $template = '';
      $template = $_DATA->get_data_section($name);
      local $@;
      eval{
          $template = slurp($name) unless $template;
      };
      chomp $template if $template;
      return $template;
  }
  
  sub code {
      my $name     = shift;
      my $template = template( $name ) or return;
      my $mt       = Text::MicroTemplate->new( template => $template );
      my $code     = $mt->code;
      return $code;
  }
  
  # stolen from TMT::Extended
  sub args_string {
      my $args        = shift;
      my $args_string = '';
      for my $key ( keys %{ $args || {} } ) {
          unless ( $key =~ /^[a-zA-Z_][a-zA-Z0-9_]*$/ ) {
              die qq{Invalid template args key name: "$key"};
          }
          if ( ref( $args->{$key} ) eq 'CODE' ) {
              $args_string .= qq{my \$$key = \$args->{$key}->();\n};
          }
          else {
              $args_string .= qq{my \$$key = \$args->{$key};\n};
          }
      }
      $args_string;
  }
  
  
  sub set_db {
      my ( $args ) = @_;
      my $schema = $args->{schema} || '';
      local $@;
      package DB::Schema;
      use DBIx::Skinny::Schema;
      eval ( $schema );  ## no critic
      1;
      die $@ if $@;
      package DB;
      use DBIx::Skinny;
      1;
      $_DB = DB->new(
          {
              dsn             => $args->{connect_info}[0] || '',
              username        => $args->{connect_info}[1] || '',
              password        => $args->{connect_info}[2] || '',
              connect_options => { AutoCommit => 1, RaiseError => 1 },
          }
      );
  }
  
  sub db { return $_DB };
  
  sub handle_html {
      my ( $body, $content_type ) = @_;
      $content_type ||= 'text/plain';
      return [
          200,
          [ 'Content-Length' => length $body, 'Content-Type' => $content_type ],
          [$body]
      ];
  }
  
  sub run {
      require Plack::Runner;
      require Plack::Middleware::Static;
      my $runner = Plack::Runner->new;
      $runner->parse_options(@ARGV);
      my $app = Plack::Middleware::Static->wrap(
          &app,
          path => qr{^/static/},
          root => $_BASE_DIR,
      );
      $runner->run($app);
  }
  
  sub run_as_cgi {
      require Plack::Handler::CGI;
      Plack::Handler::CGI->new->run(&app);
  }
  
  sub import {
      strict->import;
      warnings->import;
      no strict 'refs';
      no warnings 'redefine';
      my ( $caller, $filename ) = caller;
      $_BASE_DIR = dirname( $filename );
      $_DATA = Data::Section::Simple->new($caller);
      my @functions = qw/get post render set db template/;
      for my $function (@functions) {
          *{"${caller}\::$function"} = \&$function;
      }
      *{"${caller}::res"} = sub { Plack::Response->new(@_) };
      *{"${caller}::redirect"} =
        sub { return [ 302, [ 'Location' => shift ], [] ] };
      if ( $ENV{'PLACK_ENV'} ) {
          *{"${caller}::star"} = \&app;
      }
      else {
          *{"${caller}::star"} = sub { run(@_) };
          *{"${caller}::star"} = sub { run_as_cgi() }
            if $filename =~ /\.cgi$/;
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Hitagi - Shall we talk about stars and micro web application frameworks.
  
  =head1 SYNOPSIS
  
  In myapp.pl
  
    use Hitagi;
    get '/' => sub { render('index', { message => 'Hi' }) };
    star;
  
    __DATA__
  
    @@ index
    <h1>message : <?= $message ?></h1>
  
  Run
  
    $ perl myapp.pl
  
  =head1 DESCRIPTION
  
  Hitagi is yet another micro web application framework
  using Plack::Request, Router::Simple, Text::MicroTemplate, and DBIx::Skinny.
  
  =head2 EXAMPLE
  
  =head3 Using template in DATA section.
  
  Template format is as Text::MicroTemplate.
  
    use Hitagi;
    get '/' => 'index';
    star;
  
    __DATA__
  
    @@ index
    <h1>welcome</h1>
  
  =head3 Get params and give args to template
  
    use Hitag;
    get '/hi' => sub {
        my ($req) = @_;
        render( 'hi.mt',
            { message => $req->param('message') || 'no message' } );
    };
    star;
  
    __DATA__
  
    @@ hi
    <h1>message : <?= $message ?></h1>
  
  =head3 Handle post request and parse params from url path
  
    post '/comment/:id' => sub {
        my ( $req, $args ) = @_;
        warn "Comment id is : $args->{id}";
        ...;
    };
  
  =head3 Handle static files
  
  Put your css or image files etc. to "static" directory.
  You can access these files on http://localhost:5000/static/xxx.css
  
  =head3 Make custom response such as XML
  
  res method returns Plack::Response.
  
    get '/xml' => sub {
        my $res = res(200);
        $res->content_type('application/xml');
        $res->body( template('xml') );
        $res->finalize;
    };
  
    ...;
  
    __DATA__
  
    @xml
    <xml><root>content</root></xml>
  
  =head3 Template layout setting
  
    use Hitagi;
  
    ...;
  
    __DATA__
    @@ index
    <h1>welcome</h1>
  
    @@ layout
    <html>
    </head><title>title</title></head>
    <body>
    <div id="container">
        <?= content ?>
    </div>
    <address>This content is made by Hitagi</address>
    </body>
    </html>
  
  =head3 Using Model
  
  DBIx::Skinny based.
  
    use Hitagi;
  
    set db => {
        connect_info => [ 'dbi:SQLite:','', '' ],
        schema       => qq{
            install_table entry => schema {
               pk 'id';
               columns qw/id body/;
            };
        }
    };
  
    db->do(q{CREATE TABLE entry ( id varchar, body text )});
  
    ...;
  
    get '/entry/{entry_id}' => sub {
        my ( $req, $args ) = @_;
        my $entry_id = $args->{entry_id};
        my $entry = db->single( entry => { id => $entry_id, } );
        return res(404,[],'Not Found')->finalize unless $entry;
        render( 'entry', { body => $entry->body } );
    };
  
  =head2 Run as CGI, PSGI.
  
  If you save a application file with '.cgi' extention, it works as CGI.
  
  /home/user/public_html/hello.cgi
  
    #!/usr/bin/perl
  
    use Hitagi;
    get '/' => sub { render( 'index', { message => 'Hi' } ) };
    star;
  
    __DATA__
    @@ index
    <h1>message : <?= $message ?></h1>
  
  View http://localhost/~user/hello.cgi/
  
  PSGI supported too.
  
    $ plackup myapp.pl
  
  =head1 AUTHOR
  
  Yusuke Wada E<lt>yusuke at kamawada.comE<gt>
  
  =head1 SEE ALSO
  
  L<Plack::Request>, L<Plack::Response>, L<Text::MicroTemplate>, L<DBIx::Skinny>
  
  L<Mojolicious::Lite>, L<Dancer>, L<MojaMoja>
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
HITAGI

$fatpacked{"LWP.pm"} = <<'LWP';
  package LWP;
  
  $VERSION = "5.836";
  sub Version { $VERSION; }
  
  require 5.005;
  require LWP::UserAgent;  # this should load everything you need
  
  1;
  
  __END__
  
  =head1 NAME
  
  LWP - The World-Wide Web library for Perl
  
  =head1 SYNOPSIS
  
    use LWP;
    print "This is libwww-perl-$LWP::VERSION\n";
  
  
  =head1 DESCRIPTION
  
  The libwww-perl collection is a set of Perl modules which provides a
  simple and consistent application programming interface (API) to the
  World-Wide Web.  The main focus of the library is to provide classes
  and functions that allow you to write WWW clients. The library also
  contain modules that are of more general use and even classes that
  help you implement simple HTTP servers.
  
  Most modules in this library provide an object oriented API.  The user
  agent, requests sent and responses received from the WWW server are
  all represented by objects.  This makes a simple and powerful
  interface to these services.  The interface is easy to extend
  and customize for your own needs.
  
  The main features of the library are:
  
  =over 3
  
  =item *
  
  Contains various reusable components (modules) that can be
  used separately or together.
  
  =item *
  
  Provides an object oriented model of HTTP-style communication.  Within
  this framework we currently support access to http, https, gopher, ftp, news,
  file, and mailto resources.
  
  =item *
  
  Provides a full object oriented interface or
  a very simple procedural interface.
  
  =item *
  
  Supports the basic and digest authorization schemes.
  
  =item *
  
  Supports transparent redirect handling.
  
  =item *
  
  Supports access through proxy servers.
  
  =item *
  
  Provides parser for F<robots.txt> files and a framework for constructing robots.
  
  =item *
  
  Supports parsing of HTML forms.
  
  =item *
  
  Implements HTTP content negotiation algorithm that can
  be used both in protocol modules and in server scripts (like CGI
  scripts).
  
  =item *
  
  Supports HTTP cookies.
  
  =item *
  
  Some simple command line clients, for instance C<lwp-request> and C<lwp-download>.
  
  =back
  
  
  =head1 HTTP STYLE COMMUNICATION
  
  
  The libwww-perl library is based on HTTP style communication. This
  section tries to describe what that means.
  
  Let us start with this quote from the HTTP specification document
  <URL:http://www.w3.org/pub/WWW/Protocols/>:
  
  =over 3
  
  =item
  
  The HTTP protocol is based on a request/response paradigm. A client
  establishes a connection with a server and sends a request to the
  server in the form of a request method, URI, and protocol version,
  followed by a MIME-like message containing request modifiers, client
  information, and possible body content. The server responds with a
  status line, including the message's protocol version and a success or
  error code, followed by a MIME-like message containing server
  information, entity meta-information, and possible body content.
  
  =back
  
  What this means to libwww-perl is that communication always take place
  through these steps: First a I<request> object is created and
  configured. This object is then passed to a server and we get a
  I<response> object in return that we can examine. A request is always
  independent of any previous requests, i.e. the service is stateless.
  The same simple model is used for any kind of service we want to
  access.
  
  For example, if we want to fetch a document from a remote file server,
  then we send it a request that contains a name for that document and
  the response will contain the document itself.  If we access a search
  engine, then the content of the request will contain the query
  parameters and the response will contain the query result.  If we want
  to send a mail message to somebody then we send a request object which
  contains our message to the mail server and the response object will
  contain an acknowledgment that tells us that the message has been
  accepted and will be forwarded to the recipient(s).
  
  It is as simple as that!
  
  
  =head2 The Request Object
  
  The libwww-perl request object has the class name C<HTTP::Request>.
  The fact that the class name uses C<HTTP::> as a
  prefix only implies that we use the HTTP model of communication.  It
  does not limit the kind of services we can try to pass this I<request>
  to.  For instance, we will send C<HTTP::Request>s both to ftp and
  gopher servers, as well as to the local file system.
  
  The main attributes of the request objects are:
  
  =over 3
  
  =item *
  
  The B<method> is a short string that tells what kind of
  request this is.  The most common methods are B<GET>, B<PUT>,
  B<POST> and B<HEAD>.
  
  =item *
  
  The B<uri> is a string denoting the protocol, server and
  the name of the "document" we want to access.  The B<uri> might
  also encode various other parameters.
  
  =item *
  
  The B<headers> contain additional information about the
  request and can also used to describe the content.  The headers
  are a set of keyword/value pairs.
  
  =item *
  
  The B<content> is an arbitrary amount of data.
  
  =back
  
  =head2 The Response Object
  
  The libwww-perl response object has the class name C<HTTP::Response>.
  The main attributes of objects of this class are:
  
  =over 3
  
  =item *
  
  The B<code> is a numerical value that indicates the overall
  outcome of the request.
  
  =item *
  
  The B<message> is a short, human readable string that
  corresponds to the I<code>.
  
  =item *
  
  The B<headers> contain additional information about the
  response and describe the content.
  
  =item *
  
  The B<content> is an arbitrary amount of data.
  
  =back
  
  Since we don't want to handle all possible I<code> values directly in
  our programs, a libwww-perl response object has methods that can be
  used to query what kind of response this is.  The most commonly used
  response classification methods are:
  
  =over 3
  
  =item is_success()
  
  The request was was successfully received, understood or accepted.
  
  =item is_error()
  
  The request failed.  The server or the resource might not be
  available, access to the resource might be denied or other things might
  have failed for some reason.
  
  =back
  
  =head2 The User Agent
  
  Let us assume that we have created a I<request> object. What do we
  actually do with it in order to receive a I<response>?
  
  The answer is that you pass it to a I<user agent> object and this
  object takes care of all the things that need to be done
  (like low-level communication and error handling) and returns
  a I<response> object. The user agent represents your
  application on the network and provides you with an interface that
  can accept I<requests> and return I<responses>.
  
  The user agent is an interface layer between
  your application code and the network.  Through this interface you are
  able to access the various servers on the network.
  
  The class name for the user agent is C<LWP::UserAgent>.  Every
  libwww-perl application that wants to communicate should create at
  least one object of this class. The main method provided by this
  object is request(). This method takes an C<HTTP::Request> object as
  argument and (eventually) returns a C<HTTP::Response> object.
  
  The user agent has many other attributes that let you
  configure how it will interact with the network and with your
  application.
  
  =over 3
  
  =item *
  
  The B<timeout> specifies how much time we give remote servers to
  respond before the library disconnects and creates an
  internal I<timeout> response.
  
  =item *
  
  The B<agent> specifies the name that your application should use when it
  presents itself on the network.
  
  =item *
  
  The B<from> attribute can be set to the e-mail address of the person
  responsible for running the application.  If this is set, then the
  address will be sent to the servers with every request.
  
  =item *
  
  The B<parse_head> specifies whether we should initialize response
  headers from the E<lt>head> section of HTML documents.
  
  =item *
  
  The B<proxy> and B<no_proxy> attributes specify if and when to go through
  a proxy server. <URL:http://www.w3.org/pub/WWW/Proxies/>
  
  =item *
  
  The B<credentials> provide a way to set up user names and
  passwords needed to access certain services.
  
  =back
  
  Many applications want even more control over how they interact
  with the network and they get this by sub-classing
  C<LWP::UserAgent>.  The library includes a
  sub-class, C<LWP::RobotUA>, for robot applications.
  
  =head2 An Example
  
  This example shows how the user agent, a request and a response are
  represented in actual perl code:
  
    # Create a user agent object
    use LWP::UserAgent;
    my $ua = LWP::UserAgent->new;
    $ua->agent("MyApp/0.1 ");
  
    # Create a request
    my $req = HTTP::Request->new(POST => 'http://search.cpan.org/search');
    $req->content_type('application/x-www-form-urlencoded');
    $req->content('query=libwww-perl&mode=dist');
  
    # Pass request to the user agent and get a response back
    my $res = $ua->request($req);
  
    # Check the outcome of the response
    if ($res->is_success) {
        print $res->content;
    }
    else {
        print $res->status_line, "\n";
    }
  
  The $ua is created once when the application starts up.  New request
  objects should normally created for each request sent.
  
  
  =head1 NETWORK SUPPORT
  
  This section discusses the various protocol schemes and
  the HTTP style methods that headers may be used for each.
  
  For all requests, a "User-Agent" header is added and initialized from
  the $ua->agent attribute before the request is handed to the network
  layer.  In the same way, a "From" header is initialized from the
  $ua->from attribute.
  
  For all responses, the library adds a header called "Client-Date".
  This header holds the time when the response was received by
  your application.  The format and semantics of the header are the
  same as the server created "Date" header.  You may also encounter other
  "Client-XXX" headers.  They are all generated by the library
  internally and are not received from the servers.
  
  =head2 HTTP Requests
  
  HTTP requests are just handed off to an HTTP server and it
  decides what happens.  Few servers implement methods beside the usual
  "GET", "HEAD", "POST" and "PUT", but CGI-scripts may implement
  any method they like.
  
  If the server is not available then the library will generate an
  internal error response.
  
  The library automatically adds a "Host" and a "Content-Length" header
  to the HTTP request before it is sent over the network.
  
  For a GET request you might want to add a "If-Modified-Since" or
  "If-None-Match" header to make the request conditional.
  
  For a POST request you should add the "Content-Type" header.  When you
  try to emulate HTML E<lt>FORM> handling you should usually let the value
  of the "Content-Type" header be "application/x-www-form-urlencoded".
  See L<lwpcook> for examples of this.
  
  The libwww-perl HTTP implementation currently support the HTTP/1.1
  and HTTP/1.0 protocol.
  
  The library allows you to access proxy server through HTTP.  This
  means that you can set up the library to forward all types of request
  through the HTTP protocol module.  See L<LWP::UserAgent> for
  documentation of this.
  
  
  =head2 HTTPS Requests
  
  HTTPS requests are HTTP requests over an encrypted network connection
  using the SSL protocol developed by Netscape.  Everything about HTTP
  requests above also apply to HTTPS requests.  In addition the library
  will add the headers "Client-SSL-Cipher", "Client-SSL-Cert-Subject" and
  "Client-SSL-Cert-Issuer" to the response.  These headers denote the
  encryption method used and the name of the server owner.
  
  The request can contain the header "If-SSL-Cert-Subject" in order to
  make the request conditional on the content of the server certificate.
  If the certificate subject does not match, no request is sent to the
  server and an internally generated error response is returned.  The
  value of the "If-SSL-Cert-Subject" header is interpreted as a Perl
  regular expression.
  
  
  =head2 FTP Requests
  
  The library currently supports GET, HEAD and PUT requests.  GET
  retrieves a file or a directory listing from an FTP server.  PUT
  stores a file on a ftp server.
  
  You can specify a ftp account for servers that want this in addition
  to user name and password.  This is specified by including an "Account"
  header in the request.
  
  User name/password can be specified using basic authorization or be
  encoded in the URL.  Failed logins return an UNAUTHORIZED response with
  "WWW-Authenticate: Basic" and can be treated like basic authorization
  for HTTP.
  
  The library supports ftp ASCII transfer mode by specifying the "type=a"
  parameter in the URL. It also supports transfer of ranges for FTP transfers
  using the "Range" header.
  
  Directory listings are by default returned unprocessed (as returned
  from the ftp server) with the content media type reported to be
  "text/ftp-dir-listing". The C<File::Listing> module provides methods
  for parsing of these directory listing.
  
  The ftp module is also able to convert directory listings to HTML and
  this can be requested via the standard HTTP content negotiation
  mechanisms (add an "Accept: text/html" header in the request if you
  want this).
  
  For normal file retrievals, the "Content-Type" is guessed based on the
  file name suffix. See L<LWP::MediaTypes>.
  
  The "If-Modified-Since" request header works for servers that implement
  the MDTM command.  It will probably not work for directory listings though.
  
  Example:
  
    $req = HTTP::Request->new(GET => 'ftp://me:passwd@ftp.some.where.com/');
    $req->header(Accept => "text/html, */*;q=0.1");
  
  =head2 News Requests
  
  Access to the USENET News system is implemented through the NNTP
  protocol.  The name of the news server is obtained from the
  NNTP_SERVER environment variable and defaults to "news".  It is not
  possible to specify the hostname of the NNTP server in news: URLs.
  
  The library supports GET and HEAD to retrieve news articles through the
  NNTP protocol.  You can also post articles to newsgroups by using
  (surprise!) the POST method.
  
  GET on newsgroups is not implemented yet.
  
  Examples:
  
    $req = HTTP::Request->new(GET => 'news:abc1234@a.sn.no');
  
    $req = HTTP::Request->new(POST => 'news:comp.lang.perl.test');
    $req->header(Subject => 'This is a test',
                 From    => 'me@some.where.org');
    $req->content(<<EOT);
    This is the content of the message that we are sending to
    the world.
    EOT
  
  
  =head2 Gopher Request
  
  The library supports the GET and HEAD methods for gopher requests.  All
  request header values are ignored.  HEAD cheats and returns a
  response without even talking to server.
  
  Gopher menus are always converted to HTML.
  
  The response "Content-Type" is generated from the document type
  encoded (as the first letter) in the request URL path itself.
  
  Example:
  
    $req = HTTP::Request->new(GET => 'gopher://gopher.sn.no/');
  
  
  
  =head2 File Request
  
  The library supports GET and HEAD methods for file requests.  The
  "If-Modified-Since" header is supported.  All other headers are
  ignored.  The I<host> component of the file URL must be empty or set
  to "localhost".  Any other I<host> value will be treated as an error.
  
  Directories are always converted to an HTML document.  For normal
  files, the "Content-Type" and "Content-Encoding" in the response are
  guessed based on the file suffix.
  
  Example:
  
    $req = HTTP::Request->new(GET => 'file:/etc/passwd');
  
  
  =head2 Mailto Request
  
  You can send (aka "POST") mail messages using the library.  All
  headers specified for the request are passed on to the mail system.
  The "To" header is initialized from the mail address in the URL.
  
  Example:
  
    $req = HTTP::Request->new(POST => 'mailto:libwww@perl.org');
    $req->header(Subject => "subscribe");
    $req->content("Please subscribe me to the libwww-perl mailing list!\n");
  
  =head2 CPAN Requests
  
  URLs with scheme C<cpan:> are redirected to the a suitable CPAN
  mirror.  If you have your own local mirror of CPAN you might tell LWP
  to use it for C<cpan:> URLs by an assignment like this:
  
    $LWP::Protocol::cpan::CPAN = "file:/local/CPAN/";
  
  Suitable CPAN mirrors are also picked up from the configuration for
  the CPAN.pm, so if you have used that module a suitable mirror should
  be picked automatically.  If neither of these apply, then a redirect
  to the generic CPAN http location is issued.
  
  Example request to download the newest perl:
  
    $req = HTTP::Request->new(GET => "cpan:src/latest.tar.gz");
  
  
  =head1 OVERVIEW OF CLASSES AND PACKAGES
  
  This table should give you a quick overview of the classes provided by the
  library. Indentation shows class inheritance.
  
   LWP::MemberMixin   -- Access to member variables of Perl5 classes
     LWP::UserAgent   -- WWW user agent class
       LWP::RobotUA   -- When developing a robot applications
     LWP::Protocol          -- Interface to various protocol schemes
       LWP::Protocol::http  -- http:// access
       LWP::Protocol::file  -- file:// access
       LWP::Protocol::ftp   -- ftp:// access
       ...
  
   LWP::Authen::Basic -- Handle 401 and 407 responses
   LWP::Authen::Digest
  
   HTTP::Headers      -- MIME/RFC822 style header (used by HTTP::Message)
   HTTP::Message      -- HTTP style message
     HTTP::Request    -- HTTP request
     HTTP::Response   -- HTTP response
   HTTP::Daemon       -- A HTTP server class
  
   WWW::RobotRules    -- Parse robots.txt files
     WWW::RobotRules::AnyDBM_File -- Persistent RobotRules
  
   Net::HTTP          -- Low level HTTP client
  
  The following modules provide various functions and definitions.
  
   LWP                -- This file.  Library version number and documentation.
   LWP::MediaTypes    -- MIME types configuration (text/html etc.)
   LWP::Simple        -- Simplified procedural interface for common functions
   HTTP::Status       -- HTTP status code (200 OK etc)
   HTTP::Date         -- Date parsing module for HTTP date formats
   HTTP::Negotiate    -- HTTP content negotiation calculation
   File::Listing      -- Parse directory listings
   HTML::Form         -- Processing for <form>s in HTML documents
  
  
  =head1 MORE DOCUMENTATION
  
  All modules contain detailed information on the interfaces they
  provide.  The L<lwpcook> manpage is the libwww-perl cookbook that contain
  examples of typical usage of the library.  You might want to take a
  look at how the scripts L<lwp-request>, L<lwp-rget> and L<lwp-mirror>
  are implemented.
  
  =head1 ENVIRONMENT
  
  The following environment variables are used by LWP:
  
  =over
  
  =item HOME
  
  The C<LWP::MediaTypes> functions will look for the F<.media.types> and
  F<.mime.types> files relative to you home directory.
  
  =item http_proxy
  
  =item ftp_proxy
  
  =item xxx_proxy
  
  =item no_proxy
  
  These environment variables can be set to enable communication through
  a proxy server.  See the description of the C<env_proxy> method in
  L<LWP::UserAgent>.
  
  =item PERL_LWP_USE_HTTP_10
  
  Enable the old HTTP/1.0 protocol driver instead of the new HTTP/1.1
  driver.  You might want to set this to a TRUE value if you discover
  that your old LWP applications fails after you installed LWP-5.60 or
  better.
  
  =item PERL_HTTP_URI_CLASS
  
  Used to decide what URI objects to instantiate.  The default is C<URI>.
  You might want to set it to C<URI::URL> for compatibility with old times.
  
  =back
  
  =head1 AUTHORS
  
  LWP was made possible by contributions from Adam Newby, Albert
  Dvornik, Alexandre Duret-Lutz, Andreas Gustafsson, Andreas Knig,
  Andrew Pimlott, Andy Lester, Ben Coleman, Benjamin Low, Ben Low, Ben
  Tilly, Blair Zajac, Bob Dalgleish, BooK, Brad Hughes, Brian
  J. Murrell, Brian McCauley, Charles C. Fu, Charles Lane, Chris Nandor,
  Christian Gilmore, Chris W. Unger, Craig Macdonald, Dale Couch, Dan
  Kubb, Dave Dunkin, Dave W. Smith, David Coppit, David Dick, David
  D. Kilzer, Doug MacEachern, Edward Avis, erik, Gary Shea, Gisle Aas,
  Graham Barr, Gurusamy Sarathy, Hans de Graaff, Harald Joerg, Harry
  Bochner, Hugo, Ilya Zakharevich, INOUE Yoshinari, Ivan Panchenko, Jack
  Shirazi, James Tillman, Jan Dubois, Jared Rhine, Jim Stern, Joao
  Lopes, John Klar, Johnny Lee, Josh Kronengold, Josh Rai, Joshua
  Chamas, Joshua Hoblitt, Kartik Subbarao, Keiichiro Nagano, Ken
  Williams, KONISHI Katsuhiro, Lee T Lindley, Liam Quinn, Marc Hedlund,
  Marc Langheinrich, Mark D. Anderson, Marko Asplund, Mark Stosberg,
  Markus B Krger, Markus Laker, Martijn Koster, Martin Thurn, Matthew
  Eldridge, Matthew.van.Eerde, Matt Sergeant, Michael A. Chase, Michael
  Quaranta, Michael Thompson, Mike Schilli, Moshe Kaminsky, Nathan
  Torkington, Nicolai Langfeldt, Norton Allen, Olly Betts, Paul
  J. Schinder, peterm, Philip GuentherDaniel Buenzli, Pon Hwa Lin,
  Radoslaw Zielinski, Radu Greab, Randal L. Schwartz, Richard Chen,
  Robin Barker, Roy Fielding, Sander van Zoest, Sean M. Burke,
  shildreth, Slaven Rezic, Steve A Fink, Steve Hay, Steven Butler,
  Steve_Kilbane, Takanori Ugai, Thomas Lotterer, Tim Bunce, Tom Hughes,
  Tony Finch, Ville Skytt, Ward Vandewege, William York, Yale Huang,
  and Yitzchak Scott-Thoennes.
  
  LWP owes a lot in motivation, design, and code, to the libwww-perl
  library for Perl4 by Roy Fielding, which included work from Alberto
  Accomazzi, James Casey, Brooks Cutter, Martijn Koster, Oscar
  Nierstrasz, Mel Melchner, Gertjan van Oosten, Jared Rhine, Jack
  Shirazi, Gene Spafford, Marc VanHeyningen, Steven E. Brenner, Marion
  Hakanson, Waldemar Kebsch, Tony Sanders, and Larry Wall; see the
  libwww-perl-0.40 library for details.
  
  =head1 COPYRIGHT
  
    Copyright 1995-2009, Gisle Aas
    Copyright 1995, Martijn Koster
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =head1 AVAILABILITY
  
  The latest version of this library is likely to be available from CPAN
  as well as:
  
    http://github.com/gisle/libwww-perl
  
  The best place to discuss this code is on the <libwww@perl.org>
  mailing list.
  
  =cut
LWP

$fatpacked{"LWP/Authen/Basic.pm"} = <<'LWP_AUTHEN_BASIC';
  package LWP::Authen::Basic;
  use strict;
  
  require MIME::Base64;
  
  sub auth_header {
      my($class, $user, $pass) = @_;
      return "Basic " . MIME::Base64::encode("$user:$pass", "");
  }
  
  sub authenticate
  {
      my($class, $ua, $proxy, $auth_param, $response,
         $request, $arg, $size) = @_;
  
      my $realm = $auth_param->{realm} || "";
      my $url = $proxy ? $request->{proxy} : $request->uri_canonical;
      return $response unless $url;
      my $host_port = $url->host_port;
      my $auth_header = $proxy ? "Proxy-Authorization" : "Authorization";
  
      my @m = $proxy ? (m_proxy => $url) : (m_host_port => $host_port);
      push(@m, realm => $realm);
  
      my $h = $ua->get_my_handler("request_prepare", @m, sub {
          $_[0]{callback} = sub {
              my($req, $ua, $h) = @_;
              my($user, $pass) = $ua->credentials($host_port, $h->{realm});
  	    if (defined $user) {
  		my $auth_value = $class->auth_header($user, $pass, $req, $ua, $h);
  		$req->header($auth_header => $auth_value);
  	    }
          };
      });
      $h->{auth_param} = $auth_param;
  
      if (!$proxy && !$request->header($auth_header) && $ua->credentials($host_port, $realm)) {
  	# we can make sure this handler applies and retry
          add_path($h, $url->path);
          return $ua->request($request->clone, $arg, $size, $response);
      }
  
      my($user, $pass) = $ua->get_basic_credentials($realm, $url, $proxy);
      unless (defined $user and defined $pass) {
  	$ua->set_my_handler("request_prepare", undef, @m);  # delete handler
  	return $response;
      }
  
      # check that the password has changed
      my ($olduser, $oldpass) = $ua->credentials($host_port, $realm);
      return $response if (defined $olduser and defined $oldpass and
                           $user eq $olduser and $pass eq $oldpass);
  
      $ua->credentials($host_port, $realm, $user, $pass);
      add_path($h, $url->path) unless $proxy;
      return $ua->request($request->clone, $arg, $size, $response);
  }
  
  sub add_path {
      my($h, $path) = @_;
      $path =~ s,[^/]+\z,,;
      push(@{$h->{m_path_prefix}}, $path);
  }
  
  1;
LWP_AUTHEN_BASIC

$fatpacked{"LWP/Authen/Digest.pm"} = <<'LWP_AUTHEN_DIGEST';
  package LWP::Authen::Digest;
  
  use strict;
  use base 'LWP::Authen::Basic';
  
  require Digest::MD5;
  
  sub auth_header {
      my($class, $user, $pass, $request, $ua, $h) = @_;
  
      my $auth_param = $h->{auth_param};
  
      my $nc = sprintf "%08X", ++$ua->{authen_md5_nonce_count}{$auth_param->{nonce}};
      my $cnonce = sprintf "%8x", time;
  
      my $uri = $request->uri->path_query;
      $uri = "/" unless length $uri;
  
      my $md5 = Digest::MD5->new;
  
      my(@digest);
      $md5->add(join(":", $user, $auth_param->{realm}, $pass));
      push(@digest, $md5->hexdigest);
      $md5->reset;
  
      push(@digest, $auth_param->{nonce});
  
      if ($auth_param->{qop}) {
  	push(@digest, $nc, $cnonce, ($auth_param->{qop} =~ m|^auth[,;]auth-int$|) ? 'auth' : $auth_param->{qop});
      }
  
      $md5->add(join(":", $request->method, $uri));
      push(@digest, $md5->hexdigest);
      $md5->reset;
  
      $md5->add(join(":", @digest));
      my($digest) = $md5->hexdigest;
      $md5->reset;
  
      my %resp = map { $_ => $auth_param->{$_} } qw(realm nonce opaque);
      @resp{qw(username uri response algorithm)} = ($user, $uri, $digest, "MD5");
  
      if (($auth_param->{qop} || "") =~ m|^auth([,;]auth-int)?$|) {
  	@resp{qw(qop cnonce nc)} = ("auth", $cnonce, $nc);
      }
  
      my(@order) = qw(username realm qop algorithm uri nonce nc cnonce response);
      if($request->method =~ /^(?:POST|PUT)$/) {
  	$md5->add($request->content);
  	my $content = $md5->hexdigest;
  	$md5->reset;
  	$md5->add(join(":", @digest[0..1], $content));
  	$md5->reset;
  	$resp{"message-digest"} = $md5->hexdigest;
  	push(@order, "message-digest");
      }
      push(@order, "opaque");
      my @pairs;
      for (@order) {
  	next unless defined $resp{$_};
  	push(@pairs, "$_=" . qq("$resp{$_}"));
      }
  
      my $auth_value  = "Digest " . join(", ", @pairs);
      return $auth_value;
  }
  
  1;
LWP_AUTHEN_DIGEST

$fatpacked{"LWP/Authen/Ntlm.pm"} = <<'LWP_AUTHEN_NTLM';
  package LWP::Authen::Ntlm;
  
  use strict;
  use vars qw/$VERSION/;
  
  $VERSION = '5.835';
  
  use Authen::NTLM "1.02";
  use MIME::Base64 "2.12";
  
  sub authenticate {
      my($class, $ua, $proxy, $auth_param, $response,
         $request, $arg, $size) = @_;
  
      my($user, $pass) = $ua->get_basic_credentials($auth_param->{realm},
                                                    $request->uri, $proxy);
  
      unless(defined $user and defined $pass) {
  		return $response;
  	}
  
  	if (!$ua->conn_cache()) {
  		warn "The keep_alive option must be enabled for NTLM authentication to work.  NTLM authentication aborted.\n";
  		return $response;
  	}
  
  	my($domain, $username) = split(/\\/, $user);
  
  	ntlm_domain($domain);
  	ntlm_user($username);
  	ntlm_password($pass);
  
      my $auth_header = $proxy ? "Proxy-Authorization" : "Authorization";
  
  	# my ($challenge) = $response->header('WWW-Authenticate'); 
  	my $challenge;
  	foreach ($response->header('WWW-Authenticate')) { 
  		last if /^NTLM/ && ($challenge=$_);
  	}
  
  	if ($challenge eq 'NTLM') {
  		# First phase, send handshake
  	    my $auth_value = "NTLM " . ntlm();
  		ntlm_reset();
  
  	    # Need to check this isn't a repeated fail!
  	    my $r = $response;
  		my $retry_count = 0;
  	    while ($r) {
  			my $auth = $r->request->header($auth_header);
  			++$retry_count if ($auth && $auth eq $auth_value);
  			if ($retry_count > 2) {
  				    # here we know this failed before
  				    $response->header("Client-Warning" =>
  						      "Credentials for '$user' failed before");
  				    return $response;
  			}
  			$r = $r->previous;
  	    }
  
  	    my $referral = $request->clone;
  	    $referral->header($auth_header => $auth_value);
  	    return $ua->request($referral, $arg, $size, $response);
  	}
  	
  	else {
  		# Second phase, use the response challenge (unless non-401 code
  		#  was returned, in which case, we just send back the response
  		#  object, as is
  		my $auth_value;
  		if ($response->code ne '401') {
  			return $response;
  		}
  		else {
  			my $challenge;
  			foreach ($response->header('WWW-Authenticate')) { 
  				last if /^NTLM/ && ($challenge=$_);
  			}
  			$challenge =~ s/^NTLM //;
  			ntlm();
  			$auth_value = "NTLM " . ntlm($challenge);
  			ntlm_reset();
  		}
  
  	    my $referral = $request->clone;
  	    $referral->header($auth_header => $auth_value);
  	    my $response2 = $ua->request($referral, $arg, $size, $response);
  		return $response2;
  	}
  }
  
  1;
  
  
  =head1 NAME
  
  LWP::Authen::Ntlm - Library for enabling NTLM authentication (Microsoft) in LWP
  
  =head1 SYNOPSIS
  
   use LWP::UserAgent;
   use HTTP::Request::Common;
   my $url = 'http://www.company.com/protected_page.html';
  
   # Set up the ntlm client and then the base64 encoded ntlm handshake message
   my $ua = LWP::UserAgent->new(keep_alive=>1);
   $ua->credentials('www.company.com:80', '', "MyDomain\\MyUserCode", 'MyPassword');
  
   $request = GET $url;
   print "--Performing request now...-----------\n";
   $response = $ua->request($request);
   print "--Done with request-------------------\n";
  
   if ($response->is_success) {print "It worked!->" . $response->code . "\n"}
   else {print "It didn't work!->" . $response->code . "\n"}
  
  =head1 DESCRIPTION
  
  C<LWP::Authen::Ntlm> allows LWP to authenticate against servers that are using the 
  NTLM authentication scheme popularized by Microsoft.  This type of authentication is 
  common on intranets of Microsoft-centric organizations.
  
  The module takes advantage of the Authen::NTLM module by Mark Bush.  Since there 
  is also another Authen::NTLM module available from CPAN by Yee Man Chan with an 
  entirely different interface, it is necessary to ensure that you have the correct 
  NTLM module.
  
  In addition, there have been problems with incompatibilities between different 
  versions of Mime::Base64, which Bush's Authen::NTLM makes use of.  Therefore, it is 
  necessary to ensure that your Mime::Base64 module supports exporting of the 
  encode_base64 and decode_base64 functions.
  
  =head1 USAGE
  
  The module is used indirectly through LWP, rather than including it directly in your 
  code.  The LWP system will invoke the NTLM authentication when it encounters the 
  authentication scheme while attempting to retrieve a URL from a server.  In order 
  for the NTLM authentication to work, you must have a few things set up in your 
  code prior to attempting to retrieve the URL:
  
  =over 4
  
  =item *
  
  Enable persistent HTTP connections
  
  To do this, pass the "keep_alive=>1" option to the LWP::UserAgent when creating it, like this:
  
      my $ua = LWP::UserAgent->new(keep_alive=>1);
  
  =item *
  
  Set the credentials on the UserAgent object
  
  The credentials must be set like this:
  
     $ua->credentials('www.company.com:80', '', "MyDomain\\MyUserCode", 'MyPassword');
  
  Note that you cannot use the HTTP::Request object's authorization_basic() method to set 
  the credentials.  Note, too, that the 'www.company.com:80' portion only sets credentials 
  on the specified port AND it is case-sensitive (this is due to the way LWP is coded, and 
  has nothing to do with LWP::Authen::Ntlm)
  
  =back
  
  =head1 AVAILABILITY
  
  General queries regarding LWP should be made to the LWP Mailing List.
  
  Questions specific to LWP::Authen::Ntlm can be forwarded to jtillman@bigfoot.com
  
  =head1 COPYRIGHT
  
  Copyright (c) 2002 James Tillman. All rights reserved. This
  program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<LWP>, L<LWP::UserAgent>, L<lwpcook>.
LWP_AUTHEN_NTLM

$fatpacked{"LWP/ConnCache.pm"} = <<'LWP_CONNCACHE';
  package LWP::ConnCache;
  
  use strict;
  use vars qw($VERSION $DEBUG);
  
  $VERSION = "5.810";
  
  
  sub new {
      my($class, %cnf) = @_;
      my $total_capacity = delete $cnf{total_capacity};
      $total_capacity = 1 unless defined $total_capacity;
      if (%cnf && $^W) {
  	require Carp;
  	Carp::carp("Unrecognised options: @{[sort keys %cnf]}")
      }
      my $self = bless { cc_conns => [] }, $class;
      $self->total_capacity($total_capacity);
      $self;
  }
  
  
  sub deposit {
      my($self, $type, $key, $conn) = @_;
      push(@{$self->{cc_conns}}, [$conn, $type, $key, time]);
      $self->enforce_limits($type);
      return;
  }
  
  
  sub withdraw {
      my($self, $type, $key) = @_;
      my $conns = $self->{cc_conns};
      for my $i (0 .. @$conns - 1) {
  	my $c = $conns->[$i];
  	next unless $c->[1] eq $type && $c->[2] eq $key;
  	splice(@$conns, $i, 1);  # remove it
  	return $c->[0];
      }
      return undef;
  }
  
  
  sub total_capacity {
      my $self = shift;
      my $old = $self->{cc_limit_total};
      if (@_) {
  	$self->{cc_limit_total} = shift;
  	$self->enforce_limits;
      }
      $old;
  }
  
  
  sub capacity {
      my $self = shift;
      my $type = shift;
      my $old = $self->{cc_limit}{$type};
      if (@_) {
  	$self->{cc_limit}{$type} = shift;
  	$self->enforce_limits($type);
      }
      $old;
  }
  
  
  sub enforce_limits {
      my($self, $type) = @_;
      my $conns = $self->{cc_conns};
  
      my @types = $type ? ($type) : ($self->get_types);
      for $type (@types) {
  	next unless $self->{cc_limit};
  	my $limit = $self->{cc_limit}{$type};
  	next unless defined $limit;
  	for my $i (reverse 0 .. @$conns - 1) {
  	    next unless $conns->[$i][1] eq $type;
  	    if (--$limit < 0) {
  		$self->dropping(splice(@$conns, $i, 1), "$type capacity exceeded");
  	    }
  	}
      }
  
      if (defined(my $total = $self->{cc_limit_total})) {
  	while (@$conns > $total) {
  	    $self->dropping(shift(@$conns), "Total capacity exceeded");
  	}
      }
  }
  
  
  sub dropping {
      my($self, $c, $reason) = @_;
      print "DROPPING @$c [$reason]\n" if $DEBUG;
  }
  
  
  sub drop {
      my($self, $checker, $reason) = @_;
      if (ref($checker) ne "CODE") {
  	# make it so
  	if (!defined $checker) {
  	    $checker = sub { 1 };  # drop all of them
  	}
  	elsif (_looks_like_number($checker)) {
  	    my $age_limit = $checker;
  	    my $time_limit = time - $age_limit;
  	    $reason ||= "older than $age_limit";
  	    $checker = sub { $_[3] < $time_limit };
  	}
  	else {
  	    my $type = $checker;
  	    $reason ||= "drop $type";
  	    $checker = sub { $_[1] eq $type };  # match on type
  	}
      }
      $reason ||= "drop";
  
      local $SIG{__DIE__};  # don't interfere with eval below
      local $@;
      my @c;
      for (@{$self->{cc_conns}}) {
  	my $drop;
  	eval {
  	    if (&$checker(@$_)) {
  		$self->dropping($_, $reason);
  		$drop++;
  	    }
  	};
  	push(@c, $_) unless $drop;
      }
      @{$self->{cc_conns}} = @c;
  }
  
  
  sub prune {
      my $self = shift;
      $self->drop(sub { !shift->ping }, "ping");
  }
  
  
  sub get_types {
      my $self = shift;
      my %t;
      $t{$_->[1]}++ for @{$self->{cc_conns}};
      return keys %t;
  }
  
  
  sub get_connections {
      my($self, $type) = @_;
      my @c;
      for (@{$self->{cc_conns}}) {
  	push(@c, $_->[0]) if !$type || ($type && $type eq $_->[1]);
      }
      @c;
  }
  
  
  sub _looks_like_number {
      $_[0] =~ /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/;
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  LWP::ConnCache - Connection cache manager
  
  =head1 NOTE
  
  This module is experimental.  Details of its interface is likely to
  change in the future.
  
  =head1 SYNOPSIS
  
   use LWP::ConnCache;
   my $cache = LWP::ConnCache->new;
   $cache->deposit($type, $key, $sock);
   $sock = $cache->withdraw($type, $key);
  
  =head1 DESCRIPTION
  
  The C<LWP::ConnCache> class is the standard connection cache manager
  for LWP::UserAgent.
  
  The following basic methods are provided:
  
  =over
  
  =item $cache = LWP::ConnCache->new( %options )
  
  This method constructs a new C<LWP::ConnCache> object.  The only
  option currently accepted is 'total_capacity'.  If specified it
  initialize the total_capacity option.  It defaults to the value 1.
  
  =item $cache->total_capacity( [$num_connections] )
  
  Get/sets the number of connection that will be cached.  Connections
  will start to be dropped when this limit is reached.  If set to C<0>,
  then all connections are immediately dropped.  If set to C<undef>,
  then there is no limit.
  
  =item $cache->capacity($type, [$num_connections] )
  
  Get/set a limit for the number of connections of the specified type
  that can be cached.  The $type will typically be a short string like
  "http" or "ftp".
  
  =item $cache->drop( [$checker, [$reason]] )
  
  Drop connections by some criteria.  The $checker argument is a
  subroutine that is called for each connection.  If the routine returns
  a TRUE value then the connection is dropped.  The routine is called
  with ($conn, $type, $key, $deposit_time) as arguments.
  
  Shortcuts: If the $checker argument is absent (or C<undef>) all cached
  connections are dropped.  If the $checker is a number then all
  connections untouched that the given number of seconds or more are
  dropped.  If $checker is a string then all connections of the given
  type are dropped.
  
  The $reason argument is passed on to the dropped() method.
  
  =item $cache->prune
  
  Calling this method will drop all connections that are dead.  This is
  tested by calling the ping() method on the connections.  If the ping()
  method exists and returns a FALSE value, then the connection is
  dropped.
  
  =item $cache->get_types
  
  This returns all the 'type' fields used for the currently cached
  connections.
  
  =item $cache->get_connections( [$type] )
  
  This returns all connection objects of the specified type.  If no type
  is specified then all connections are returned.  In scalar context the
  number of cached connections of the specified type is returned.
  
  =back
  
  
  The following methods are called by low-level protocol modules to
  try to save away connections and to get them back.
  
  =over
  
  =item $cache->deposit($type, $key, $conn)
  
  This method adds a new connection to the cache.  As a result other
  already cached connections might be dropped.  Multiple connections with
  the same $type/$key might added.
  
  =item $conn = $cache->withdraw($type, $key)
  
  This method tries to fetch back a connection that was previously
  deposited.  If no cached connection with the specified $type/$key is
  found, then C<undef> is returned.  There is not guarantee that a
  deposited connection can be withdrawn, as the cache manger is free to
  drop connections at any time.
  
  =back
  
  The following methods are called internally.  Subclasses might want to
  override them.
  
  =over
  
  =item $conn->enforce_limits([$type])
  
  This method is called with after a new connection is added (deposited)
  in the cache or capacity limits are adjusted.  The default
  implementation drops connections until the specified capacity limits
  are not exceeded.
  
  =item $conn->dropping($conn_record, $reason)
  
  This method is called when a connection is dropped.  The record
  belonging to the dropped connection is passed as the first argument
  and a string describing the reason for the drop is passed as the
  second argument.  The default implementation makes some noise if the
  $LWP::ConnCache::DEBUG variable is set and nothing more.
  
  =back
  
  =head1 SUBCLASSING
  
  For specialized cache policy it makes sense to subclass
  C<LWP::ConnCache> and perhaps override the deposit(), enforce_limits()
  and dropping() methods.
  
  The object itself is a hash.  Keys prefixed with C<cc_> are reserved
  for the base class.
  
  =head1 SEE ALSO
  
  L<LWP::UserAgent>
  
  =head1 COPYRIGHT
  
  Copyright 2001 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
LWP_CONNCACHE

$fatpacked{"LWP/Debug.pm"} = <<'LWP_DEBUG';
  package LWP::Debug;  # legacy
  
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT_OK = qw(level trace debug conns);
  
  use Carp ();
  
  my @levels = qw(trace debug conns);
  %current_level = ();
  
  
  sub import
  {
      my $pack = shift;
      my $callpkg = caller(0);
      my @symbols = ();
      my @levels = ();
      for (@_) {
  	if (/^[-+]/) {
  	    push(@levels, $_);
  	}
  	else {
  	    push(@symbols, $_);
  	}
      }
      Exporter::export($pack, $callpkg, @symbols);
      level(@levels);
  }
  
  
  sub level
  {
      for (@_) {
  	if ($_ eq '+') {              # all on
  	    # switch on all levels
  	    %current_level = map { $_ => 1 } @levels;
  	}
  	elsif ($_ eq '-') {           # all off
  	    %current_level = ();
  	}
  	elsif (/^([-+])(\w+)$/) {
  	    $current_level{$2} = $1 eq '+';
  	}
  	else {
  	    Carp::croak("Illegal level format $_");
  	}
      }
  }
  
  
  sub trace  { _log(@_) if $current_level{'trace'}; }
  sub debug  { _log(@_) if $current_level{'debug'}; }
  sub conns  { _log(@_) if $current_level{'conns'}; }
  
  
  sub _log
  {
      my $msg = shift;
      $msg .= "\n" unless $msg =~ /\n$/;  # ensure trailing "\n"
  
      my($package,$filename,$line,$sub) = caller(2);
      print STDERR "$sub: $msg";
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  LWP::Debug - deprecated
  
  =head1 DESCRIPTION
  
  LWP::Debug used to provide tracing facilities, but these are not used
  by LWP any more.  The code in this module is kept around
  (undocumented) so that 3rd party code that happen to use the old
  interfaces continue to run.
  
  One useful feature that LWP::Debug provided (in an imprecise and
  troublesome way) was network traffic monitoring.  The following
  section provide some hints about recommened replacements.
  
  =head2 Network traffic monitoring
  
  The best way to monitor the network traffic that LWP generates is to
  use an external TCP monitoring program.  The Wireshark program
  (L<http://www.wireshark.org/>) is higly recommended for this.
  
  Another approach it to use a debugging HTTP proxy server and make
  LWP direct all its traffic via this one.  Call C<< $ua->proxy >> to
  set it up and then just use LWP as before.
  
  For less precise monitoring needs just setting up a few simple
  handlers might do.  The following example sets up handlers to dump the
  request and response objects that pass through LWP:
  
    use LWP::UserAgent;
    $ua = LWP::UserAgent->new;
    $ua->default_header('Accept-Encoding' => scalar HTTP::Message::decodable());
  
    $ua->add_handler("request_send",  sub { shift->dump; return });
    $ua->add_handler("response_done", sub { shift->dump; return });
  
    $ua->get("http://www.example.com");
  
  =head1 SEE ALSO
  
  L<LWP::UserAgent>
LWP_DEBUG

$fatpacked{"LWP/DebugFile.pm"} = <<'LWP_DEBUGFILE';
  package LWP::DebugFile;
  
  # legacy stub
  
  1;
LWP_DEBUGFILE

$fatpacked{"LWP/MediaTypes.pm"} = <<'LWP_MEDIATYPES';
  package LWP::MediaTypes;
  
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT = qw(guess_media_type media_suffix);
  @EXPORT_OK = qw(add_type add_encoding read_media_types);
  $VERSION = "5.835";
  
  use strict;
  
  # note: These hashes will also be filled with the entries found in
  # the 'media.types' file.
  
  my %suffixType = (
      'txt'   => 'text/plain',
      'html'  => 'text/html',
      'gif'   => 'image/gif',
      'jpg'   => 'image/jpeg',
      'xml'   => 'text/xml',
  );
  
  my %suffixExt = (
      'text/plain' => 'txt',
      'text/html'  => 'html',
      'image/gif'  => 'gif',
      'image/jpeg' => 'jpg',
      'text/xml'   => 'xml',
  );
  
  #XXX: there should be some way to define this in the media.types files.
  my %suffixEncoding = (
      'Z'   => 'compress',
      'gz'  => 'gzip',
      'hqx' => 'x-hqx',
      'uu'  => 'x-uuencode',
      'z'   => 'x-pack',
      'bz2' => 'x-bzip2',
  );
  
  read_media_types();
  
  
  
  sub _dump {
      require Data::Dumper;
      Data::Dumper->new([\%suffixType, \%suffixExt, \%suffixEncoding],
  		      [qw(*suffixType *suffixExt *suffixEncoding)])->Dump;
  }
  
  
  sub guess_media_type
  {
      my($file, $header) = @_;
      return undef unless defined $file;
  
      my $fullname;
      if (ref($file)) {
  	# assume URI object
  	$file = $file->path;
  	#XXX should handle non http:, file: or ftp: URIs differently
      }
      else {
  	$fullname = $file;  # enable peek at actual file
      }
  
      my @encoding = ();
      my $ct = undef;
      for (file_exts($file)) {
  	# first check this dot part as encoding spec
  	if (exists $suffixEncoding{$_}) {
  	    unshift(@encoding, $suffixEncoding{$_});
  	    next;
  	}
  	if (exists $suffixEncoding{lc $_}) {
  	    unshift(@encoding, $suffixEncoding{lc $_});
  	    next;
  	}
  
  	# check content-type
  	if (exists $suffixType{$_}) {
  	    $ct = $suffixType{$_};
  	    last;
  	}
  	if (exists $suffixType{lc $_}) {
  	    $ct = $suffixType{lc $_};
  	    last;
  	}
  
  	# don't know nothing about this dot part, bail out
  	last;
      }
      unless (defined $ct) {
  	# Take a look at the file
  	if (defined $fullname) {
  	    $ct = (-T $fullname) ? "text/plain" : "application/octet-stream";
  	}
  	else {
  	    $ct = "application/octet-stream";
  	}
      }
  
      if ($header) {
  	$header->header('Content-Type' => $ct);
  	$header->header('Content-Encoding' => \@encoding) if @encoding;
      }
  
      wantarray ? ($ct, @encoding) : $ct;
  }
  
  
  sub media_suffix {
      if (!wantarray && @_ == 1 && $_[0] !~ /\*/) {
  	return $suffixExt{lc $_[0]};
      }
      my(@type) = @_;
      my(@suffix, $ext, $type);
      foreach (@type) {
  	if (s/\*/.*/) {
  	    while(($ext,$type) = each(%suffixType)) {
  		push(@suffix, $ext) if $type =~ /^$_$/i;
  	    }
  	}
  	else {
  	    my $ltype = lc $_;
  	    while(($ext,$type) = each(%suffixType)) {
  		push(@suffix, $ext) if lc $type eq $ltype;
  	    }
  	}
      }
      wantarray ? @suffix : $suffix[0];
  }
  
  
  sub file_exts 
  {
      require File::Basename;
      my @parts = reverse split(/\./, File::Basename::basename($_[0]));
      pop(@parts);        # never consider first part
      @parts;
  }
  
  
  sub add_type 
  {
      my($type, @exts) = @_;
      for my $ext (@exts) {
  	$ext =~ s/^\.//;
  	$suffixType{$ext} = $type;
      }
      $suffixExt{lc $type} = $exts[0] if @exts;
  }
  
  
  sub add_encoding
  {
      my($type, @exts) = @_;
      for my $ext (@exts) {
  	$ext =~ s/^\.//;
  	$suffixEncoding{$ext} = $type;
      }
  }
  
  
  sub read_media_types 
  {
      my(@files) = @_;
  
      local($/, $_) = ("\n", undef);  # ensure correct $INPUT_RECORD_SEPARATOR
  
      my @priv_files = ();
      if($^O eq "MacOS") {
  	push(@priv_files, "$ENV{HOME}:media.types", "$ENV{HOME}:mime.types")
  	    if defined $ENV{HOME};  # Some does not have a home (for instance Win32)
      }
      else {
  	push(@priv_files, "$ENV{HOME}/.media.types", "$ENV{HOME}/.mime.types")
  	    if defined $ENV{HOME};  # Some doesn't have a home (for instance Win32)
      }
  
      # Try to locate "media.types" file, and initialize %suffixType from it
      my $typefile;
      unless (@files) {
  	if($^O eq "MacOS") {
  	    @files = map {$_."LWP:media.types"} @INC;
  	}
  	else {
  	    @files = map {"$_/LWP/media.types"} @INC;
  	}
  	push @files, @priv_files;
      }
      for $typefile (@files) {
  	local(*TYPE);
  	open(TYPE, $typefile) || next;
  	while (<TYPE>) {
  	    next if /^\s*#/; # comment line
  	    next if /^\s*$/; # blank line
  	    s/#.*//;         # remove end-of-line comments
  	    my($type, @exts) = split(' ', $_);
  	    add_type($type, @exts);
  	}
  	close(TYPE);
      }
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  LWP::MediaTypes - guess media type for a file or a URL
  
  =head1 SYNOPSIS
  
   use LWP::MediaTypes qw(guess_media_type);
   $type = guess_media_type("/tmp/foo.gif");
  
  =head1 DESCRIPTION
  
  This module provides functions for handling media (also known as
  MIME) types and encodings.  The mapping from file extensions to media
  types is defined by the F<media.types> file.  If the F<~/.media.types>
  file exists it is used instead.
  For backwards compatibility we will also look for F<~/.mime.types>.
  
  The following functions are exported by default:
  
  =over 4
  
  =item guess_media_type( $filename )
  
  =item guess_media_type( $uri )
  
  =item guess_media_type( $filename_or_uri, $header_to_modify )
  
  This function tries to guess media type and encoding for a file or a URI.
  It returns the content type, which is a string like C<"text/html">.
  In array context it also returns any content encodings applied (in the
  order used to encode the file).  You can pass a URI object
  reference, instead of the file name.
  
  If the type can not be deduced from looking at the file name,
  then guess_media_type() will let the C<-T> Perl operator take a look.
  If this works (and C<-T> returns a TRUE value) then we return
  I<text/plain> as the type, otherwise we return
  I<application/octet-stream> as the type.
  
  The optional second argument should be a reference to a HTTP::Headers
  object or any object that implements the $obj->header method in a
  similar way.  When it is present the values of the
  'Content-Type' and 'Content-Encoding' will be set for this header.
  
  =item media_suffix( $type, ... )
  
  This function will return all suffixes that can be used to denote the
  specified media type(s).  Wildcard types can be used.  In a scalar
  context it will return the first suffix found. Examples:
  
    @suffixes = media_suffix('image/*', 'audio/basic');
    $suffix = media_suffix('text/html');
  
  =back
  
  The following functions are only exported by explicit request:
  
  =over 4
  
  =item add_type( $type, @exts )
  
  Associate a list of file extensions with the given media type.
  Example:
  
      add_type("x-world/x-vrml" => qw(wrl vrml));
  
  =item add_encoding( $type, @ext )
  
  Associate a list of file extensions with an encoding type.
  Example:
  
   add_encoding("x-gzip" => "gz");
  
  =item read_media_types( @files )
  
  Parse media types files and add the type mappings found there.
  Example:
  
      read_media_types("conf/mime.types");
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 1995-1999 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
LWP_MEDIATYPES

$fatpacked{"LWP/MemberMixin.pm"} = <<'LWP_MEMBERMIXIN';
  package LWP::MemberMixin;
  
  sub _elem
  {
      my $self = shift;
      my $elem = shift;
      my $old = $self->{$elem};
      $self->{$elem} = shift if @_;
      return $old;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  LWP::MemberMixin - Member access mixin class
  
  =head1 SYNOPSIS
  
   package Foo;
   require LWP::MemberMixin;
   @ISA=qw(LWP::MemberMixin);
  
  =head1 DESCRIPTION
  
  A mixin class to get methods that provide easy access to member
  variables in the %$self.
  Ideally there should be better Perl language support for this.
  
  There is only one method provided:
  
  =over 4
  
  =item _elem($elem [, $val])
  
  Internal method to get/set the value of member variable
  C<$elem>. If C<$val> is present it is used as the new value
  for the member variable.  If it is not present the current
  value is not touched. In both cases the previous value of
  the member variable is returned.
  
  =back
LWP_MEMBERMIXIN

$fatpacked{"LWP/Protocol.pm"} = <<'LWP_PROTOCOL';
  package LWP::Protocol;
  
  require LWP::MemberMixin;
  @ISA = qw(LWP::MemberMixin);
  $VERSION = "5.829";
  
  use strict;
  use Carp ();
  use HTTP::Status ();
  use HTTP::Response;
  
  my %ImplementedBy = (); # scheme => classname
  
  
  
  sub new
  {
      my($class, $scheme, $ua) = @_;
  
      my $self = bless {
  	scheme => $scheme,
  	ua => $ua,
  
  	# historical/redundant
          max_size => $ua->{max_size},
      }, $class;
  
      $self;
  }
  
  
  sub create
  {
      my($scheme, $ua) = @_;
      my $impclass = LWP::Protocol::implementor($scheme) or
  	Carp::croak("Protocol scheme '$scheme' is not supported");
  
      # hand-off to scheme specific implementation sub-class
      my $protocol = $impclass->new($scheme, $ua);
  
      return $protocol;
  }
  
  
  sub implementor
  {
      my($scheme, $impclass) = @_;
  
      if ($impclass) {
  	$ImplementedBy{$scheme} = $impclass;
      }
      my $ic = $ImplementedBy{$scheme};
      return $ic if $ic;
  
      return '' unless $scheme =~ /^([.+\-\w]+)$/;  # check valid URL schemes
      $scheme = $1; # untaint
      $scheme =~ s/[.+\-]/_/g;  # make it a legal module name
  
      # scheme not yet known, look for a 'use'd implementation
      $ic = "LWP::Protocol::$scheme";  # default location
      $ic = "LWP::Protocol::nntp" if $scheme eq 'news'; #XXX ugly hack
      no strict 'refs';
      # check we actually have one for the scheme:
      unless (@{"${ic}::ISA"}) {
  	# try to autoload it
  	eval "require $ic";
  	if ($@) {
  	    if ($@ =~ /Can't locate/) { #' #emacs get confused by '
  		$ic = '';
  	    }
  	    else {
  		die "$@\n";
  	    }
  	}
      }
      $ImplementedBy{$scheme} = $ic if $ic;
      $ic;
  }
  
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
      Carp::croak('LWP::Protocol::request() needs to be overridden in subclasses');
  }
  
  
  # legacy
  sub timeout    { shift->_elem('timeout',    @_); }
  sub max_size   { shift->_elem('max_size',   @_); }
  
  
  sub collect
  {
      my ($self, $arg, $response, $collector) = @_;
      my $content;
      my($ua, $max_size) = @{$self}{qw(ua max_size)};
  
      eval {
  	local $\; # protect the print below from surprises
          if (!defined($arg) || !$response->is_success) {
              $response->{default_add_content} = 1;
          }
          elsif (!ref($arg) && length($arg)) {
              open(my $fh, ">", $arg) or die "Can't write to '$arg': $!";
  	    binmode($fh);
              push(@{$response->{handlers}{response_data}}, {
                  callback => sub {
                      print $fh $_[3] or die "Can't write to '$arg': $!";
                      1;
                  },
              });
              push(@{$response->{handlers}{response_done}}, {
                  callback => sub {
  		    close($fh) or die "Can't write to '$arg': $!";
  		    undef($fh);
  		},
  	    });
          }
          elsif (ref($arg) eq 'CODE') {
              push(@{$response->{handlers}{response_data}}, {
                  callback => sub {
  		    &$arg($_[3], $_[0], $self);
  		    1;
                  },
              });
          }
          else {
              die "Unexpected collect argument '$arg'";
          }
  
          $ua->run_handlers("response_header", $response);
  
          if (delete $response->{default_add_content}) {
              push(@{$response->{handlers}{response_data}}, {
  		callback => sub {
  		    $_[0]->add_content($_[3]);
  		    1;
  		},
  	    });
          }
  
  
          my $content_size = 0;
          my $length = $response->content_length;
          my %skip_h;
  
          while ($content = &$collector, length $$content) {
              for my $h ($ua->handlers("response_data", $response)) {
                  next if $skip_h{$h};
                  unless ($h->{callback}->($response, $ua, $h, $$content)) {
                      # XXX remove from $response->{handlers}{response_data} if present
                      $skip_h{$h}++;
                  }
              }
              $content_size += length($$content);
              $ua->progress(($length ? ($content_size / $length) : "tick"), $response);
              if (defined($max_size) && $content_size > $max_size) {
                  $response->push_header("Client-Aborted", "max_size");
                  last;
              }
          }
      };
      my $err = $@;
      delete $response->{handlers}{response_data};
      delete $response->{handlers} unless %{$response->{handlers}};
      if ($err) {
          chomp($err);
          $response->push_header('X-Died' => $err);
          $response->push_header("Client-Aborted", "die");
          return $response;
      }
  
      return $response;
  }
  
  
  sub collect_once
  {
      my($self, $arg, $response) = @_;
      my $content = \ $_[3];
      my $first = 1;
      $self->collect($arg, $response, sub {
  	return $content if $first--;
  	return \ "";
      });
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  LWP::Protocol - Base class for LWP protocols
  
  =head1 SYNOPSIS
  
   package LWP::Protocol::foo;
   require LWP::Protocol;
   @ISA=qw(LWP::Protocol);
  
  =head1 DESCRIPTION
  
  This class is used a the base class for all protocol implementations
  supported by the LWP library.
  
  When creating an instance of this class using
  C<LWP::Protocol::create($url)>, and you get an initialised subclass
  appropriate for that access method. In other words, the
  LWP::Protocol::create() function calls the constructor for one of its
  subclasses.
  
  All derived LWP::Protocol classes need to override the request()
  method which is used to service a request. The overridden method can
  make use of the collect() function to collect together chunks of data
  as it is received.
  
  The following methods and functions are provided:
  
  =over 4
  
  =item $prot = LWP::Protocol->new()
  
  The LWP::Protocol constructor is inherited by subclasses. As this is a
  virtual base class this method should B<not> be called directly.
  
  =item $prot = LWP::Protocol::create($scheme)
  
  Create an object of the class implementing the protocol to handle the
  given scheme. This is a function, not a method. It is more an object
  factory than a constructor. This is the function user agents should
  use to access protocols.
  
  =item $class = LWP::Protocol::implementor($scheme, [$class])
  
  Get and/or set implementor class for a scheme.  Returns '' if the
  specified scheme is not supported.
  
  =item $prot->request(...)
  
   $response = $protocol->request($request, $proxy, undef);
   $response = $protocol->request($request, $proxy, '/tmp/sss');
   $response = $protocol->request($request, $proxy, \&callback, 1024);
  
  Dispatches a request over the protocol, and returns a response
  object. This method needs to be overridden in subclasses.  Refer to
  L<LWP::UserAgent> for description of the arguments.
  
  =item $prot->collect($arg, $response, $collector)
  
  Called to collect the content of a request, and process it
  appropriately into a scalar, file, or by calling a callback.  If $arg
  is undefined, then the content is stored within the $response.  If
  $arg is a simple scalar, then $arg is interpreted as a file name and
  the content is written to this file.  If $arg is a reference to a
  routine, then content is passed to this routine.
  
  The $collector is a routine that will be called and which is
  responsible for returning pieces (as ref to scalar) of the content to
  process.  The $collector signals EOF by returning a reference to an
  empty sting.
  
  The return value from collect() is the $response object reference.
  
  B<Note:> We will only use the callback or file argument if
  $response->is_success().  This avoids sending content data for
  redirects and authentication responses to the callback which would be
  confusing.
  
  =item $prot->collect_once($arg, $response, $content)
  
  Can be called when the whole response content is available as
  $content.  This will invoke collect() with a collector callback that
  returns a reference to $content the first time and an empty string the
  next.
  
  =back
  
  =head1 SEE ALSO
  
  Inspect the F<LWP/Protocol/file.pm> and F<LWP/Protocol/http.pm> files
  for examples of usage.
  
  =head1 COPYRIGHT
  
  Copyright 1995-2001 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
LWP_PROTOCOL

$fatpacked{"LWP/Protocol/GHTTP.pm"} = <<'LWP_PROTOCOL_GHTTP';
  package LWP::Protocol::GHTTP;
  
  # You can tell LWP to use this module for 'http' requests by running
  # code like this before you make requests:
  #
  #    require LWP::Protocol::GHTTP;
  #    LWP::Protocol::implementor('http', 'LWP::Protocol::GHTTP');
  #
  
  use strict;
  use vars qw(@ISA);
  
  require LWP::Protocol;
  @ISA=qw(LWP::Protocol);
  
  require HTTP::Response;
  require HTTP::Status;
  
  use HTTP::GHTTP qw(METHOD_GET METHOD_HEAD METHOD_POST);
  
  my %METHOD =
  (
   GET  => METHOD_GET,
   HEAD => METHOD_HEAD,
   POST => METHOD_POST,
  );
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
  
      my $method = $request->method;
      unless (exists $METHOD{$method}) {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   "Bad method '$method'");
      }
  
      my $r = HTTP::GHTTP->new($request->uri);
  
      # XXX what headers for repeated headers here?
      $request->headers->scan(sub { $r->set_header(@_)});
  
      $r->set_type($METHOD{$method});
  
      # XXX should also deal with subroutine content.
      my $cref = $request->content_ref;
      $r->set_body($$cref) if length($$cref);
  
      # XXX is this right
      $r->set_proxy($proxy->as_string) if $proxy;
  
      $r->process_request;
  
      my $response = HTTP::Response->new($r->get_status);
  
      # XXX How can get the headers out of $r??  This way is too stupid.
      my @headers;
      eval {
  	# Wrapped in eval because this method is not always available
  	@headers = $r->get_headers;
      };
      @headers = qw(Date Connection Server Content-type
                    Accept-Ranges Server
                    Content-Length Last-Modified ETag) if $@;
      for (@headers) {
  	my $v = $r->get_header($_);
  	$response->header($_ => $v) if defined $v;
      }
  
      return $self->collect_once($arg, $response, $r->get_body);
  }
  
  1;
LWP_PROTOCOL_GHTTP

$fatpacked{"LWP/Protocol/cpan.pm"} = <<'LWP_PROTOCOL_CPAN';
  package LWP::Protocol::cpan;
  
  use strict;
  use vars qw(@ISA);
  
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  require URI;
  require HTTP::Status;
  require HTTP::Response;
  
  our $CPAN;
  
  unless ($CPAN) {
      # Try to find local CPAN mirror via $CPAN::Config
      eval {
  	require CPAN::Config;
  	if($CPAN::Config) {
  	    my $urls = $CPAN::Config->{urllist};
  	    if (ref($urls) eq "ARRAY") {
  		my $file;
  		for (@$urls) {
  		    if (/^file:/) {
  			$file = $_;
  			last;
  		    }
  		}
  
  		if ($file) {
  		    $CPAN = $file;
  		}
  		else {
  		    $CPAN = $urls->[0];
  		}
  	    }
  	}
      };
  
      $CPAN ||= "http://cpan.org/";  # last resort
  }
  
  # ensure that we don't chop of last part
  $CPAN .= "/" unless $CPAN =~ m,/$,;
  
  
  sub request {
      my($self, $request, $proxy, $arg, $size) = @_;
      # check proxy
      if (defined $proxy)
      {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   'You can not proxy with cpan');
      }
  
      # check method
      my $method = $request->method;
      unless ($method eq 'GET' || $method eq 'HEAD') {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   'Library does not allow method ' .
  				   "$method for 'cpan:' URLs");
      }
  
      my $path = $request->uri->path;
      $path =~ s,^/,,;
  
      my $response = HTTP::Response->new(&HTTP::Status::RC_FOUND);
      $response->header("Location" => URI->new_abs($path, $CPAN));
      $response;
  }
  
  1;
LWP_PROTOCOL_CPAN

$fatpacked{"LWP/Protocol/data.pm"} = <<'LWP_PROTOCOL_DATA';
  package LWP::Protocol::data;
  
  # Implements access to data:-URLs as specified in RFC 2397
  
  use strict;
  use vars qw(@ISA);
  
  require HTTP::Response;
  require HTTP::Status;
  
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  use HTTP::Date qw(time2str);
  require LWP;  # needs version number
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size) = @_;
  
      # check proxy
      if (defined $proxy)
      {
  	return HTTP::Response->new( &HTTP::Status::RC_BAD_REQUEST,
  				  'You can not proxy with data');
      }
  
      # check method
      my $method = $request->method;
      unless ($method eq 'GET' || $method eq 'HEAD') {
  	return HTTP::Response->new( &HTTP::Status::RC_BAD_REQUEST,
  				  'Library does not allow method ' .
  				  "$method for 'data:' URLs");
      }
  
      my $url = $request->uri;
      my $response = HTTP::Response->new( &HTTP::Status::RC_OK, "Document follows");
  
      my $media_type = $url->media_type;
  
      my $data = $url->data;
      $response->header('Content-Type'   => $media_type,
  		      'Content-Length' => length($data),
  		      'Date'           => time2str(time),
  		      'Server'         => "libwww-perl-internal/$LWP::VERSION"
  		     );
  
      $data = "" if $method eq "HEAD";
      return $self->collect_once($arg, $response, $data);
  }
  
  1;
LWP_PROTOCOL_DATA

$fatpacked{"LWP/Protocol/file.pm"} = <<'LWP_PROTOCOL_FILE';
  package LWP::Protocol::file;
  
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  use strict;
  
  require LWP::MediaTypes;
  require HTTP::Request;
  require HTTP::Response;
  require HTTP::Status;
  require HTTP::Date;
  
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size) = @_;
  
      $size = 4096 unless defined $size and $size > 0;
  
      # check proxy
      if (defined $proxy)
      {
  	return HTTP::Response->new( &HTTP::Status::RC_BAD_REQUEST,
  				  'You can not proxy through the filesystem');
      }
  
      # check method
      my $method = $request->method;
      unless ($method eq 'GET' || $method eq 'HEAD') {
  	return HTTP::Response->new( &HTTP::Status::RC_BAD_REQUEST,
  				  'Library does not allow method ' .
  				  "$method for 'file:' URLs");
      }
  
      # check url
      my $url = $request->uri;
  
      my $scheme = $url->scheme;
      if ($scheme ne 'file') {
  	return HTTP::Response->new( &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  			   "LWP::Protocol::file::request called for '$scheme'");
      }
  
      # URL OK, look at file
      my $path  = $url->file;
  
      # test file exists and is readable
      unless (-e $path) {
  	return HTTP::Response->new( &HTTP::Status::RC_NOT_FOUND,
  				  "File `$path' does not exist");
      }
      unless (-r _) {
  	return HTTP::Response->new( &HTTP::Status::RC_FORBIDDEN,
  				  'User does not have read permission');
      }
  
      # looks like file exists
      my($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$filesize,
         $atime,$mtime,$ctime,$blksize,$blocks)
  	    = stat(_);
  
      # XXX should check Accept headers?
  
      # check if-modified-since
      my $ims = $request->header('If-Modified-Since');
      if (defined $ims) {
  	my $time = HTTP::Date::str2time($ims);
  	if (defined $time and $time >= $mtime) {
  	    return HTTP::Response->new( &HTTP::Status::RC_NOT_MODIFIED,
  				      "$method $path");
  	}
      }
  
      # Ok, should be an OK response by now...
      my $response = HTTP::Response->new( &HTTP::Status::RC_OK );
  
      # fill in response headers
      $response->header('Last-Modified', HTTP::Date::time2str($mtime));
  
      if (-d _) {         # If the path is a directory, process it
  	# generate the HTML for directory
  	opendir(D, $path) or
  	   return HTTP::Response->new( &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  				     "Cannot read directory '$path': $!");
  	my(@files) = sort readdir(D);
  	closedir(D);
  
  	# Make directory listing
  	require URI::Escape;
  	require HTML::Entities;
          my $pathe = $path . ( $^O eq 'MacOS' ? ':' : '/');
  	for (@files) {
  	    my $furl = URI::Escape::uri_escape($_);
              if ( -d "$pathe$_" ) {
                  $furl .= '/';
                  $_ .= '/';
              }
  	    my $desc = HTML::Entities::encode($_);
  	    $_ = qq{<LI><A HREF="$furl">$desc</A>};
  	}
  	# Ensure that the base URL is "/" terminated
  	my $base = $url->clone;
  	unless ($base->path =~ m|/$|) {
  	    $base->path($base->path . "/");
  	}
  	my $html = join("\n",
  			"<HTML>\n<HEAD>",
  			"<TITLE>Directory $path</TITLE>",
  			"<BASE HREF=\"$base\">",
  			"</HEAD>\n<BODY>",
  			"<H1>Directory listing of $path</H1>",
  			"<UL>", @files, "</UL>",
  			"</BODY>\n</HTML>\n");
  
  	$response->header('Content-Type',   'text/html');
  	$response->header('Content-Length', length $html);
  	$html = "" if $method eq "HEAD";
  
  	return $self->collect_once($arg, $response, $html);
  
      }
  
      # path is a regular file
      $response->header('Content-Length', $filesize);
      LWP::MediaTypes::guess_media_type($path, $response);
  
      # read the file
      if ($method ne "HEAD") {
  	open(F, $path) or return new
  	    HTTP::Response(&HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  			   "Cannot read file '$path': $!");
  	binmode(F);
  	$response =  $self->collect($arg, $response, sub {
  	    my $content = "";
  	    my $bytes = sysread(F, $content, $size);
  	    return \$content if $bytes > 0;
  	    return \ "";
  	});
  	close(F);
      }
  
      $response;
  }
  
  1;
LWP_PROTOCOL_FILE

$fatpacked{"LWP/Protocol/ftp.pm"} = <<'LWP_PROTOCOL_FTP';
  package LWP::Protocol::ftp;
  
  # Implementation of the ftp protocol (RFC 959). We let the Net::FTP
  # package do all the dirty work.
  
  use Carp ();
  
  use HTTP::Status ();
  use HTTP::Negotiate ();
  use HTTP::Response ();
  use LWP::MediaTypes ();
  use File::Listing ();
  
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  use strict;
  eval {
      package LWP::Protocol::MyFTP;
  
      require Net::FTP;
      Net::FTP->require_version(2.00);
  
      use vars qw(@ISA);
      @ISA=qw(Net::FTP);
  
      sub new {
  	my $class = shift;
  
  	my $self = $class->SUPER::new(@_) || return undef;
  
  	my $mess = $self->message;  # welcome message
  	$mess =~ s|\n.*||s; # only first line left
  	$mess =~ s|\s*ready\.?$||;
  	# Make the version number more HTTP like
  	$mess =~ s|\s*\(Version\s*|/| and $mess =~ s|\)$||;
  	${*$self}{myftp_server} = $mess;
  	#$response->header("Server", $mess);
  
  	$self;
      }
  
      sub http_server {
  	my $self = shift;
  	${*$self}{myftp_server};
      }
  
      sub home {
  	my $self = shift;
  	my $old = ${*$self}{myftp_home};
  	if (@_) {
  	    ${*$self}{myftp_home} = shift;
  	}
  	$old;
      }
  
      sub go_home {
  	my $self = shift;
  	$self->cwd(${*$self}{myftp_home});
      }
  
      sub request_count {
  	my $self = shift;
  	++${*$self}{myftp_reqcount};
      }
  
      sub ping {
  	my $self = shift;
  	return $self->go_home;
      }
  
  };
  my $init_failed = $@;
  
  
  sub _connect {
      my($self, $host, $port, $user, $account, $password, $timeout) = @_;
  
      my $key;
      my $conn_cache = $self->{ua}{conn_cache};
      if ($conn_cache) {
  	$key = "$host:$port:$user";
  	$key .= ":$account" if defined($account);
  	if (my $ftp = $conn_cache->withdraw("ftp", $key)) {
  	    if ($ftp->ping) {
  		# save it again
  		$conn_cache->deposit("ftp", $key, $ftp);
  		return $ftp;
  	    }
  	}
      }
  
      # try to make a connection
      my $ftp = LWP::Protocol::MyFTP->new($host,
  					Port => $port,
  					Timeout => $timeout,
  					LocalAddr => $self->{ua}{local_address},
  				       );
      # XXX Should be some what to pass on 'Passive' (header??)
      unless ($ftp) {
  	$@ =~ s/^Net::FTP: //;
  	return HTTP::Response->new(&HTTP::Status::RC_INTERNAL_SERVER_ERROR, $@);
      }
  
      unless ($ftp->login($user, $password, $account)) {
  	# Unauthorized.  Let's fake a RC_UNAUTHORIZED response
  	my $mess = scalar($ftp->message);
  	$mess =~ s/\n$//;
  	my $res =  HTTP::Response->new(&HTTP::Status::RC_UNAUTHORIZED, $mess);
  	$res->header("Server", $ftp->http_server);
  	$res->header("WWW-Authenticate", qq(Basic Realm="FTP login"));
  	return $res;
      }
  
      my $home = $ftp->pwd;
      $ftp->home($home);
  
      $conn_cache->deposit("ftp", $key, $ftp) if $conn_cache;
  
      return $ftp;
  }
  
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
  
      $size = 4096 unless $size;
  
      # check proxy
      if (defined $proxy)
      {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   'You can not proxy through the ftp');
      }
  
      my $url = $request->uri;
      if ($url->scheme ne 'ftp') {
  	my $scheme = $url->scheme;
  	return HTTP::Response->new(&HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  		       "LWP::Protocol::ftp::request called for '$scheme'");
      }
  
      # check method
      my $method = $request->method;
  
      unless ($method eq 'GET' || $method eq 'HEAD' || $method eq 'PUT') {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   'Library does not allow method ' .
  				   "$method for 'ftp:' URLs");
      }
  
      if ($init_failed) {
  	return HTTP::Response->new(&HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  				   $init_failed);
      }
  
      my $host     = $url->host;
      my $port     = $url->port;
      my $user     = $url->user;
      my $password = $url->password;
  
      # If a basic autorization header is present than we prefer these over
      # the username/password specified in the URL.
      {
  	my($u,$p) = $request->authorization_basic;
  	if (defined $u) {
  	    $user = $u;
  	    $password = $p;
  	}
      }
  
      # We allow the account to be specified in the "Account" header
      my $account = $request->header('Account');
  
      my $ftp = $self->_connect($host, $port, $user, $account, $password, $timeout);
      return $ftp if ref($ftp) eq "HTTP::Response"; # ugh!
  
      # Create an initial response object
      my $response = HTTP::Response->new(&HTTP::Status::RC_OK, "OK");
      $response->header(Server => $ftp->http_server);
      $response->header('Client-Request-Num' => $ftp->request_count);
      $response->request($request);
  
      # Get & fix the path
      my @path =  grep { length } $url->path_segments;
      my $remote_file = pop(@path);
      $remote_file = '' unless defined $remote_file;
  
      my $type;
      if (ref $remote_file) {
  	my @params;
  	($remote_file, @params) = @$remote_file;
  	for (@params) {
  	    $type = $_ if s/^type=//;
  	}
      }
  
      if ($type && $type eq 'a') {
  	$ftp->ascii;
      }
      else {
  	$ftp->binary;
      }
  
      for (@path) {
  	unless ($ftp->cwd($_)) {
  	    return HTTP::Response->new(&HTTP::Status::RC_NOT_FOUND,
  				       "Can't chdir to $_");
  	}
      }
  
      if ($method eq 'GET' || $method eq 'HEAD') {
  	if (my $mod_time = $ftp->mdtm($remote_file)) {
  	    $response->last_modified($mod_time);
  	    if (my $ims = $request->if_modified_since) {
  		if ($mod_time <= $ims) {
  		    $response->code(&HTTP::Status::RC_NOT_MODIFIED);
  		    $response->message("Not modified");
  		    return $response;
  		}
  	    }
  	}
  
  	# We'll use this later to abort the transfer if necessary. 
  	# if $max_size is defined, we need to abort early. Otherwise, it's
        # a normal transfer
  	my $max_size = undef;
  
  	# Set resume location, if the client requested it
  	if ($request->header('Range') && $ftp->supported('REST'))
  	{
  		my $range_info = $request->header('Range');
  
  		# Change bytes=2772992-6781209 to just 2772992
  		my ($start_byte,$end_byte) = $range_info =~ /.*=\s*(\d+)-(\d+)?/;
  		if ( defined $start_byte && !defined $end_byte ) {
  
  		  # open range -- only the start is specified
  
  		  $ftp->restart( $start_byte );
  		  # don't define $max_size, we don't want to abort early
  		}
  		elsif ( defined $start_byte && defined $end_byte &&
  			$start_byte >= 0 && $end_byte >= $start_byte ) {
  
  		  $ftp->restart( $start_byte );
  		  $max_size = $end_byte - $start_byte;
  		}
  		else {
  
  		  return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  		     'Incorrect syntax for Range request');
  		}
  	}
  	elsif ($request->header('Range') && !$ftp->supported('REST'))
  	{
  		return HTTP::Response->new(&HTTP::Status::RC_NOT_IMPLEMENTED,
  	         "Server does not support resume.");
  	}
  
  	my $data;  # the data handle
  	if (length($remote_file) and $data = $ftp->retr($remote_file)) {
  	    my($type, @enc) = LWP::MediaTypes::guess_media_type($remote_file);
  	    $response->header('Content-Type',   $type) if $type;
  	    for (@enc) {
  		$response->push_header('Content-Encoding', $_);
  	    }
  	    my $mess = $ftp->message;
  	    if ($mess =~ /\((\d+)\s+bytes\)/) {
  		$response->header('Content-Length', "$1");
  	    }
  
  	    if ($method ne 'HEAD') {
  		# Read data from server
  		$response = $self->collect($arg, $response, sub {
  		    my $content = '';
  		    my $result = $data->read($content, $size);
  
                      # Stop early if we need to.
                      if (defined $max_size)
                      {
                        # We need an interface to Net::FTP::dataconn for getting
                        # the number of bytes already read
                        my $bytes_received = $data->bytes_read();
  
                        # We were already over the limit. (Should only happen
                        # once at the end.)
                        if ($bytes_received - length($content) > $max_size)
                        {
                          $content = '';
                        }
                        # We just went over the limit
                        elsif ($bytes_received  > $max_size)
                        {
                          # Trim content
                          $content = substr($content, 0,
                            $max_size - ($bytes_received - length($content)) );
                        }
                        # We're under the limit
                        else
                        {
                        }
                      }
  
  		    return \$content;
  		} );
  	    }
  	    # abort is needed for HEAD, it's == close if the transfer has
  	    # already completed.
  	    unless ($data->abort) {
  		# Something did not work too well.  Note that we treat
  		# responses to abort() with code 0 in case of HEAD as ok
  		# (at least wu-ftpd 2.6.1(1) does that).
  		if ($method ne 'HEAD' || $ftp->code != 0) {
  		    $response->code(&HTTP::Status::RC_INTERNAL_SERVER_ERROR);
  		    $response->message("FTP close response: " . $ftp->code .
  				       " " . $ftp->message);
  		}
  	    }
  	}
  	elsif (!length($remote_file) || ( $ftp->code >= 400 && $ftp->code < 600 )) {
  	    # not a plain file, try to list instead
  	    if (length($remote_file) && !$ftp->cwd($remote_file)) {
  		return HTTP::Response->new(&HTTP::Status::RC_NOT_FOUND,
  					   "File '$remote_file' not found");
  	    }
  
  	    # It should now be safe to try to list the directory
  	    my @lsl = $ftp->dir;
  
  	    # Try to figure out if the user want us to convert the
  	    # directory listing to HTML.
  	    my @variants =
  	      (
  	       ['html',  0.60, 'text/html'            ],
  	       ['dir',   1.00, 'text/ftp-dir-listing' ]
  	      );
  	    #$HTTP::Negotiate::DEBUG=1;
  	    my $prefer = HTTP::Negotiate::choose(\@variants, $request);
  
  	    my $content = '';
  
  	    if (!defined($prefer)) {
  		return HTTP::Response->new(&HTTP::Status::RC_NOT_ACCEPTABLE,
  			       "Neither HTML nor directory listing wanted");
  	    }
  	    elsif ($prefer eq 'html') {
  		$response->header('Content-Type' => 'text/html');
  		$content = "<HEAD><TITLE>File Listing</TITLE>\n";
  		my $base = $request->uri->clone;
  		my $path = $base->path;
  		$base->path("$path/") unless $path =~ m|/$|;
  		$content .= qq(<BASE HREF="$base">\n</HEAD>\n);
  		$content .= "<BODY>\n<UL>\n";
  		for (File::Listing::parse_dir(\@lsl, 'GMT')) {
  		    my($name, $type, $size, $mtime, $mode) = @$_;
  		    $content .= qq(  <LI> <a href="$name">$name</a>);
  		    $content .= " $size bytes" if $type eq 'f';
  		    $content .= "\n";
  		}
  		$content .= "</UL></body>\n";
  	    }
  	    else {
  		$response->header('Content-Type', 'text/ftp-dir-listing');
  		$content = join("\n", @lsl, '');
  	    }
  
  	    $response->header('Content-Length', length($content));
  
  	    if ($method ne 'HEAD') {
  		$response = $self->collect_once($arg, $response, $content);
  	    }
  	}
  	else {
  	    my $res = HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  			  "FTP return code " . $ftp->code);
  	    $res->content_type("text/plain");
  	    $res->content($ftp->message);
  	    return $res;
  	}
      }
      elsif ($method eq 'PUT') {
  	# method must be PUT
  	unless (length($remote_file)) {
  	    return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				       "Must have a file name to PUT to");
  	}
  	my $data;
  	if ($data = $ftp->stor($remote_file)) {
  	    my $content = $request->content;
  	    my $bytes = 0;
  	    if (defined $content) {
  		if (ref($content) eq 'SCALAR') {
  		    $bytes = $data->write($$content, length($$content));
  		}
  		elsif (ref($content) eq 'CODE') {
  		    my($buf, $n);
  		    while (length($buf = &$content)) {
  			$n = $data->write($buf, length($buf));
  			last unless $n;
  			$bytes += $n;
  		    }
  		}
  		elsif (!ref($content)) {
  		    if (defined $content && length($content)) {
  			$bytes = $data->write($content, length($content));
  		    }
  		}
  		else {
  		    die "Bad content";
  		}
  	    }
  	    $data->close;
  
  	    $response->code(&HTTP::Status::RC_CREATED);
  	    $response->header('Content-Type', 'text/plain');
  	    $response->content("$bytes bytes stored as $remote_file on $host\n")
  
  	}
  	else {
  	    my $res = HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  					  "FTP return code " . $ftp->code);
  	    $res->content_type("text/plain");
  	    $res->content($ftp->message);
  	    return $res;
  	}
      }
      else {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   "Illegal method $method");
      }
  
      $response;
  }
  
  1;
  
  __END__
  
  # This is what RFC 1738 has to say about FTP access:
  # --------------------------------------------------
  #
  # 3.2. FTP
  #
  #    The FTP URL scheme is used to designate files and directories on
  #    Internet hosts accessible using the FTP protocol (RFC959).
  #
  #    A FTP URL follow the syntax described in Section 3.1.  If :<port> is
  #    omitted, the port defaults to 21.
  #
  # 3.2.1. FTP Name and Password
  #
  #    A user name and password may be supplied; they are used in the ftp
  #    "USER" and "PASS" commands after first making the connection to the
  #    FTP server.  If no user name or password is supplied and one is
  #    requested by the FTP server, the conventions for "anonymous" FTP are
  #    to be used, as follows:
  #
  #         The user name "anonymous" is supplied.
  #
  #         The password is supplied as the Internet e-mail address
  #         of the end user accessing the resource.
  #
  #    If the URL supplies a user name but no password, and the remote
  #    server requests a password, the program interpreting the FTP URL
  #    should request one from the user.
  #
  # 3.2.2. FTP url-path
  #
  #    The url-path of a FTP URL has the following syntax:
  #
  #         <cwd1>/<cwd2>/.../<cwdN>/<name>;type=<typecode>
  #
  #    Where <cwd1> through <cwdN> and <name> are (possibly encoded) strings
  #    and <typecode> is one of the characters "a", "i", or "d".  The part
  #    ";type=<typecode>" may be omitted. The <cwdx> and <name> parts may be
  #    empty. The whole url-path may be omitted, including the "/"
  #    delimiting it from the prefix containing user, password, host, and
  #    port.
  #
  #    The url-path is interpreted as a series of FTP commands as follows:
  #
  #       Each of the <cwd> elements is to be supplied, sequentially, as the
  #       argument to a CWD (change working directory) command.
  #
  #       If the typecode is "d", perform a NLST (name list) command with
  #       <name> as the argument, and interpret the results as a file
  #       directory listing.
  #
  #       Otherwise, perform a TYPE command with <typecode> as the argument,
  #       and then access the file whose name is <name> (for example, using
  #       the RETR command.)
  #
  #    Within a name or CWD component, the characters "/" and ";" are
  #    reserved and must be encoded. The components are decoded prior to
  #    their use in the FTP protocol.  In particular, if the appropriate FTP
  #    sequence to access a particular file requires supplying a string
  #    containing a "/" as an argument to a CWD or RETR command, it is
  #    necessary to encode each "/".
  #
  #    For example, the URL <URL:ftp://myname@host.dom/%2Fetc/motd> is
  #    interpreted by FTP-ing to "host.dom", logging in as "myname"
  #    (prompting for a password if it is asked for), and then executing
  #    "CWD /etc" and then "RETR motd". This has a different meaning from
  #    <URL:ftp://myname@host.dom/etc/motd> which would "CWD etc" and then
  #    "RETR motd"; the initial "CWD" might be executed relative to the
  #    default directory for "myname". On the other hand,
  #    <URL:ftp://myname@host.dom//etc/motd>, would "CWD " with a null
  #    argument, then "CWD etc", and then "RETR motd".
  #
  #    FTP URLs may also be used for other operations; for example, it is
  #    possible to update a file on a remote file server, or infer
  #    information about it from the directory listings. The mechanism for
  #    doing so is not spelled out here.
  #
  # 3.2.3. FTP Typecode is Optional
  #
  #    The entire ;type=<typecode> part of a FTP URL is optional. If it is
  #    omitted, the client program interpreting the URL must guess the
  #    appropriate mode to use. In general, the data content type of a file
  #    can only be guessed from the name, e.g., from the suffix of the name;
  #    the appropriate type code to be used for transfer of the file can
  #    then be deduced from the data content of the file.
  #
  # 3.2.4 Hierarchy
  #
  #    For some file systems, the "/" used to denote the hierarchical
  #    structure of the URL corresponds to the delimiter used to construct a
  #    file name hierarchy, and thus, the filename will look similar to the
  #    URL path. This does NOT mean that the URL is a Unix filename.
  #
  # 3.2.5. Optimization
  #
  #    Clients accessing resources via FTP may employ additional heuristics
  #    to optimize the interaction. For some FTP servers, for example, it
  #    may be reasonable to keep the control connection open while accessing
  #    multiple URLs from the same server. However, there is no common
  #    hierarchical model to the FTP protocol, so if a directory change
  #    command has been given, it is impossible in general to deduce what
  #    sequence should be given to navigate to another directory for a
  #    second retrieval, if the paths are different.  The only reliable
  #    algorithm is to disconnect and reestablish the control connection.
LWP_PROTOCOL_FTP

$fatpacked{"LWP/Protocol/gopher.pm"} = <<'LWP_PROTOCOL_GOPHER';
  package LWP::Protocol::gopher;
  
  # Implementation of the gopher protocol (RFC 1436)
  #
  # This code is based on 'wwwgopher.pl,v 0.10 1994/10/17 18:12:34 shelden'
  # which in turn is a vastly modified version of Oscar's http'get()
  # dated 28/3/94 in <ftp://cui.unige.ch/PUBLIC/oscar/scripts/http.pl>
  # including contributions from Marc van Heyningen and Martijn Koster.
  
  use strict;
  use vars qw(@ISA);
  
  require HTTP::Response;
  require HTTP::Status;
  require IO::Socket;
  require IO::Select;
  
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  
  my %gopher2mimetype = (
      '0' => 'text/plain',                # 0 file
      '1' => 'text/html',                 # 1 menu
  					# 2 CSO phone-book server
  					# 3 Error
      '4' => 'application/mac-binhex40',  # 4 BinHexed Macintosh file
      '5' => 'application/zip',           # 5 DOS binary archive of some sort
      '6' => 'application/octet-stream',  # 6 UNIX uuencoded file.
      '7' => 'text/html',                 # 7 Index-Search server
  					# 8 telnet session
      '9' => 'application/octet-stream',  # 9 binary file
      'h' => 'text/html',                 # html
      'g' => 'image/gif',                 # gif
      'I' => 'image/*',                   # some kind of image
  );
  
  my %gopher2encoding = (
      '6' => 'x_uuencode',                # 6 UNIX uuencoded file.
  );
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
  
      $size = 4096 unless $size;
  
      # check proxy
      if (defined $proxy) {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   'You can not proxy through the gopher');
      }
  
      my $url = $request->uri;
      die "bad scheme" if $url->scheme ne 'gopher';
  
  
      my $method = $request->method;
      unless ($method eq 'GET' || $method eq 'HEAD') {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   'Library does not allow method ' .
  				   "$method for 'gopher:' URLs");
      }
  
      my $gophertype = $url->gopher_type;
      unless (exists $gopher2mimetype{$gophertype}) {
  	return HTTP::Response->new(&HTTP::Status::RC_NOT_IMPLEMENTED,
  				   'Library does not support gophertype ' .
  				   $gophertype);
      }
  
      my $response = HTTP::Response->new(&HTTP::Status::RC_OK, "OK");
      $response->header('Content-type' => $gopher2mimetype{$gophertype}
  					|| 'text/plain');
      $response->header('Content-Encoding' => $gopher2encoding{$gophertype})
  	if exists $gopher2encoding{$gophertype};
  
      if ($method eq 'HEAD') {
  	# XXX: don't even try it so we set this header
  	$response->header('Client-Warning' => 'Client answer only');
  	return $response;
      }
      
      if ($gophertype eq '7' && ! $url->search) {
        # the url is the prompt for a gopher search; supply boiler-plate
        return $self->collect_once($arg, $response, <<"EOT");
  <HEAD>
  <TITLE>Gopher Index</TITLE>
  <ISINDEX>
  </HEAD>
  <BODY>
  <H1>$url<BR>Gopher Search</H1>
  This is a searchable Gopher index.
  Use the search function of your browser to enter search terms.
  </BODY>
  EOT
      }
  
      my $host = $url->host;
      my $port = $url->port;
  
      my $requestLine = "";
  
      my $selector = $url->selector;
      if (defined $selector) {
  	$requestLine .= $selector;
  	my $search = $url->search;
  	if (defined $search) {
  	    $requestLine .= "\t$search";
  	    my $string = $url->string;
  	    if (defined $string) {
  		$requestLine .= "\t$string";
  	    }
  	}
      }
      $requestLine .= "\015\012";
  
      # potential request headers are just ignored
  
      # Ok, lets make the request
      my $socket = IO::Socket::INET->new(PeerAddr => $host,
  				       PeerPort => $port,
  				       LocalAddr => $self->{ua}{local_address},
  				       Proto    => 'tcp',
  				       Timeout  => $timeout);
      die "Can't connect to $host:$port" unless $socket;
      my $sel = IO::Select->new($socket);
  
      {
  	die "write timeout" if $timeout && !$sel->can_write($timeout);
  	my $n = syswrite($socket, $requestLine, length($requestLine));
  	die $! unless defined($n);
  	die "short write" if $n != length($requestLine);
      }
  
      my $user_arg = $arg;
  
      # must handle menus in a special way since they are to be
      # converted to HTML.  Undefing $arg ensures that the user does
      # not see the data before we get a change to convert it.
      $arg = undef if $gophertype eq '1' || $gophertype eq '7';
  
      # collect response
      my $buf = '';
      $response = $self->collect($arg, $response, sub {
  	die "read timeout" if $timeout && !$sel->can_read($timeout);
          my $n = sysread($socket, $buf, $size);
  	die $! unless defined($n);
  	return \$buf;
        } );
  
      # Convert menu to HTML and return data to user.
      if ($gophertype eq '1' || $gophertype eq '7') {
  	my $content = menu2html($response->content);
  	if (defined $user_arg) {
  	    $response = $self->collect_once($user_arg, $response, $content);
  	}
  	else {
  	    $response->content($content);
  	}
      }
  
      $response;
  }
  
  
  sub gopher2url
  {
      my($gophertype, $path, $host, $port) = @_;
  
      my $url;
  
      if ($gophertype eq '8' || $gophertype eq 'T') {
  	# telnet session
  	$url = $HTTP::URI_CLASS->new($gophertype eq '8' ? 'telnet:':'tn3270:');
  	$url->user($path) if defined $path;
      }
      else {
  	$path = URI::Escape::uri_escape($path);
  	$url = $HTTP::URI_CLASS->new("gopher:/$gophertype$path");
      }
      $url->host($host);
      $url->port($port);
      $url;
  }
  
  sub menu2html {
      my($menu) = @_;
  
      $menu =~ s/\015//g;  # remove carriage return
      my $tmp = <<"EOT";
  <HTML>
  <HEAD>
     <TITLE>Gopher menu</TITLE>
  </HEAD>
  <BODY>
  <H1>Gopher menu</H1>
  EOT
      for (split("\n", $menu)) {
  	last if /^\./;
  	my($pretty, $path, $host, $port) = split("\t");
  
  	$pretty =~ s/^(.)//;
  	my $type = $1;
  
  	my $url = gopher2url($type, $path, $host, $port)->as_string;
  	$tmp .= qq{<A HREF="$url">$pretty</A><BR>\n};
      }
      $tmp .= "</BODY>\n</HTML>\n";
      $tmp;
  }
  
  1;
LWP_PROTOCOL_GOPHER

$fatpacked{"LWP/Protocol/http.pm"} = <<'LWP_PROTOCOL_HTTP';
  package LWP::Protocol::http;
  
  use strict;
  
  require HTTP::Response;
  require HTTP::Status;
  require Net::HTTP;
  
  use vars qw(@ISA @EXTRA_SOCK_OPTS);
  
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  my $CRLF = "\015\012";
  
  sub _new_socket
  {
      my($self, $host, $port, $timeout) = @_;
      my $conn_cache = $self->{ua}{conn_cache};
      if ($conn_cache) {
  	if (my $sock = $conn_cache->withdraw($self->socket_type, "$host:$port")) {
  	    return $sock if $sock && !$sock->can_read(0);
  	    # if the socket is readable, then either the peer has closed the
  	    # connection or there are some garbage bytes on it.  In either
  	    # case we abandon it.
  	    $sock->close;
  	}
      }
  
      local($^W) = 0;  # IO::Socket::INET can be noisy
      my $sock = $self->socket_class->new(PeerAddr => $host,
  					PeerPort => $port,
  					LocalAddr => $self->{ua}{local_address},
  					Proto    => 'tcp',
  					Timeout  => $timeout,
  					KeepAlive => !!$conn_cache,
  					SendTE    => 1,
  					$self->_extra_sock_opts($host, $port),
  				       );
  
      unless ($sock) {
  	# IO::Socket::INET leaves additional error messages in $@
  	$@ =~ s/^.*?: //;
  	die "Can't connect to $host:$port ($@)";
      }
  
      # perl 5.005's IO::Socket does not have the blocking method.
      eval { $sock->blocking(0); };
  
      $sock;
  }
  
  sub socket_type
  {
      return "http";
  }
  
  sub socket_class
  {
      my $self = shift;
      (ref($self) || $self) . "::Socket";
  }
  
  sub _extra_sock_opts  # to be overridden by subclass
  {
      return @EXTRA_SOCK_OPTS;
  }
  
  sub _check_sock
  {
      #my($self, $req, $sock) = @_;
  }
  
  sub _get_sock_info
  {
      my($self, $res, $sock) = @_;
      if (defined(my $peerhost = $sock->peerhost)) {
          $res->header("Client-Peer" => "$peerhost:" . $sock->peerport);
      }
  }
  
  sub _fixup_header
  {
      my($self, $h, $url, $proxy) = @_;
  
      # Extract 'Host' header
      my $hhost = $url->authority;
      if ($hhost =~ s/^([^\@]*)\@//) {  # get rid of potential "user:pass@"
  	# add authorization header if we need them.  HTTP URLs do
  	# not really support specification of user and password, but
  	# we allow it.
  	if (defined($1) && not $h->header('Authorization')) {
  	    require URI::Escape;
  	    $h->authorization_basic(map URI::Escape::uri_unescape($_),
  				    split(":", $1, 2));
  	}
      }
      $h->init_header('Host' => $hhost);
  
      if ($proxy) {
  	# Check the proxy URI's userinfo() for proxy credentials
  	# export http_proxy="http://proxyuser:proxypass@proxyhost:port"
  	my $p_auth = $proxy->userinfo();
  	if(defined $p_auth) {
  	    require URI::Escape;
  	    $h->proxy_authorization_basic(map URI::Escape::uri_unescape($_),
  					  split(":", $p_auth, 2))
  	}
      }
  }
  
  sub hlist_remove {
      my($hlist, $k) = @_;
      $k = lc $k;
      for (my $i = @$hlist - 2; $i >= 0; $i -= 2) {
  	next unless lc($hlist->[$i]) eq $k;
  	splice(@$hlist, $i, 2);
      }
  }
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
  
      $size ||= 4096;
  
      # check method
      my $method = $request->method;
      unless ($method =~ /^[A-Za-z0-9_!\#\$%&\'*+\-.^\`|~]+$/) {  # HTTP token
  	return HTTP::Response->new( &HTTP::Status::RC_BAD_REQUEST,
  				  'Library does not allow method ' .
  				  "$method for 'http:' URLs");
      }
  
      my $url = $request->uri;
      my($host, $port, $fullpath);
  
      # Check if we're proxy'ing
      if (defined $proxy) {
  	# $proxy is an URL to an HTTP server which will proxy this request
  	$host = $proxy->host;
  	$port = $proxy->port;
  	$fullpath = $method eq "CONNECT" ?
                         ($url->host . ":" . $url->port) :
                         $url->as_string;
      }
      else {
  	$host = $url->host;
  	$port = $url->port;
  	$fullpath = $url->path_query;
  	$fullpath = "/$fullpath" unless $fullpath =~ m,^/,;
      }
  
      # connect to remote site
      my $socket = $self->_new_socket($host, $port, $timeout);
      $self->_check_sock($request, $socket);
  
      my @h;
      my $request_headers = $request->headers->clone;
      $self->_fixup_header($request_headers, $url, $proxy);
  
      $request_headers->scan(sub {
  			       my($k, $v) = @_;
  			       $k =~ s/^://;
  			       $v =~ s/\n/ /g;
  			       push(@h, $k, $v);
  			   });
  
      my $content_ref = $request->content_ref;
      $content_ref = $$content_ref if ref($$content_ref);
      my $chunked;
      my $has_content;
  
      if (ref($content_ref) eq 'CODE') {
  	my $clen = $request_headers->header('Content-Length');
  	$has_content++ if $clen;
  	unless (defined $clen) {
  	    push(@h, "Transfer-Encoding" => "chunked");
  	    $has_content++;
  	    $chunked++;
  	}
      }
      else {
  	# Set (or override) Content-Length header
  	my $clen = $request_headers->header('Content-Length');
  	if (defined($$content_ref) && length($$content_ref)) {
  	    $has_content = length($$content_ref);
  	    if (!defined($clen) || $clen ne $has_content) {
  		if (defined $clen) {
  		    warn "Content-Length header value was wrong, fixed";
  		    hlist_remove(\@h, 'Content-Length');
  		}
  		push(@h, 'Content-Length' => $has_content);
  	    }
  	}
  	elsif ($clen) {
  	    warn "Content-Length set when there is no content, fixed";
  	    hlist_remove(\@h, 'Content-Length');
  	}
      }
  
      my $write_wait = 0;
      $write_wait = 2
  	if ($request_headers->header("Expect") || "") =~ /100-continue/;
  
      my $req_buf = $socket->format_request($method, $fullpath, @h);
      #print "------\n$req_buf\n------\n";
  
      if (!$has_content || $write_wait || $has_content > 8*1024) {
        WRITE:
          {
              # Since this just writes out the header block it should almost
              # always succeed to send the whole buffer in a single write call.
              my $n = $socket->syswrite($req_buf, length($req_buf));
              unless (defined $n) {
                  redo WRITE if $!{EINTR};
                  if ($!{EAGAIN}) {
                      select(undef, undef, undef, 0.1);
                      redo WRITE;
                  }
                  die "write failed: $!";
              }
              if ($n) {
                  substr($req_buf, 0, $n, "");
              }
              else {
                  select(undef, undef, undef, 0.5);
              }
              redo WRITE if length $req_buf;
          }
      }
  
      my($code, $mess, @junk);
      my $drop_connection;
  
      if ($has_content) {
  	my $eof;
  	my $wbuf;
  	my $woffset = 0;
  	if (ref($content_ref) eq 'CODE') {
  	    my $buf = &$content_ref();
  	    $buf = "" unless defined($buf);
  	    $buf = sprintf "%x%s%s%s", length($buf), $CRLF, $buf, $CRLF
  		if $chunked;
  	    substr($buf, 0, 0) = $req_buf if $req_buf;
  	    $wbuf = \$buf;
  	}
  	else {
  	    if ($req_buf) {
  		my $buf = $req_buf . $$content_ref;
  		$wbuf = \$buf;
  	    }
  	    else {
  		$wbuf = $content_ref;
  	    }
  	    $eof = 1;
  	}
  
  	my $fbits = '';
  	vec($fbits, fileno($socket), 1) = 1;
  
        WRITE:
  	while ($woffset < length($$wbuf)) {
  
  	    my $sel_timeout = $timeout;
  	    if ($write_wait) {
  		$sel_timeout = $write_wait if $write_wait < $sel_timeout;
  	    }
  	    my $time_before;
              $time_before = time if $sel_timeout;
  
  	    my $rbits = $fbits;
  	    my $wbits = $write_wait ? undef : $fbits;
              my $sel_timeout_before = $sel_timeout;
            SELECT:
              {
                  my $nfound = select($rbits, $wbits, undef, $sel_timeout);
                  if ($nfound < 0) {
                      if ($!{EINTR} || $!{EAGAIN}) {
                          if ($time_before) {
                              $sel_timeout = $sel_timeout_before - (time - $time_before);
                              $sel_timeout = 0 if $sel_timeout < 0;
                          }
                          redo SELECT;
                      }
                      die "select failed: $!";
                  }
  	    }
  
  	    if ($write_wait) {
  		$write_wait -= time - $time_before;
  		$write_wait = 0 if $write_wait < 0;
  	    }
  
  	    if (defined($rbits) && $rbits =~ /[^\0]/) {
  		# readable
  		my $buf = $socket->_rbuf;
  		my $n = $socket->sysread($buf, 1024, length($buf));
                  unless (defined $n) {
                      die "read failed: $!" unless  $!{EINTR} || $!{EAGAIN};
                      # if we get here the rest of the block will do nothing
                      # and we will retry the read on the next round
                  }
  		elsif ($n == 0) {
                      # the server closed the connection before we finished
                      # writing all the request content.  No need to write any more.
                      $drop_connection++;
                      last WRITE;
  		}
  		$socket->_rbuf($buf);
  		if (!$code && $buf =~ /\015?\012\015?\012/) {
  		    # a whole response header is present, so we can read it without blocking
  		    ($code, $mess, @h) = $socket->read_response_headers(laxed => 1,
  									junk_out => \@junk,
  								       );
  		    if ($code eq "100") {
  			$write_wait = 0;
  			undef($code);
  		    }
  		    else {
  			$drop_connection++;
  			last WRITE;
  			# XXX should perhaps try to abort write in a nice way too
  		    }
  		}
  	    }
  	    if (defined($wbits) && $wbits =~ /[^\0]/) {
  		my $n = $socket->syswrite($$wbuf, length($$wbuf), $woffset);
                  unless (defined $n) {
                      die "write failed: $!" unless $!{EINTR} || $!{EAGAIN};
                      $n = 0;  # will retry write on the next round
                  }
                  elsif ($n == 0) {
  		    die "write failed: no bytes written";
  		}
  		$woffset += $n;
  
  		if (!$eof && $woffset >= length($$wbuf)) {
  		    # need to refill buffer from $content_ref code
  		    my $buf = &$content_ref();
  		    $buf = "" unless defined($buf);
  		    $eof++ unless length($buf);
  		    $buf = sprintf "%x%s%s%s", length($buf), $CRLF, $buf, $CRLF
  			if $chunked;
  		    $wbuf = \$buf;
  		    $woffset = 0;
  		}
  	    }
  	} # WRITE
      }
  
      ($code, $mess, @h) = $socket->read_response_headers(laxed => 1, junk_out => \@junk)
  	unless $code;
      ($code, $mess, @h) = $socket->read_response_headers(laxed => 1, junk_out => \@junk)
  	if $code eq "100";
  
      my $response = HTTP::Response->new($code, $mess);
      my $peer_http_version = $socket->peer_http_version;
      $response->protocol("HTTP/$peer_http_version");
      {
  	local $HTTP::Headers::TRANSLATE_UNDERSCORE;
  	$response->push_header(@h);
      }
      $response->push_header("Client-Junk" => \@junk) if @junk;
  
      $response->request($request);
      $self->_get_sock_info($response, $socket);
  
      if ($method eq "CONNECT") {
  	$response->{client_socket} = $socket;  # so it can be picked up
  	return $response;
      }
  
      if (my @te = $response->remove_header('Transfer-Encoding')) {
  	$response->push_header('Client-Transfer-Encoding', \@te);
      }
      $response->push_header('Client-Response-Num', scalar $socket->increment_response_count);
  
      my $complete;
      $response = $self->collect($arg, $response, sub {
  	my $buf = ""; #prevent use of uninitialized value in SSLeay.xs
  	my $n;
        READ:
  	{
  	    $n = $socket->read_entity_body($buf, $size);
              unless (defined $n) {
                  redo READ if $!{EINTR} || $!{EAGAIN};
                  die "read failed: $!";
              }
  	    redo READ if $n == -1;
  	}
  	$complete++ if !$n;
          return \$buf;
      } );
      $drop_connection++ unless $complete;
  
      @h = $socket->get_trailers;
      if (@h) {
  	local $HTTP::Headers::TRANSLATE_UNDERSCORE;
  	$response->push_header(@h);
      }
  
      # keep-alive support
      unless ($drop_connection) {
  	if (my $conn_cache = $self->{ua}{conn_cache}) {
  	    my %connection = map { (lc($_) => 1) }
  		             split(/\s*,\s*/, ($response->header("Connection") || ""));
  	    if (($peer_http_version eq "1.1" && !$connection{close}) ||
  		$connection{"keep-alive"})
  	    {
  		$conn_cache->deposit($self->socket_type, "$host:$port", $socket);
  	    }
  	}
      }
  
      $response;
  }
  
  
  #-----------------------------------------------------------
  package LWP::Protocol::http::SocketMethods;
  
  sub sysread {
      my $self = shift;
      if (my $timeout = ${*$self}{io_socket_timeout}) {
  	die "read timeout" unless $self->can_read($timeout);
      }
      else {
  	# since we have made the socket non-blocking we
  	# use select to wait for some data to arrive
  	$self->can_read(undef) || die "Assert";
      }
      sysread($self, $_[0], $_[1], $_[2] || 0);
  }
  
  sub can_read {
      my($self, $timeout) = @_;
      my $fbits = '';
      vec($fbits, fileno($self), 1) = 1;
    SELECT:
      {
          my $before;
          $before = time if $timeout;
          my $nfound = select($fbits, undef, undef, $timeout);
          if ($nfound < 0) {
              if ($!{EINTR} || $!{EAGAIN}) {
                  # don't really think EAGAIN can happen here
                  if ($timeout) {
                      $timeout -= time - $before;
                      $timeout = 0 if $timeout < 0;
                  }
                  redo SELECT;
              }
              die "select failed: $!";
          }
          return $nfound > 0;
      }
  }
  
  sub ping {
      my $self = shift;
      !$self->can_read(0);
  }
  
  sub increment_response_count {
      my $self = shift;
      return ++${*$self}{'myhttp_response_count'};
  }
  
  #-----------------------------------------------------------
  package LWP::Protocol::http::Socket;
  use vars qw(@ISA);
  @ISA = qw(LWP::Protocol::http::SocketMethods Net::HTTP);
  
  1;
LWP_PROTOCOL_HTTP

$fatpacked{"LWP/Protocol/http10.pm"} = <<'LWP_PROTOCOL_HTTP10';
  package LWP::Protocol::http10;
  
  use strict;
  
  require HTTP::Response;
  require HTTP::Status;
  require IO::Socket;
  require IO::Select;
  
  use vars qw(@ISA @EXTRA_SOCK_OPTS);
  
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  my $CRLF         = "\015\012";     # how lines should be terminated;
  				   # "\r\n" is not correct on all systems, for
  				   # instance MacPerl defines it to "\012\015"
  
  sub _new_socket
  {
      my($self, $host, $port, $timeout) = @_;
  
      local($^W) = 0;  # IO::Socket::INET can be noisy
      my $sock = IO::Socket::INET->new(PeerAddr => $host,
  				     PeerPort => $port,
  				     Proto    => 'tcp',
  				     Timeout  => $timeout,
  				     $self->_extra_sock_opts($host, $port),
  				    );
      unless ($sock) {
  	# IO::Socket::INET leaves additional error messages in $@
  	$@ =~ s/^.*?: //;
  	die "Can't connect to $host:$port ($@)";
      }
      $sock;
  }
  
  sub _extra_sock_opts  # to be overridden by subclass
  {
      return @EXTRA_SOCK_OPTS;
  }
  
  
  sub _check_sock
  {
      #my($self, $req, $sock) = @_;
  }
  
  sub _get_sock_info
  {
      my($self, $res, $sock) = @_;
      if (defined(my $peerhost = $sock->peerhost)) {
  	$res->header("Client-Peer" => "$peerhost:" . $sock->peerport);
      }
  }
  
  sub _fixup_header
  {
      my($self, $h, $url, $proxy) = @_;
  
      $h->remove_header('Connection');  # need support here to be useful
  
      # HTTP/1.1 will require us to send the 'Host' header, so we might
      # as well start now.
      my $hhost = $url->authority;
      if ($hhost =~ s/^([^\@]*)\@//) {  # get rid of potential "user:pass@"
  	# add authorization header if we need them.  HTTP URLs do
  	# not really support specification of user and password, but
  	# we allow it.
  	if (defined($1) && not $h->header('Authorization')) {
  	    require URI::Escape;
  	    $h->authorization_basic(map URI::Escape::uri_unescape($_),
  				    split(":", $1, 2));
  	}
      }
      $h->init_header('Host' => $hhost);
  
      if ($proxy) {
  	# Check the proxy URI's userinfo() for proxy credentials
  	# export http_proxy="http://proxyuser:proxypass@proxyhost:port"
  	my $p_auth = $proxy->userinfo();
  	if(defined $p_auth) {
  	    require URI::Escape;
  	    $h->proxy_authorization_basic(map URI::Escape::uri_unescape($_),
  					  split(":", $p_auth, 2))
  	}
      }
  }
  
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
  
      $size ||= 4096;
  
      # check method
      my $method = $request->method;
      unless ($method =~ /^[A-Za-z0-9_!\#\$%&\'*+\-.^\`|~]+$/) {  # HTTP token
  	return HTTP::Response->new( &HTTP::Status::RC_BAD_REQUEST,
  				  'Library does not allow method ' .
  				  "$method for 'http:' URLs");
      }
  
      my $url = $request->uri;
      my($host, $port, $fullpath);
  
      # Check if we're proxy'ing
      if (defined $proxy) {
  	# $proxy is an URL to an HTTP server which will proxy this request
  	$host = $proxy->host;
  	$port = $proxy->port;
  	$fullpath = $method eq "CONNECT" ?
                         ($url->host . ":" . $url->port) :
                         $url->as_string;
      }
      else {
  	$host = $url->host;
  	$port = $url->port;
  	$fullpath = $url->path_query;
  	$fullpath = "/" unless length $fullpath;
      }
  
      # connect to remote site
      my $socket = $self->_new_socket($host, $port, $timeout);
      $self->_check_sock($request, $socket);
  
      my $sel = IO::Select->new($socket) if $timeout;
  
      my $request_line = "$method $fullpath HTTP/1.0$CRLF";
  
      my $h = $request->headers->clone;
      my $cont_ref = $request->content_ref;
      $cont_ref = $$cont_ref if ref($$cont_ref);
      my $ctype = ref($cont_ref);
  
      # If we're sending content we *have* to specify a content length
      # otherwise the server won't know a messagebody is coming.
      if ($ctype eq 'CODE') {
  	die 'No Content-Length header for request with dynamic content'
  	    unless defined($h->header('Content-Length')) ||
  		   $h->content_type =~ /^multipart\//;
  	# For HTTP/1.1 we could have used chunked transfer encoding...
      }
      else {
  	$h->header('Content-Length' => length $$cont_ref)
  	        if defined($$cont_ref) && length($$cont_ref);
      }
  
      $self->_fixup_header($h, $url, $proxy);
  
      my $buf = $request_line . $h->as_string($CRLF) . $CRLF;
      my $n;  # used for return value from syswrite/sysread
      my $length;
      my $offset;
  
      # syswrite $buf
      $length = length($buf);
      $offset = 0;
      while ( $offset < $length ) {
  	die "write timeout" if $timeout && !$sel->can_write($timeout);
  	$n = $socket->syswrite($buf, $length-$offset, $offset );
  	die $! unless defined($n);
  	$offset += $n;
      }
  
      if ($ctype eq 'CODE') {
  	while ( ($buf = &$cont_ref()), defined($buf) && length($buf)) {
  	    # syswrite $buf
  	    $length = length($buf);
  	    $offset = 0;
  	    while ( $offset < $length ) {
  		die "write timeout" if $timeout && !$sel->can_write($timeout);
  		$n = $socket->syswrite($buf, $length-$offset, $offset );
  		die $! unless defined($n);
  		$offset += $n;
  	    }
  	}
      }
      elsif (defined($$cont_ref) && length($$cont_ref)) {
  	# syswrite $$cont_ref
  	$length = length($$cont_ref);
  	$offset = 0;
  	while ( $offset < $length ) {
  	    die "write timeout" if $timeout && !$sel->can_write($timeout);
  	    $n = $socket->syswrite($$cont_ref, $length-$offset, $offset );
  	    die $! unless defined($n);
  	    $offset += $n;
  	}
      }
  
      # read response line from server
      my $response;
      $buf = '';
  
      # Inside this loop we will read the response line and all headers
      # found in the response.
      while (1) {
  	die "read timeout" if $timeout && !$sel->can_read($timeout);
  	$n = $socket->sysread($buf, $size, length($buf));
  	die $! unless defined($n);
  	die "unexpected EOF before status line seen" unless $n;
  
  	if ($buf =~ s/^(HTTP\/\d+\.\d+)[ \t]+(\d+)[ \t]*([^\012]*)\012//) {
  	    # HTTP/1.0 response or better
  	    my($ver,$code,$msg) = ($1, $2, $3);
  	    $msg =~ s/\015$//;
  	    $response = HTTP::Response->new($code, $msg);
  	    $response->protocol($ver);
  
  	    # ensure that we have read all headers.  The headers will be
  	    # terminated by two blank lines
  	    until ($buf =~ /^\015?\012/ || $buf =~ /\015?\012\015?\012/) {
  		# must read more if we can...
  		die "read timeout" if $timeout && !$sel->can_read($timeout);
  		my $old_len = length($buf);
  		$n = $socket->sysread($buf, $size, $old_len);
  		die $! unless defined($n);
  		die "unexpected EOF before all headers seen" unless $n;
  	    }
  
  	    # now we start parsing the headers.  The strategy is to
  	    # remove one line at a time from the beginning of the header
  	    # buffer ($res).
  	    my($key, $val);
  	    while ($buf =~ s/([^\012]*)\012//) {
  		my $line = $1;
  
  		# if we need to restore as content when illegal headers
  		# are found.
  		my $save = "$line\012"; 
  
  		$line =~ s/\015$//;
  		last unless length $line;
  
  		if ($line =~ /^([a-zA-Z0-9_\-.]+)\s*:\s*(.*)/) {
  		    $response->push_header($key, $val) if $key;
  		    ($key, $val) = ($1, $2);
  		}
  		elsif ($line =~ /^\s+(.*)/ && $key) {
  		    $val .= " $1";
  		}
  		else {
  		    $response->push_header("Client-Bad-Header-Line" => $line);
  		}
  	    }
  	    $response->push_header($key, $val) if $key;
  	    last;
  
  	}
  	elsif ((length($buf) >= 5 and $buf !~ /^HTTP\//) or
  	       $buf =~ /\012/ ) {
  	    # HTTP/0.9 or worse
  	    $response = HTTP::Response->new(&HTTP::Status::RC_OK, "OK");
  	    $response->protocol('HTTP/0.9');
  	    last;
  
  	}
  	else {
  	    # need more data
  	}
      };
      $response->request($request);
      $self->_get_sock_info($response, $socket);
  
      if ($method eq "CONNECT") {
  	$response->{client_socket} = $socket;  # so it can be picked up
  	$response->content($buf);     # in case we read more than the headers
  	return $response;
      }
  
      my $usebuf = length($buf) > 0;
      $response = $self->collect($arg, $response, sub {
          if ($usebuf) {
  	    $usebuf = 0;
  	    return \$buf;
  	}
  	die "read timeout" if $timeout && !$sel->can_read($timeout);
  	my $n = $socket->sysread($buf, $size);
  	die $! unless defined($n);
  	return \$buf;
  	} );
  
      #$socket->close;
  
      $response;
  }
  
  1;
LWP_PROTOCOL_HTTP10

$fatpacked{"LWP/Protocol/https.pm"} = <<'LWP_PROTOCOL_HTTPS';
  package LWP::Protocol::https;
  
  use strict;
  
  use vars qw(@ISA);
  require LWP::Protocol::http;
  @ISA = qw(LWP::Protocol::http);
  
  sub socket_type
  {
      return "https";
  }
  
  sub _check_sock
  {
      my($self, $req, $sock) = @_;
      my $check = $req->header("If-SSL-Cert-Subject");
      if (defined $check) {
  	my $cert = $sock->get_peer_certificate ||
  	    die "Missing SSL certificate";
  	my $subject = $cert->subject_name;
  	die "Bad SSL certificate subject: '$subject' !~ /$check/"
  	    unless $subject =~ /$check/;
  	$req->remove_header("If-SSL-Cert-Subject");  # don't pass it on
      }
  }
  
  sub _get_sock_info
  {
      my $self = shift;
      $self->SUPER::_get_sock_info(@_);
      my($res, $sock) = @_;
      $res->header("Client-SSL-Cipher" => $sock->get_cipher);
      my $cert = $sock->get_peer_certificate;
      if ($cert) {
  	$res->header("Client-SSL-Cert-Subject" => $cert->subject_name);
  	$res->header("Client-SSL-Cert-Issuer" => $cert->issuer_name);
      }
      if(! eval { $sock->get_peer_verify }) {
         $res->header("Client-SSL-Warning" => "Peer certificate not verified");
      }
  }
  
  #-----------------------------------------------------------
  package LWP::Protocol::https::Socket;
  
  use vars qw(@ISA);
  require Net::HTTPS;
  @ISA = qw(Net::HTTPS LWP::Protocol::http::SocketMethods);
  
  1;
LWP_PROTOCOL_HTTPS

$fatpacked{"LWP/Protocol/https10.pm"} = <<'LWP_PROTOCOL_HTTPS10';
  package LWP::Protocol::https10;
  
  use strict;
  
  # Figure out which SSL implementation to use
  use vars qw($SSL_CLASS);
  if ($Net::SSL::VERSION) {
      $SSL_CLASS = "Net::SSL";
  }
  elsif ($IO::Socket::SSL::VERSION) {
      $SSL_CLASS = "IO::Socket::SSL"; # it was already loaded
  }
  else {
      eval { require Net::SSL; };     # from Crypt-SSLeay
      if ($@) {
  	require IO::Socket::SSL;
  	$SSL_CLASS = "IO::Socket::SSL";
      }
      else {
  	$SSL_CLASS = "Net::SSL";
      }
  }
  
  
  use vars qw(@ISA);
  
  require LWP::Protocol::http10;
  @ISA=qw(LWP::Protocol::http10);
  
  sub _new_socket
  {
      my($self, $host, $port, $timeout) = @_;
      local($^W) = 0;  # IO::Socket::INET can be noisy
      my $sock = $SSL_CLASS->new(PeerAddr => $host,
  			       PeerPort => $port,
  			       Proto    => 'tcp',
  			       Timeout  => $timeout,
  			      );
      unless ($sock) {
  	# IO::Socket::INET leaves additional error messages in $@
  	$@ =~ s/^.*?: //;
  	die "Can't connect to $host:$port ($@)";
      }
      $sock;
  }
  
  sub _check_sock
  {
      my($self, $req, $sock) = @_;
      my $check = $req->header("If-SSL-Cert-Subject");
      if (defined $check) {
  	my $cert = $sock->get_peer_certificate ||
  	    die "Missing SSL certificate";
  	my $subject = $cert->subject_name;
  	die "Bad SSL certificate subject: '$subject' !~ /$check/"
  	    unless $subject =~ /$check/;
  	$req->remove_header("If-SSL-Cert-Subject");  # don't pass it on
      }
  }
  
  sub _get_sock_info
  {
      my $self = shift;
      $self->SUPER::_get_sock_info(@_);
      my($res, $sock) = @_;
      $res->header("Client-SSL-Cipher" => $sock->get_cipher);
      my $cert = $sock->get_peer_certificate;
      if ($cert) {
  	$res->header("Client-SSL-Cert-Subject" => $cert->subject_name);
  	$res->header("Client-SSL-Cert-Issuer" => $cert->issuer_name);
      }
      $res->header("Client-SSL-Warning" => "Peer certificate not verified");
  }
  
  1;
LWP_PROTOCOL_HTTPS10

$fatpacked{"LWP/Protocol/loopback.pm"} = <<'LWP_PROTOCOL_LOOPBACK';
  package LWP::Protocol::loopback;
  
  use strict;
  use vars qw(@ISA);
  require HTTP::Response;
  
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  sub request {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
  
      my $response = HTTP::Response->new(200, "OK");
      $response->content_type("message/http; msgtype=request");
  
      $response->header("Via", "loopback/1.0 $proxy")
  	if $proxy;
  
      $response->header("X-Arg", $arg);
      $response->header("X-Read-Size", $size);
      $response->header("X-Timeout", $timeout);
  
      return $self->collect_once($arg, $response, $request->as_string);
  }
  
  1;
LWP_PROTOCOL_LOOPBACK

$fatpacked{"LWP/Protocol/mailto.pm"} = <<'LWP_PROTOCOL_MAILTO';
  package LWP::Protocol::mailto;
  
  # This module implements the mailto protocol.  It is just a simple
  # frontend to the Unix sendmail program except on MacOS, where it uses
  # Mail::Internet.
  
  require LWP::Protocol;
  require HTTP::Request;
  require HTTP::Response;
  require HTTP::Status;
  
  use Carp;
  use strict;
  use vars qw(@ISA $SENDMAIL);
  
  @ISA = qw(LWP::Protocol);
  
  unless ($SENDMAIL = $ENV{SENDMAIL}) {
      for my $sm (qw(/usr/sbin/sendmail
  		   /usr/lib/sendmail
  		   /usr/ucblib/sendmail
  		  ))
      {
  	if (-x $sm) {
  	    $SENDMAIL = $sm;
  	    last;
  	}
      }
      die "Can't find the 'sendmail' program" unless $SENDMAIL;
  }
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size) = @_;
  
      my ($mail, $addr) if $^O eq "MacOS";
      my @text = () if $^O eq "MacOS";
  
      # check proxy
      if (defined $proxy)
      {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				  'You can not proxy with mail');
      }
  
      # check method
      my $method = $request->method;
  
      if ($method ne 'POST') {
  	return HTTP::Response->new( &HTTP::Status::RC_BAD_REQUEST,
  				  'Library does not allow method ' .
  				  "$method for 'mailto:' URLs");
      }
  
      # check url
      my $url = $request->uri;
  
      my $scheme = $url->scheme;
      if ($scheme ne 'mailto') {
  	return HTTP::Response->new( &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  			 "LWP::Protocol::mailto::request called for '$scheme'");
      }
      if ($^O eq "MacOS") {
  	eval {
  	    require Mail::Internet;
  	};
  	if($@) {
  	    return HTTP::Response->new( &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  	               "You don't have MailTools installed");
  	}
  	unless ($ENV{SMTPHOSTS}) {
  	    return HTTP::Response->new( &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  	               "You don't have SMTPHOSTS defined");
  	}
      }
      else {
  	unless (-x $SENDMAIL) {
  	    return HTTP::Response->new( &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  	               "You don't have $SENDMAIL");
      }
      }
      if ($^O eq "MacOS") {
  	    $mail = Mail::Internet->new or
  	    return HTTP::Response->new( &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  	    "Can't get a Mail::Internet object");
      }
      else {
  	open(SENDMAIL, "| $SENDMAIL -oi -t") or
  	    return HTTP::Response->new( &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  	               "Can't run $SENDMAIL: $!");
      }
      if ($^O eq "MacOS") {
  	$addr = $url->encoded822addr;
      }
      else {
  	$request = $request->clone;  # we modify a copy
  	my @h = $url->headers;  # URL headers override those in the request
  	while (@h) {
  	    my $k = shift @h;
  	    my $v = shift @h;
  	    next unless defined $v;
  	    if (lc($k) eq "body") {
  		$request->content($v);
  	    }
  	    else {
  		$request->push_header($k => $v);
  	    }
  	}
      }
      if ($^O eq "MacOS") {
  	$mail->add(To => $addr);
  	$mail->add(split(/[:\n]/,$request->headers_as_string));
      }
      else {
  	print SENDMAIL $request->headers_as_string;
  	print SENDMAIL "\n";
      }
      my $content = $request->content;
      if (defined $content) {
  	my $contRef = ref($content) ? $content : \$content;
  	if (ref($contRef) eq 'SCALAR') {
  	    if ($^O eq "MacOS") {
  		@text = split("\n",$$contRef);
  		foreach (@text) {
  		    $_ .= "\n";
  		}
  	    }
  	    else {
  	    print SENDMAIL $$contRef;
  	    }
  
  	}
  	elsif (ref($contRef) eq 'CODE') {
  	    # Callback provides data
  	    my $d;
  	    if ($^O eq "MacOS") {
  		my $stuff = "";
  		while (length($d = &$contRef)) {
  		    $stuff .= $d;
  		}
  		@text = split("\n",$stuff);
  		foreach (@text) {
  		    $_ .= "\n";
  		}
  	    }
  	    else {
  		print SENDMAIL $d;
  	    }
  	}
      }
      if ($^O eq "MacOS") {
  	$mail->body(\@text);
  	unless ($mail->smtpsend) {
  	    return HTTP::Response->new(&HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  				       "Mail::Internet->smtpsend unable to send message to <$addr>");
  	}
      }
      else {
  	unless (close(SENDMAIL)) {
  	    my $err = $! ? "$!" : "Exit status $?";
  	    return HTTP::Response->new(&HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  				       "$SENDMAIL: $err");
  	}
      }
  
  
      my $response = HTTP::Response->new(&HTTP::Status::RC_ACCEPTED,
  				       "Mail accepted");
      $response->header('Content-Type', 'text/plain');
      if ($^O eq "MacOS") {
  	$response->header('Server' => "Mail::Internet $Mail::Internet::VERSION");
  	$response->content("Message sent to <$addr>\n");
      }
      else {
  	$response->header('Server' => $SENDMAIL);
  	my $to = $request->header("To");
  	$response->content("Message sent to <$to>\n");
      }
  
      return $response;
  }
  
  1;
LWP_PROTOCOL_MAILTO

$fatpacked{"LWP/Protocol/nntp.pm"} = <<'LWP_PROTOCOL_NNTP';
  package LWP::Protocol::nntp;
  
  # Implementation of the Network News Transfer Protocol (RFC 977)
  
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  require HTTP::Response;
  require HTTP::Status;
  require Net::NNTP;
  
  use strict;
  
  
  sub request
  {
      my($self, $request, $proxy, $arg, $size, $timeout) = @_;
  
      $size = 4096 unless $size;
  
      # Check for proxy
      if (defined $proxy) {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   'You can not proxy through NNTP');
      }
  
      # Check that the scheme is as expected
      my $url = $request->uri;
      my $scheme = $url->scheme;
      unless ($scheme eq 'news' || $scheme eq 'nntp') {
  	return HTTP::Response->new(&HTTP::Status::RC_INTERNAL_SERVER_ERROR,
  				   "LWP::Protocol::nntp::request called for '$scheme'");
      }
  
      # check for a valid method
      my $method = $request->method;
      unless ($method eq 'GET' || $method eq 'HEAD' || $method eq 'POST') {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   'Library does not allow method ' .
  				   "$method for '$scheme:' URLs");
      }
  
      # extract the identifier and check against posting to an article
      my $groupart = $url->_group;
      my $is_art = $groupart =~ /@/;
  
      if ($is_art && $method eq 'POST') {
  	return HTTP::Response->new(&HTTP::Status::RC_BAD_REQUEST,
  				   "Can't post to an article <$groupart>");
      }
  
      my $nntp = Net::NNTP->new($url->host,
  			      #Port    => 18574,
  			      Timeout => $timeout,
  			      #Debug   => 1,
  			     );
      die "Can't connect to nntp server" unless $nntp;
  
      # Check the initial welcome message from the NNTP server
      if ($nntp->status != 2) {
  	return HTTP::Response->new(&HTTP::Status::RC_SERVICE_UNAVAILABLE,
  				   $nntp->message);
      }
      my $response = HTTP::Response->new(&HTTP::Status::RC_OK, "OK");
  
      my $mess = $nntp->message;
  
      # Try to extract server name from greeting message.
      # Don't know if this works well for a large class of servers, but
      # this works for our server.
      $mess =~ s/\s+ready\b.*//;
      $mess =~ s/^\S+\s+//;
      $response->header(Server => $mess);
  
      # First we handle posting of articles
      if ($method eq 'POST') {
  	$nntp->quit; $nntp = undef;
  	$response->code(&HTTP::Status::RC_NOT_IMPLEMENTED);
  	$response->message("POST not implemented yet");
  	return $response;
      }
  
      # The method must be "GET" or "HEAD" by now
      if (!$is_art) {
  	if (!$nntp->group($groupart)) {
  	    $response->code(&HTTP::Status::RC_NOT_FOUND);
  	    $response->message($nntp->message);
  	}
  	$nntp->quit; $nntp = undef;
  	# HEAD: just check if the group exists
  	if ($method eq 'GET' && $response->is_success) {
  	    $response->code(&HTTP::Status::RC_NOT_IMPLEMENTED);
  	    $response->message("GET newsgroup not implemented yet");
  	}
  	return $response;
      }
  
      # Send command to server to retrieve an article (or just the headers)
      my $get = $method eq 'HEAD' ? "head" : "article";
      my $art = $nntp->$get("<$groupart>");
      unless ($art) {
  	$nntp->quit; $nntp = undef;
  	$response->code(&HTTP::Status::RC_NOT_FOUND);
  	$response->message($nntp->message);
  	return $response;
      }
  
      # Parse headers
      my($key, $val);
      local $_;
      while ($_ = shift @$art) {
  	if (/^\s+$/) {
  	    last;  # end of headers
  	}
  	elsif (/^(\S+):\s*(.*)/) {
  	    $response->push_header($key, $val) if $key;
  	    ($key, $val) = ($1, $2);
  	}
  	elsif (/^\s+(.*)/) {
  	    next unless $key;
  	    $val .= $1;
  	}
  	else {
  	    unshift(@$art, $_);
  	    last;
  	}
      }
      $response->push_header($key, $val) if $key;
  
      # Ensure that there is a Content-Type header
      $response->header("Content-Type", "text/plain")
  	unless $response->header("Content-Type");
  
      # Collect the body
      $response = $self->collect_once($arg, $response, join("", @$art))
        if @$art;
  
      # Say goodbye to the server
      $nntp->quit;
      $nntp = undef;
  
      $response;
  }
  
  1;
LWP_PROTOCOL_NNTP

$fatpacked{"LWP/Protocol/nogo.pm"} = <<'LWP_PROTOCOL_NOGO';
  package LWP::Protocol::nogo;
  # If you want to disable access to a particular scheme, use this
  # class and then call
  #   LWP::Protocol::implementor(that_scheme, 'LWP::Protocol::nogo');
  # For then on, attempts to access URLs with that scheme will generate
  # a 500 error.
  
  use strict;
  use vars qw(@ISA);
  require HTTP::Response;
  require HTTP::Status;
  require LWP::Protocol;
  @ISA = qw(LWP::Protocol);
  
  sub request {
      my($self, $request) = @_;
      my $scheme = $request->uri->scheme;
      
      return HTTP::Response->new(
        &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
        "Access to \'$scheme\' URIs has been disabled"
      );
  }
  1;
LWP_PROTOCOL_NOGO

$fatpacked{"LWP/RobotUA.pm"} = <<'LWP_ROBOTUA';
  package LWP::RobotUA;
  
  require LWP::UserAgent;
  @ISA = qw(LWP::UserAgent);
  $VERSION = "5.835";
  
  require WWW::RobotRules;
  require HTTP::Request;
  require HTTP::Response;
  
  use Carp ();
  use HTTP::Status ();
  use HTTP::Date qw(time2str);
  use strict;
  
  
  #
  # Additional attributes in addition to those found in LWP::UserAgent:
  #
  # $self->{'delay'}    Required delay between request to the same
  #                     server in minutes.
  #
  # $self->{'rules'}     A WWW::RobotRules object
  #
  
  sub new
  {
      my $class = shift;
      my %cnf;
      if (@_ < 4) {
  	# legacy args
  	@cnf{qw(agent from rules)} = @_;
      }
      else {
  	%cnf = @_;
      }
  
      Carp::croak('LWP::RobotUA agent required') unless $cnf{agent};
      Carp::croak('LWP::RobotUA from address required')
  	unless $cnf{from} && $cnf{from} =~ m/\@/;
  
      my $delay = delete $cnf{delay} || 1;
      my $use_sleep = delete $cnf{use_sleep};
      $use_sleep = 1 unless defined($use_sleep);
      my $rules = delete $cnf{rules};
  
      my $self = LWP::UserAgent->new(%cnf);
      $self = bless $self, $class;
  
      $self->{'delay'} = $delay;   # minutes
      $self->{'use_sleep'} = $use_sleep;
  
      if ($rules) {
  	$rules->agent($cnf{agent});
  	$self->{'rules'} = $rules;
      }
      else {
  	$self->{'rules'} = WWW::RobotRules->new($cnf{agent});
      }
  
      $self;
  }
  
  
  sub delay     { shift->_elem('delay',     @_); }
  sub use_sleep { shift->_elem('use_sleep', @_); }
  
  
  sub agent
  {
      my $self = shift;
      my $old = $self->SUPER::agent(@_);
      if (@_) {
  	# Changing our name means to start fresh
  	$self->{'rules'}->agent($self->{'agent'}); 
      }
      $old;
  }
  
  
  sub rules {
      my $self = shift;
      my $old = $self->_elem('rules', @_);
      $self->{'rules'}->agent($self->{'agent'}) if @_;
      $old;
  }
  
  
  sub no_visits
  {
      my($self, $netloc) = @_;
      $self->{'rules'}->no_visits($netloc) || 0;
  }
  
  *host_count = \&no_visits;  # backwards compatibility with LWP-5.02
  
  
  sub host_wait
  {
      my($self, $netloc) = @_;
      return undef unless defined $netloc;
      my $last = $self->{'rules'}->last_visit($netloc);
      if ($last) {
  	my $wait = int($self->{'delay'} * 60 - (time - $last));
  	$wait = 0 if $wait < 0;
  	return $wait;
      }
      return 0;
  }
  
  
  sub simple_request
  {
      my($self, $request, $arg, $size) = @_;
  
      # Do we try to access a new server?
      my $allowed = $self->{'rules'}->allowed($request->uri);
  
      if ($allowed < 0) {
  	# Host is not visited before, or robots.txt expired; fetch "robots.txt"
  	my $robot_url = $request->uri->clone;
  	$robot_url->path("robots.txt");
  	$robot_url->query(undef);
  
  	# make access to robot.txt legal since this will be a recursive call
  	$self->{'rules'}->parse($robot_url, ""); 
  
  	my $robot_req = HTTP::Request->new('GET', $robot_url);
  	my $robot_res = $self->request($robot_req);
  	my $fresh_until = $robot_res->fresh_until;
  	if ($robot_res->is_success) {
  	    my $c = $robot_res->content;
  	    if ($robot_res->content_type =~ m,^text/, && $c =~ /^\s*Disallow\s*:/mi) {
  		$self->{'rules'}->parse($robot_url, $c, $fresh_until);
  	    }
  	    else {
  		$self->{'rules'}->parse($robot_url, "", $fresh_until);
  	    }
  
  	}
  	else {
  	    $self->{'rules'}->parse($robot_url, "", $fresh_until);
  	}
  
  	# recalculate allowed...
  	$allowed = $self->{'rules'}->allowed($request->uri);
      }
  
      # Check rules
      unless ($allowed) {
  	my $res = HTTP::Response->new(
  	  &HTTP::Status::RC_FORBIDDEN, 'Forbidden by robots.txt');
  	$res->request( $request ); # bind it to that request
  	return $res;
      }
  
      my $netloc = eval { local $SIG{__DIE__}; $request->uri->host_port; };
      my $wait = $self->host_wait($netloc);
  
      if ($wait) {
  	if ($self->{'use_sleep'}) {
  	    sleep($wait)
  	}
  	else {
  	    my $res = HTTP::Response->new(
  	      &HTTP::Status::RC_SERVICE_UNAVAILABLE, 'Please, slow down');
  	    $res->header('Retry-After', time2str(time + $wait));
  	    $res->request( $request ); # bind it to that request
  	    return $res;
  	}
      }
  
      # Perform the request
      my $res = $self->SUPER::simple_request($request, $arg, $size);
  
      $self->{'rules'}->visit($netloc);
  
      $res;
  }
  
  
  sub as_string
  {
      my $self = shift;
      my @s;
      push(@s, "Robot: $self->{'agent'} operated by $self->{'from'}  [$self]");
      push(@s, "    Minimum delay: " . int($self->{'delay'}*60) . "s");
      push(@s, "    Will sleep if too early") if $self->{'use_sleep'};
      push(@s, "    Rules = $self->{'rules'}");
      join("\n", @s, '');
  }
  
  1;
  
  
  __END__
  
  =head1 NAME
  
  LWP::RobotUA - a class for well-behaved Web robots
  
  =head1 SYNOPSIS
  
    use LWP::RobotUA;
    my $ua = LWP::RobotUA->new('my-robot/0.1', 'me@foo.com');
    $ua->delay(10);  # be very nice -- max one hit every ten minutes!
    ...
  
    # Then just use it just like a normal LWP::UserAgent:
    my $response = $ua->get('http://whatever.int/...');
    ...
  
  =head1 DESCRIPTION
  
  This class implements a user agent that is suitable for robot
  applications.  Robots should be nice to the servers they visit.  They
  should consult the F</robots.txt> file to ensure that they are welcomed
  and they should not make requests too frequently.
  
  But before you consider writing a robot, take a look at
  <URL:http://www.robotstxt.org/>.
  
  When you use a I<LWP::RobotUA> object as your user agent, then you do not
  really have to think about these things yourself; C<robots.txt> files
  are automatically consulted and obeyed, the server isn't queried
  too rapidly, and so on.  Just send requests
  as you do when you are using a normal I<LWP::UserAgent>
  object (using C<< $ua->get(...) >>, C<< $ua->head(...) >>,
  C<< $ua->request(...) >>, etc.), and this
  special agent will make sure you are nice.
  
  =head1 METHODS
  
  The LWP::RobotUA is a sub-class of LWP::UserAgent and implements the
  same methods. In addition the following methods are provided:
  
  =over 4
  
  =item $ua = LWP::RobotUA->new( %options )
  
  =item $ua = LWP::RobotUA->new( $agent, $from )
  
  =item $ua = LWP::RobotUA->new( $agent, $from, $rules )
  
  The LWP::UserAgent options C<agent> and C<from> are mandatory.  The
  options C<delay>, C<use_sleep> and C<rules> initialize attributes
  private to the RobotUA.  If C<rules> are not provided, then
  C<WWW::RobotRules> is instantiated providing an internal database of
  F<robots.txt>.
  
  It is also possible to just pass the value of C<agent>, C<from> and
  optionally C<rules> as plain positional arguments.
  
  =item $ua->delay
  
  =item $ua->delay( $minutes )
  
  Get/set the minimum delay between requests to the same server, in
  I<minutes>.  The default is 1 minute.  Note that this number doesn't
  have to be an integer; for example, this sets the delay to 10 seconds:
  
      $ua->delay(10/60);
  
  =item $ua->use_sleep
  
  =item $ua->use_sleep( $boolean )
  
  Get/set a value indicating whether the UA should sleep() if requests
  arrive too fast, defined as $ua->delay minutes not passed since
  last request to the given server.  The default is TRUE.  If this value is
  FALSE then an internal SERVICE_UNAVAILABLE response will be generated.
  It will have an Retry-After header that indicates when it is OK to
  send another request to this server.
  
  =item $ua->rules
  
  =item $ua->rules( $rules )
  
  Set/get which I<WWW::RobotRules> object to use.
  
  =item $ua->no_visits( $netloc )
  
  Returns the number of documents fetched from this server host. Yeah I
  know, this method should probably have been named num_visits() or
  something like that. :-(
  
  =item $ua->host_wait( $netloc )
  
  Returns the number of I<seconds> (from now) you must wait before you can
  make a new request to this host.
  
  =item $ua->as_string
  
  Returns a string that describes the state of the UA.
  Mainly useful for debugging.
  
  =back
  
  =head1 SEE ALSO
  
  L<LWP::UserAgent>, L<WWW::RobotRules>
  
  =head1 COPYRIGHT
  
  Copyright 1996-2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
LWP_ROBOTUA

$fatpacked{"LWP/Simple.pm"} = <<'LWP_SIMPLE';
  package LWP::Simple;
  
  use strict;
  use vars qw($ua %loop_check $FULL_LWP @EXPORT @EXPORT_OK $VERSION);
  
  require Exporter;
  
  @EXPORT = qw(get head getprint getstore mirror);
  @EXPORT_OK = qw($ua);
  
  # I really hate this.  I was a bad idea to do it in the first place.
  # Wonder how to get rid of it???  (It even makes LWP::Simple 7% slower
  # for trivial tests)
  use HTTP::Status;
  push(@EXPORT, @HTTP::Status::EXPORT);
  
  $VERSION = "5.835";
  
  sub import
  {
      my $pkg = shift;
      my $callpkg = caller;
      Exporter::export($pkg, $callpkg, @_);
  }
  
  use LWP::UserAgent ();
  use HTTP::Status ();
  use HTTP::Date ();
  $ua = LWP::UserAgent->new;  # we create a global UserAgent object
  $ua->agent("LWP::Simple/$VERSION ");
  $ua->env_proxy;
  
  
  sub get ($)
  {
      my $response = $ua->get(shift);
      return $response->decoded_content if $response->is_success;
      return undef;
  }
  
  
  sub head ($)
  {
      my($url) = @_;
      my $request = HTTP::Request->new(HEAD => $url);
      my $response = $ua->request($request);
  
      if ($response->is_success) {
  	return $response unless wantarray;
  	return (scalar $response->header('Content-Type'),
  		scalar $response->header('Content-Length'),
  		HTTP::Date::str2time($response->header('Last-Modified')),
  		HTTP::Date::str2time($response->header('Expires')),
  		scalar $response->header('Server'),
  	       );
      }
      return;
  }
  
  
  sub getprint ($)
  {
      my($url) = @_;
      my $request = HTTP::Request->new(GET => $url);
      local($\) = ""; # ensure standard $OUTPUT_RECORD_SEPARATOR
      my $callback = sub { print $_[0] };
      if ($^O eq "MacOS") {
  	$callback = sub { $_[0] =~ s/\015?\012/\n/g; print $_[0] }
      }
      my $response = $ua->request($request, $callback);
      unless ($response->is_success) {
  	print STDERR $response->status_line, " <URL:$url>\n";
      }
      $response->code;
  }
  
  
  sub getstore ($$)
  {
      my($url, $file) = @_;
      my $request = HTTP::Request->new(GET => $url);
      my $response = $ua->request($request, $file);
  
      $response->code;
  }
  
  
  sub mirror ($$)
  {
      my($url, $file) = @_;
      my $response = $ua->mirror($url, $file);
      $response->code;
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  LWP::Simple - simple procedural interface to LWP
  
  =head1 SYNOPSIS
  
   perl -MLWP::Simple -e 'getprint "http://www.sn.no"'
  
   use LWP::Simple;
   $content = get("http://www.sn.no/");
   die "Couldn't get it!" unless defined $content;
  
   if (mirror("http://www.sn.no/", "foo") == RC_NOT_MODIFIED) {
       ...
   }
  
   if (is_success(getprint("http://www.sn.no/"))) {
       ...
   }
  
  =head1 DESCRIPTION
  
  This module is meant for people who want a simplified view of the
  libwww-perl library.  It should also be suitable for one-liners.  If
  you need more control or access to the header fields in the requests
  sent and responses received, then you should use the full object-oriented
  interface provided by the C<LWP::UserAgent> module.
  
  The following functions are provided (and exported) by this module:
  
  =over 3
  
  =item get($url)
  
  The get() function will fetch the document identified by the given URL
  and return it.  It returns C<undef> if it fails.  The $url argument can
  be either a string or a reference to a URI object.
  
  You will not be able to examine the response code or response headers
  (like 'Content-Type') when you are accessing the web using this
  function.  If you need that information you should use the full OO
  interface (see L<LWP::UserAgent>).
  
  =item head($url)
  
  Get document headers. Returns the following 5 values if successful:
  ($content_type, $document_length, $modified_time, $expires, $server)
  
  Returns an empty list if it fails.  In scalar context returns TRUE if
  successful.
  
  =item getprint($url)
  
  Get and print a document identified by a URL. The document is printed
  to the selected default filehandle for output (normally STDOUT) as
  data is received from the network.  If the request fails, then the
  status code and message are printed on STDERR.  The return value is
  the HTTP response code.
  
  =item getstore($url, $file)
  
  Gets a document identified by a URL and stores it in the file. The
  return value is the HTTP response code.
  
  =item mirror($url, $file)
  
  Get and store a document identified by a URL, using
  I<If-modified-since>, and checking the I<Content-Length>.  Returns
  the HTTP response code.
  
  =back
  
  This module also exports the HTTP::Status constants and procedures.
  You can use them when you check the response code from getprint(),
  getstore() or mirror().  The constants are:
  
     RC_CONTINUE
     RC_SWITCHING_PROTOCOLS
     RC_OK
     RC_CREATED
     RC_ACCEPTED
     RC_NON_AUTHORITATIVE_INFORMATION
     RC_NO_CONTENT
     RC_RESET_CONTENT
     RC_PARTIAL_CONTENT
     RC_MULTIPLE_CHOICES
     RC_MOVED_PERMANENTLY
     RC_MOVED_TEMPORARILY
     RC_SEE_OTHER
     RC_NOT_MODIFIED
     RC_USE_PROXY
     RC_BAD_REQUEST
     RC_UNAUTHORIZED
     RC_PAYMENT_REQUIRED
     RC_FORBIDDEN
     RC_NOT_FOUND
     RC_METHOD_NOT_ALLOWED
     RC_NOT_ACCEPTABLE
     RC_PROXY_AUTHENTICATION_REQUIRED
     RC_REQUEST_TIMEOUT
     RC_CONFLICT
     RC_GONE
     RC_LENGTH_REQUIRED
     RC_PRECONDITION_FAILED
     RC_REQUEST_ENTITY_TOO_LARGE
     RC_REQUEST_URI_TOO_LARGE
     RC_UNSUPPORTED_MEDIA_TYPE
     RC_INTERNAL_SERVER_ERROR
     RC_NOT_IMPLEMENTED
     RC_BAD_GATEWAY
     RC_SERVICE_UNAVAILABLE
     RC_GATEWAY_TIMEOUT
     RC_HTTP_VERSION_NOT_SUPPORTED
  
  The HTTP::Status classification functions are:
  
  =over 3
  
  =item is_success($rc)
  
  True if response code indicated a successful request.
  
  =item is_error($rc)
  
  True if response code indicated that an error occurred.
  
  =back
  
  The module will also export the LWP::UserAgent object as C<$ua> if you
  ask for it explicitly.
  
  The user agent created by this module will identify itself as
  "LWP::Simple/#.##"
  and will initialize its proxy defaults from the environment (by
  calling $ua->env_proxy).
  
  =head1 CAVEAT
  
  Note that if you are using both LWP::Simple and the very popular CGI.pm
  module, you may be importing a C<head> function from each module,
  producing a warning like "Prototype mismatch: sub main::head ($) vs
  none". Get around this problem by just not importing LWP::Simple's
  C<head> function, like so:
  
          use LWP::Simple qw(!head);
          use CGI qw(:standard);  # then only CGI.pm defines a head()
  
  Then if you do need LWP::Simple's C<head> function, you can just call
  it as C<LWP::Simple::head($url)>.
  
  =head1 SEE ALSO
  
  L<LWP>, L<lwpcook>, L<LWP::UserAgent>, L<HTTP::Status>, L<lwp-request>,
  L<lwp-mirror>
LWP_SIMPLE

$fatpacked{"LWP/UserAgent.pm"} = <<'LWP_USERAGENT';
  package LWP::UserAgent;
  
  use strict;
  use vars qw(@ISA $VERSION);
  
  require LWP::MemberMixin;
  @ISA = qw(LWP::MemberMixin);
  $VERSION = "5.835";
  
  use HTTP::Request ();
  use HTTP::Response ();
  use HTTP::Date ();
  
  use LWP ();
  use LWP::Protocol ();
  
  use Carp ();
  
  if ($ENV{PERL_LWP_USE_HTTP_10}) {
      require LWP::Protocol::http10;
      LWP::Protocol::implementor('http', 'LWP::Protocol::http10');
      eval {
          require LWP::Protocol::https10;
          LWP::Protocol::implementor('https', 'LWP::Protocol::https10');
      };
  }
  
  
  
  sub new
  {
      # Check for common user mistake
      Carp::croak("Options to LWP::UserAgent should be key/value pairs, not hash reference") 
          if ref($_[1]) eq 'HASH'; 
  
      my($class, %cnf) = @_;
  
      my $agent = delete $cnf{agent};
      my $from  = delete $cnf{from};
      my $def_headers = delete $cnf{default_headers};
      my $timeout = delete $cnf{timeout};
      $timeout = 3*60 unless defined $timeout;
      my $local_address = delete $cnf{local_address};
      my $use_eval = delete $cnf{use_eval};
      $use_eval = 1 unless defined $use_eval;
      my $parse_head = delete $cnf{parse_head};
      $parse_head = 1 unless defined $parse_head;
      my $show_progress = delete $cnf{show_progress};
      my $max_size = delete $cnf{max_size};
      my $max_redirect = delete $cnf{max_redirect};
      $max_redirect = 7 unless defined $max_redirect;
      my $env_proxy = delete $cnf{env_proxy};
  
      my $cookie_jar = delete $cnf{cookie_jar};
      my $conn_cache = delete $cnf{conn_cache};
      my $keep_alive = delete $cnf{keep_alive};
      
      Carp::croak("Can't mix conn_cache and keep_alive")
  	  if $conn_cache && $keep_alive;
  
  
      my $protocols_allowed   = delete $cnf{protocols_allowed};
      my $protocols_forbidden = delete $cnf{protocols_forbidden};
      
      my $requests_redirectable = delete $cnf{requests_redirectable};
      $requests_redirectable = ['GET', 'HEAD']
        unless defined $requests_redirectable;
  
      # Actually ""s are just as good as 0's, but for concision we'll just say:
      Carp::croak("protocols_allowed has to be an arrayref or 0, not \"$protocols_allowed\"!")
        if $protocols_allowed and ref($protocols_allowed) ne 'ARRAY';
      Carp::croak("protocols_forbidden has to be an arrayref or 0, not \"$protocols_forbidden\"!")
        if $protocols_forbidden and ref($protocols_forbidden) ne 'ARRAY';
      Carp::croak("requests_redirectable has to be an arrayref or 0, not \"$requests_redirectable\"!")
        if $requests_redirectable and ref($requests_redirectable) ne 'ARRAY';
  
  
      if (%cnf && $^W) {
  	Carp::carp("Unrecognized LWP::UserAgent options: @{[sort keys %cnf]}");
      }
  
      my $self = bless {
  		      def_headers  => $def_headers,
  		      timeout      => $timeout,
  		      local_address => $local_address,
  		      use_eval     => $use_eval,
                        show_progress=> $show_progress,
  		      max_size     => $max_size,
  		      max_redirect => $max_redirect,
                        proxy        => {},
  		      no_proxy     => [],
                        protocols_allowed     => $protocols_allowed,
                        protocols_forbidden   => $protocols_forbidden,
                        requests_redirectable => $requests_redirectable,
  		     }, $class;
  
      $self->agent(defined($agent) ? $agent : $class->_agent)
  	if defined($agent) || !$def_headers || !$def_headers->header("User-Agent");
      $self->from($from) if $from;
      $self->cookie_jar($cookie_jar) if $cookie_jar;
      $self->parse_head($parse_head);
      $self->env_proxy if $env_proxy;
  
      $self->protocols_allowed(  $protocols_allowed  ) if $protocols_allowed;
      $self->protocols_forbidden($protocols_forbidden) if $protocols_forbidden;
  
      if ($keep_alive) {
  	$conn_cache ||= { total_capacity => $keep_alive };
      }
      $self->conn_cache($conn_cache) if $conn_cache;
  
      return $self;
  }
  
  
  sub send_request
  {
      my($self, $request, $arg, $size) = @_;
      my($method, $url) = ($request->method, $request->uri);
      my $scheme = $url->scheme;
  
      local($SIG{__DIE__});  # protect against user defined die handlers
  
      $self->progress("begin", $request);
  
      my $response = $self->run_handlers("request_send", $request);
  
      unless ($response) {
          my $protocol;
  
          {
              # Honor object-specific restrictions by forcing protocol objects
              #  into class LWP::Protocol::nogo.
              my $x;
              if($x = $self->protocols_allowed) {
                  if (grep lc($_) eq $scheme, @$x) {
                  }
                  else {
                      require LWP::Protocol::nogo;
                      $protocol = LWP::Protocol::nogo->new;
                  }
              }
              elsif ($x = $self->protocols_forbidden) {
                  if(grep lc($_) eq $scheme, @$x) {
                      require LWP::Protocol::nogo;
                      $protocol = LWP::Protocol::nogo->new;
                  }
              }
              # else fall thru and create the protocol object normally
          }
  
          # Locate protocol to use
          my $proxy = $request->{proxy};
          if ($proxy) {
              $scheme = $proxy->scheme;
          }
  
          unless ($protocol) {
              $protocol = eval { LWP::Protocol::create($scheme, $self) };
              if ($@) {
                  $@ =~ s/ at .* line \d+.*//s;  # remove file/line number
                  $response =  _new_response($request, &HTTP::Status::RC_NOT_IMPLEMENTED, $@);
                  if ($scheme eq "https") {
                      $response->message($response->message . " (Crypt::SSLeay or IO::Socket::SSL not installed)");
                      $response->content_type("text/plain");
                      $response->content(<<EOT);
  LWP will support https URLs if either Crypt::SSLeay or IO::Socket::SSL
  is installed. More information at
  <http://search.cpan.org/dist/libwww-perl/README.SSL>.
  EOT
                  }
              }
          }
  
          if (!$response && $self->{use_eval}) {
              # we eval, and turn dies into responses below
              eval {
                  $response = $protocol->request($request, $proxy,
                                                 $arg, $size, $self->{timeout});
              };
              if ($@) {
                  $@ =~ s/ at .* line \d+.*//s;  # remove file/line number
                      $response = _new_response($request,
                                                &HTTP::Status::RC_INTERNAL_SERVER_ERROR,
                                                $@);
              }
          }
          elsif (!$response) {
              $response = $protocol->request($request, $proxy,
                                             $arg, $size, $self->{timeout});
              # XXX: Should we die unless $response->is_success ???
          }
      }
  
      $response->request($request);  # record request for reference
      $response->header("Client-Date" => HTTP::Date::time2str(time));
  
      $self->run_handlers("response_done", $response);
  
      $self->progress("end", $response);
      return $response;
  }
  
  
  sub prepare_request
  {
      my($self, $request) = @_;
      die "Method missing" unless $request->method;
      my $url = $request->uri;
      die "URL missing" unless $url;
      die "URL must be absolute" unless $url->scheme;
  
      $self->run_handlers("request_preprepare", $request);
  
      if (my $def_headers = $self->{def_headers}) {
  	for my $h ($def_headers->header_field_names) {
  	    $request->init_header($h => [$def_headers->header($h)]);
  	}
      }
  
      $self->run_handlers("request_prepare", $request);
  
      return $request;
  }
  
  
  sub simple_request
  {
      my($self, $request, $arg, $size) = @_;
  
      # sanity check the request passed in
      if (defined $request) {
  	if (ref $request) {
  	    Carp::croak("You need a request object, not a " . ref($request) . " object")
  	      if ref($request) eq 'ARRAY' or ref($request) eq 'HASH' or
  		 !$request->can('method') or !$request->can('uri');
  	}
  	else {
  	    Carp::croak("You need a request object, not '$request'");
  	}
      }
      else {
          Carp::croak("No request object passed in");
      }
  
      eval {
  	$request = $self->prepare_request($request);
      };
      if ($@) {
  	$@ =~ s/ at .* line \d+.*//s;  # remove file/line number
  	return _new_response($request, &HTTP::Status::RC_BAD_REQUEST, $@);
      }
      return $self->send_request($request, $arg, $size);
  }
  
  
  sub request
  {
      my($self, $request, $arg, $size, $previous) = @_;
  
      my $response = $self->simple_request($request, $arg, $size);
      $response->previous($previous) if $previous;
  
      if ($response->redirects >= $self->{max_redirect}) {
          $response->header("Client-Warning" =>
                            "Redirect loop detected (max_redirect = $self->{max_redirect})");
          return $response;
      }
  
      if (my $req = $self->run_handlers("response_redirect", $response)) {
          return $self->request($req, $arg, $size, $response);
      }
  
      my $code = $response->code;
  
      if ($code == &HTTP::Status::RC_MOVED_PERMANENTLY or
  	$code == &HTTP::Status::RC_FOUND or
  	$code == &HTTP::Status::RC_SEE_OTHER or
  	$code == &HTTP::Status::RC_TEMPORARY_REDIRECT)
      {
  	my $referral = $request->clone;
  
  	# These headers should never be forwarded
  	$referral->remove_header('Host', 'Cookie');
  	
  	if ($referral->header('Referer') &&
  	    $request->uri->scheme eq 'https' &&
  	    $referral->uri->scheme eq 'http')
  	{
  	    # RFC 2616, section 15.1.3.
  	    # https -> http redirect, suppressing Referer
  	    $referral->remove_header('Referer');
  	}
  
  	if ($code == &HTTP::Status::RC_SEE_OTHER ||
  	    $code == &HTTP::Status::RC_FOUND) 
          {
  	    my $method = uc($referral->method);
  	    unless ($method eq "GET" || $method eq "HEAD") {
  		$referral->method("GET");
  		$referral->content("");
  		$referral->remove_content_headers;
  	    }
  	}
  
  	# And then we update the URL based on the Location:-header.
  	my $referral_uri = $response->header('Location');
  	{
  	    # Some servers erroneously return a relative URL for redirects,
  	    # so make it absolute if it not already is.
  	    local $URI::ABS_ALLOW_RELATIVE_SCHEME = 1;
  	    my $base = $response->base;
  	    $referral_uri = "" unless defined $referral_uri;
  	    $referral_uri = $HTTP::URI_CLASS->new($referral_uri, $base)
  		            ->abs($base);
  	}
  	$referral->uri($referral_uri);
  
  	return $response unless $self->redirect_ok($referral, $response);
  	return $self->request($referral, $arg, $size, $response);
  
      }
      elsif ($code == &HTTP::Status::RC_UNAUTHORIZED ||
  	     $code == &HTTP::Status::RC_PROXY_AUTHENTICATION_REQUIRED
  	    )
      {
  	my $proxy = ($code == &HTTP::Status::RC_PROXY_AUTHENTICATION_REQUIRED);
  	my $ch_header = $proxy ?  "Proxy-Authenticate" : "WWW-Authenticate";
  	my @challenge = $response->header($ch_header);
  	unless (@challenge) {
  	    $response->header("Client-Warning" => 
  			      "Missing Authenticate header");
  	    return $response;
  	}
  
  	require HTTP::Headers::Util;
  	CHALLENGE: for my $challenge (@challenge) {
  	    $challenge =~ tr/,/;/;  # "," is used to separate auth-params!!
  	    ($challenge) = HTTP::Headers::Util::split_header_words($challenge);
  	    my $scheme = shift(@$challenge);
  	    shift(@$challenge); # no value
  	    $challenge = { @$challenge };  # make rest into a hash
  
  	    unless ($scheme =~ /^([a-z]+(?:-[a-z]+)*)$/) {
  		$response->header("Client-Warning" => 
  				  "Bad authentication scheme '$scheme'");
  		return $response;
  	    }
  	    $scheme = $1;  # untainted now
  	    my $class = "LWP::Authen::\u$scheme";
  	    $class =~ s/-/_/g;
  
  	    no strict 'refs';
  	    unless (%{"$class\::"}) {
  		# try to load it
  		eval "require $class";
  		if ($@) {
  		    if ($@ =~ /^Can\'t locate/) {
  			$response->header("Client-Warning" =>
  					  "Unsupported authentication scheme '$scheme'");
  		    }
  		    else {
  			$response->header("Client-Warning" => $@);
  		    }
  		    next CHALLENGE;
  		}
  	    }
  	    unless ($class->can("authenticate")) {
  		$response->header("Client-Warning" =>
  				  "Unsupported authentication scheme '$scheme'");
  		next CHALLENGE;
  	    }
  	    return $class->authenticate($self, $proxy, $challenge, $response,
  					$request, $arg, $size);
  	}
  	return $response;
      }
      return $response;
  }
  
  
  #
  # Now the shortcuts...
  #
  sub get {
      require HTTP::Request::Common;
      my($self, @parameters) = @_;
      my @suff = $self->_process_colonic_headers(\@parameters,1);
      return $self->request( HTTP::Request::Common::GET( @parameters ), @suff );
  }
  
  
  sub post {
      require HTTP::Request::Common;
      my($self, @parameters) = @_;
      my @suff = $self->_process_colonic_headers(\@parameters, (ref($parameters[1]) ? 2 : 1));
      return $self->request( HTTP::Request::Common::POST( @parameters ), @suff );
  }
  
  
  sub head {
      require HTTP::Request::Common;
      my($self, @parameters) = @_;
      my @suff = $self->_process_colonic_headers(\@parameters,1);
      return $self->request( HTTP::Request::Common::HEAD( @parameters ), @suff );
  }
  
  
  sub _process_colonic_headers {
      # Process :content_cb / :content_file / :read_size_hint headers.
      my($self, $args, $start_index) = @_;
  
      my($arg, $size);
      for(my $i = $start_index; $i < @$args; $i += 2) {
  	next unless defined $args->[$i];
  
  	#printf "Considering %s => %s\n", $args->[$i], $args->[$i + 1];
  
  	if($args->[$i] eq ':content_cb') {
  	    # Some sanity-checking...
  	    $arg = $args->[$i + 1];
  	    Carp::croak("A :content_cb value can't be undef") unless defined $arg;
  	    Carp::croak("A :content_cb value must be a coderef")
  		unless ref $arg and UNIVERSAL::isa($arg, 'CODE');
  	    
  	}
  	elsif ($args->[$i] eq ':content_file') {
  	    $arg = $args->[$i + 1];
  
  	    # Some sanity-checking...
  	    Carp::croak("A :content_file value can't be undef")
  		unless defined $arg;
  	    Carp::croak("A :content_file value can't be a reference")
  		if ref $arg;
  	    Carp::croak("A :content_file value can't be \"\"")
  		unless length $arg;
  
  	}
  	elsif ($args->[$i] eq ':read_size_hint') {
  	    $size = $args->[$i + 1];
  	    # Bother checking it?
  
  	}
  	else {
  	    next;
  	}
  	splice @$args, $i, 2;
  	$i -= 2;
      }
  
      # And return a suitable suffix-list for request(REQ,...)
  
      return             unless defined $arg;
      return $arg, $size if     defined $size;
      return $arg;
  }
  
  my @ANI = qw(- \ | /);
  
  sub progress {
      my($self, $status, $m) = @_;
      return unless $self->{show_progress};
  
      local($,, $\);
      if ($status eq "begin") {
          print STDERR "** ", $m->method, " ", $m->uri, " ==> ";
          $self->{progress_start} = time;
          $self->{progress_lastp} = "";
          $self->{progress_ani} = 0;
      }
      elsif ($status eq "end") {
          delete $self->{progress_lastp};
          delete $self->{progress_ani};
          print STDERR $m->status_line;
          my $t = time - delete $self->{progress_start};
          print STDERR " (${t}s)" if $t;
          print STDERR "\n";
      }
      elsif ($status eq "tick") {
          print STDERR "$ANI[$self->{progress_ani}++]\b";
          $self->{progress_ani} %= @ANI;
      }
      else {
          my $p = sprintf "%3.0f%%", $status * 100;
          return if $p eq $self->{progress_lastp};
          print STDERR "$p\b\b\b\b";
          $self->{progress_lastp} = $p;
      }
      STDERR->flush;
  }
  
  
  #
  # This whole allow/forbid thing is based on man 1 at's way of doing things.
  #
  sub is_protocol_supported
  {
      my($self, $scheme) = @_;
      if (ref $scheme) {
  	# assume we got a reference to an URI object
  	$scheme = $scheme->scheme;
      }
      else {
  	Carp::croak("Illegal scheme '$scheme' passed to is_protocol_supported")
  	    if $scheme =~ /\W/;
  	$scheme = lc $scheme;
      }
  
      my $x;
      if(ref($self) and $x       = $self->protocols_allowed) {
        return 0 unless grep lc($_) eq $scheme, @$x;
      }
      elsif (ref($self) and $x = $self->protocols_forbidden) {
        return 0 if grep lc($_) eq $scheme, @$x;
      }
  
      local($SIG{__DIE__});  # protect against user defined die handlers
      $x = LWP::Protocol::implementor($scheme);
      return 1 if $x and $x ne 'LWP::Protocol::nogo';
      return 0;
  }
  
  
  sub protocols_allowed      { shift->_elem('protocols_allowed'    , @_) }
  sub protocols_forbidden    { shift->_elem('protocols_forbidden'  , @_) }
  sub requests_redirectable  { shift->_elem('requests_redirectable', @_) }
  
  
  sub redirect_ok
  {
      # RFC 2616, section 10.3.2 and 10.3.3 say:
      #  If the 30[12] status code is received in response to a request other
      #  than GET or HEAD, the user agent MUST NOT automatically redirect the
      #  request unless it can be confirmed by the user, since this might
      #  change the conditions under which the request was issued.
  
      # Note that this routine used to be just:
      #  return 0 if $_[1]->method eq "POST";  return 1;
  
      my($self, $new_request, $response) = @_;
      my $method = $response->request->method;
      return 0 unless grep $_ eq $method,
        @{ $self->requests_redirectable || [] };
      
      if ($new_request->uri->scheme eq 'file') {
        $response->header("Client-Warning" =>
  			"Can't redirect to a file:// URL!");
        return 0;
      }
      
      # Otherwise it's apparently okay...
      return 1;
  }
  
  
  sub credentials
  {
      my $self = shift;
      my $netloc = lc(shift);
      my $realm = shift || "";
      my $old = $self->{basic_authentication}{$netloc}{$realm};
      if (@_) {
          $self->{basic_authentication}{$netloc}{$realm} = [@_];
      }
      return unless $old;
      return @$old if wantarray;
      return join(":", @$old);
  }
  
  
  sub get_basic_credentials
  {
      my($self, $realm, $uri, $proxy) = @_;
      return if $proxy;
      return $self->credentials($uri->host_port, $realm);
  }
  
  
  sub timeout      { shift->_elem('timeout',      @_); }
  sub local_address{ shift->_elem('local_address',@_); }
  sub max_size     { shift->_elem('max_size',     @_); }
  sub max_redirect { shift->_elem('max_redirect', @_); }
  sub show_progress{ shift->_elem('show_progress', @_); }
  
  sub parse_head {
      my $self = shift;
      if (@_) {
          my $flag = shift;
          my $parser;
          my $old = $self->set_my_handler("response_header", $flag ? sub {
                 my($response, $ua) = @_;
                 require HTML::HeadParser;
                 $parser = HTML::HeadParser->new;
                 $parser->xml_mode(1) if $response->content_is_xhtml;
                 $parser->utf8_mode(1) if $] >= 5.008 && $HTML::Parser::VERSION >= 3.40;
  
                 push(@{$response->{handlers}{response_data}}, {
  		   callback => sub {
  		       return unless $parser;
  		       unless ($parser->parse($_[3])) {
  			   my $h = $parser->header;
  			   my $r = $_[0];
  			   for my $f ($h->header_field_names) {
  			       $r->init_header($f, [$h->header($f)]);
  			   }
  			   undef($parser);
  		       }
  		   },
  	       });
  
              } : undef,
              m_media_type => "html",
          );
          return !!$old;
      }
      else {
          return !!$self->get_my_handler("response_header");
      }
  }
  
  sub cookie_jar {
      my $self = shift;
      my $old = $self->{cookie_jar};
      if (@_) {
  	my $jar = shift;
  	if (ref($jar) eq "HASH") {
  	    require HTTP::Cookies;
  	    $jar = HTTP::Cookies->new(%$jar);
  	}
  	$self->{cookie_jar} = $jar;
          $self->set_my_handler("request_prepare",
              $jar ? sub { $jar->add_cookie_header($_[0]); } : undef,
          );
          $self->set_my_handler("response_done",
              $jar ? sub { $jar->extract_cookies($_[0]); } : undef,
          );
      }
      $old;
  }
  
  sub default_headers {
      my $self = shift;
      my $old = $self->{def_headers} ||= HTTP::Headers->new;
      if (@_) {
  	Carp::croak("default_headers not set to HTTP::Headers compatible object")
  	    unless @_ == 1 && $_[0]->can("header_field_names");
  	$self->{def_headers} = shift;
      }
      return $old;
  }
  
  sub default_header {
      my $self = shift;
      return $self->default_headers->header(@_);
  }
  
  sub _agent       { "libwww-perl/$LWP::VERSION" }
  
  sub agent {
      my $self = shift;
      if (@_) {
  	my $agent = shift;
          if ($agent) {
              $agent .= $self->_agent if $agent =~ /\s+$/;
          }
          else {
              undef($agent)
          }
          return $self->default_header("User-Agent", $agent);
      }
      return $self->default_header("User-Agent");
  }
  
  sub from {  # legacy
      my $self = shift;
      return $self->default_header("From", @_);
  }
  
  
  sub conn_cache {
      my $self = shift;
      my $old = $self->{conn_cache};
      if (@_) {
  	my $cache = shift;
  	if (ref($cache) eq "HASH") {
  	    require LWP::ConnCache;
  	    $cache = LWP::ConnCache->new(%$cache);
  	}
  	$self->{conn_cache} = $cache;
      }
      $old;
  }
  
  
  sub add_handler {
      my($self, $phase, $cb, %spec) = @_;
      $spec{line} ||= join(":", (caller)[1,2]);
      my $conf = $self->{handlers}{$phase} ||= do {
          require HTTP::Config;
          HTTP::Config->new;
      };
      $conf->add(%spec, callback => $cb);
  }
  
  sub set_my_handler {
      my($self, $phase, $cb, %spec) = @_;
      $spec{owner} = (caller(1))[3] unless exists $spec{owner};
      $self->remove_handler($phase, %spec);
      $spec{line} ||= join(":", (caller)[1,2]);
      $self->add_handler($phase, $cb, %spec) if $cb;
  }
  
  sub get_my_handler {
      my $self = shift;
      my $phase = shift;
      my $init = pop if @_ % 2;
      my %spec = @_;
      my $conf = $self->{handlers}{$phase};
      unless ($conf) {
          return unless $init;
          require HTTP::Config;
          $conf = $self->{handlers}{$phase} = HTTP::Config->new;
      }
      $spec{owner} = (caller(1))[3] unless exists $spec{owner};
      my @h = $conf->find(%spec);
      if (!@h && $init) {
          if (ref($init) eq "CODE") {
              $init->(\%spec);
          }
          elsif (ref($init) eq "HASH") {
              while (my($k, $v) = each %$init) {
                  $spec{$k} = $v;
              }
          }
          $spec{callback} ||= sub {};
          $spec{line} ||= join(":", (caller)[1,2]);
          $conf->add(\%spec);
          return \%spec;
      }
      return wantarray ? @h : $h[0];
  }
  
  sub remove_handler {
      my($self, $phase, %spec) = @_;
      if ($phase) {
          my $conf = $self->{handlers}{$phase} || return;
          my @h = $conf->remove(%spec);
          delete $self->{handlers}{$phase} if $conf->empty;
          return @h;
      }
  
      return unless $self->{handlers};
      return map $self->remove_handler($_), sort keys %{$self->{handlers}};
  }
  
  sub handlers {
      my($self, $phase, $o) = @_;
      my @h;
      if ($o->{handlers} && $o->{handlers}{$phase}) {
          push(@h, @{$o->{handlers}{$phase}});
      }
      if (my $conf = $self->{handlers}{$phase}) {
          push(@h, $conf->matching($o));
      }
      return @h;
  }
  
  sub run_handlers {
      my($self, $phase, $o) = @_;
      if (defined(wantarray)) {
          for my $h ($self->handlers($phase, $o)) {
              my $ret = $h->{callback}->($o, $self, $h);
              return $ret if $ret;
          }
          return undef;
      }
  
      for my $h ($self->handlers($phase, $o)) {
          $h->{callback}->($o, $self, $h);
      }
  }
  
  
  # depreciated
  sub use_eval   { shift->_elem('use_eval',  @_); }
  sub use_alarm
  {
      Carp::carp("LWP::UserAgent->use_alarm(BOOL) is a no-op")
  	if @_ > 1 && $^W;
      "";
  }
  
  
  sub clone
  {
      my $self = shift;
      my $copy = bless { %$self }, ref $self;  # copy most fields
  
      delete $copy->{handlers};
      delete $copy->{conn_cache};
  
      # copy any plain arrays and hashes; known not to need recursive copy
      for my $k (qw(proxy no_proxy requests_redirectable)) {
          next unless $copy->{$k};
          if (ref($copy->{$k}) eq "ARRAY") {
              $copy->{$k} = [ @{$copy->{$k}} ];
          }
          elsif (ref($copy->{$k}) eq "HASH") {
              $copy->{$k} = { %{$copy->{$k}} };
          }
      }
  
      if ($self->{def_headers}) {
          $copy->{def_headers} = $self->{def_headers}->clone;
      }
  
      # re-enable standard handlers
      $copy->parse_head($self->parse_head);
  
      # no easy way to clone the cookie jar; so let's just remove it for now
      $copy->cookie_jar(undef);
  
      $copy;
  }
  
  
  sub mirror
  {
      my($self, $url, $file) = @_;
  
      my $request = HTTP::Request->new('GET', $url);
  
      # If the file exists, add a cache-related header
      if ( -e $file ) {
          my ($mtime) = ( stat($file) )[9];
          if ($mtime) {
              $request->header( 'If-Modified-Since' => HTTP::Date::time2str($mtime) );
          }
      }
      my $tmpfile = "$file-$$";
  
      my $response = $self->request($request, $tmpfile);
      if ( $response->header('X-Died') ) {
  	die $response->header('X-Died');
      }
  
      # Only fetching a fresh copy of the would be considered success.
      # If the file was not modified, "304" would returned, which 
      # is considered by HTTP::Status to be a "redirect", /not/ "success"
      if ( $response->is_success ) {
          my @stat        = stat($tmpfile) or die "Could not stat tmpfile '$tmpfile': $!";
          my $file_length = $stat[7];
          my ($content_length) = $response->header('Content-length');
  
          if ( defined $content_length and $file_length < $content_length ) {
              unlink($tmpfile);
              die "Transfer truncated: " . "only $file_length out of $content_length bytes received\n";
          }
          elsif ( defined $content_length and $file_length > $content_length ) {
              unlink($tmpfile);
              die "Content-length mismatch: " . "expected $content_length bytes, got $file_length\n";
          }
          # The file was the expected length. 
          else {
              # Replace the stale file with a fresh copy
              if ( -e $file ) {
                  # Some dosish systems fail to rename if the target exists
                  chmod 0777, $file;
                  unlink $file;
              }
              rename( $tmpfile, $file )
                  or die "Cannot rename '$tmpfile' to '$file': $!\n";
  
              # make sure the file has the same last modification time
              if ( my $lm = $response->last_modified ) {
                  utime $lm, $lm, $file;
              }
          }
      }
      # The local copy is fresh enough, so just delete the temp file  
      else {
  	unlink($tmpfile);
      }
      return $response;
  }
  
  
  sub _need_proxy {
      my($req, $ua) = @_;
      return if exists $req->{proxy};
      my $proxy = $ua->{proxy}{$req->uri->scheme} || return;
      if ($ua->{no_proxy}) {
          if (my $host = eval { $req->uri->host }) {
              for my $domain (@{$ua->{no_proxy}}) {
                  if ($host =~ /\Q$domain\E$/) {
                      return;
                  }
              }
          }
      }
      $req->{proxy} = $HTTP::URI_CLASS->new($proxy);
  }
  
  
  sub proxy
  {
      my $self = shift;
      my $key  = shift;
      return map $self->proxy($_, @_), @$key if ref $key;
  
      Carp::croak("'$key' is not a valid URI scheme") unless $key =~ /^$URI::scheme_re\z/;
      my $old = $self->{'proxy'}{$key};
      if (@_) {
          my $url = shift;
          if (defined($url) && length($url)) {
              Carp::croak("Proxy must be specified as absolute URI; '$url' is not") unless $url =~ /^$URI::scheme_re:/;
              Carp::croak("Bad http proxy specification '$url'") if $url =~ /^https?:/ && $url !~ m,^https?://\w,;
          }
          $self->{proxy}{$key} = $url;
          $self->set_my_handler("request_preprepare", \&_need_proxy)
      }
      return $old;
  }
  
  
  sub env_proxy {
      my ($self) = @_;
      my($k,$v);
      while(($k, $v) = each %ENV) {
  	if ($ENV{REQUEST_METHOD}) {
  	    # Need to be careful when called in the CGI environment, as
  	    # the HTTP_PROXY variable is under control of that other guy.
  	    next if $k =~ /^HTTP_/;
  	    $k = "HTTP_PROXY" if $k eq "CGI_HTTP_PROXY";
  	}
  	$k = lc($k);
  	next unless $k =~ /^(.*)_proxy$/;
  	$k = $1;
  	if ($k eq 'no') {
  	    $self->no_proxy(split(/\s*,\s*/, $v));
  	}
  	else {
              # Ignore random _proxy variables, allow only valid schemes
              next unless $k =~ /^$URI::scheme_re\z/;
              # Ignore xxx_proxy variables if xxx isn't a supported protocol
              next unless LWP::Protocol::implementor($k);
  	    $self->proxy($k, $v);
  	}
      }
  }
  
  
  sub no_proxy {
      my($self, @no) = @_;
      if (@no) {
  	push(@{ $self->{'no_proxy'} }, @no);
      }
      else {
  	$self->{'no_proxy'} = [];
      }
  }
  
  
  sub _new_response {
      my($request, $code, $message) = @_;
      my $response = HTTP::Response->new($code, $message);
      $response->request($request);
      $response->header("Client-Date" => HTTP::Date::time2str(time));
      $response->header("Client-Warning" => "Internal response");
      $response->header("Content-Type" => "text/plain");
      $response->content("$code $message\n");
      return $response;
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  LWP::UserAgent - Web user agent class
  
  =head1 SYNOPSIS
  
   require LWP::UserAgent;
   
   my $ua = LWP::UserAgent->new;
   $ua->timeout(10);
   $ua->env_proxy;
   
   my $response = $ua->get('http://search.cpan.org/');
   
   if ($response->is_success) {
       print $response->decoded_content;  # or whatever
   }
   else {
       die $response->status_line;
   }
  
  =head1 DESCRIPTION
  
  The C<LWP::UserAgent> is a class implementing a web user agent.
  C<LWP::UserAgent> objects can be used to dispatch web requests.
  
  In normal use the application creates an C<LWP::UserAgent> object, and
  then configures it with values for timeouts, proxies, name, etc. It
  then creates an instance of C<HTTP::Request> for the request that
  needs to be performed. This request is then passed to one of the
  request method the UserAgent, which dispatches it using the relevant
  protocol, and returns a C<HTTP::Response> object.  There are
  convenience methods for sending the most common request types: get(),
  head() and post().  When using these methods then the creation of the
  request object is hidden as shown in the synopsis above.
  
  The basic approach of the library is to use HTTP style communication
  for all protocol schemes.  This means that you will construct
  C<HTTP::Request> objects and receive C<HTTP::Response> objects even
  for non-HTTP resources like I<gopher> and I<ftp>.  In order to achieve
  even more similarity to HTTP style communications, gopher menus and
  file directories are converted to HTML documents.
  
  =head1 CONSTRUCTOR METHODS
  
  The following constructor methods are available:
  
  =over 4
  
  =item $ua = LWP::UserAgent->new( %options )
  
  This method constructs a new C<LWP::UserAgent> object and returns it.
  Key/value pair arguments may be provided to set up the initial state.
  The following options correspond to attribute methods described below:
  
     KEY                     DEFAULT
     -----------             --------------------
     agent                   "libwww-perl/#.###"
     from                    undef
     conn_cache              undef
     cookie_jar              undef
     default_headers         HTTP::Headers->new
     local_address           undef
     max_size                undef
     max_redirect            7
     parse_head              1
     protocols_allowed       undef
     protocols_forbidden     undef
     requests_redirectable   ['GET', 'HEAD']
     timeout                 180
  
  The following additional options are also accepted: If the
  C<env_proxy> option is passed in with a TRUE value, then proxy
  settings are read from environment variables (see env_proxy() method
  below).  If the C<keep_alive> option is passed in, then a
  C<LWP::ConnCache> is set up (see conn_cache() method below).  The
  C<keep_alive> value is passed on as the C<total_capacity> for the
  connection cache.
  
  =item $ua->clone
  
  Returns a copy of the LWP::UserAgent object.
  
  =back
  
  =head1 ATTRIBUTES
  
  The settings of the configuration attributes modify the behaviour of the
  C<LWP::UserAgent> when it dispatches requests.  Most of these can also
  be initialized by options passed to the constructor method.
  
  The following attribute methods are provided.  The attribute value is
  left unchanged if no argument is given.  The return value from each
  method is the old attribute value.
  
  =over
  
  =item $ua->agent
  
  =item $ua->agent( $product_id )
  
  Get/set the product token that is used to identify the user agent on
  the network.  The agent value is sent as the "User-Agent" header in
  the requests.  The default is the string returned by the _agent()
  method (see below).
  
  If the $product_id ends with space then the _agent() string is
  appended to it.
  
  The user agent string should be one or more simple product identifiers
  with an optional version number separated by the "/" character.
  Examples are:
  
    $ua->agent('Checkbot/0.4 ' . $ua->_agent);
    $ua->agent('Checkbot/0.4 ');    # same as above
    $ua->agent('Mozilla/5.0');
    $ua->agent("");                 # don't identify
  
  =item $ua->_agent
  
  Returns the default agent identifier.  This is a string of the form
  "libwww-perl/#.###", where "#.###" is substituted with the version number
  of this library.
  
  =item $ua->from
  
  =item $ua->from( $email_address )
  
  Get/set the e-mail address for the human user who controls
  the requesting user agent.  The address should be machine-usable, as
  defined in RFC 822.  The C<from> value is send as the "From" header in
  the requests.  Example:
  
    $ua->from('gaas@cpan.org');
  
  The default is to not send a "From" header.  See the default_headers()
  method for the more general interface that allow any header to be defaulted.
  
  =item $ua->cookie_jar
  
  =item $ua->cookie_jar( $cookie_jar_obj )
  
  Get/set the cookie jar object to use.  The only requirement is that
  the cookie jar object must implement the extract_cookies($request) and
  add_cookie_header($response) methods.  These methods will then be
  invoked by the user agent as requests are sent and responses are
  received.  Normally this will be a C<HTTP::Cookies> object or some
  subclass.
  
  The default is to have no cookie_jar, i.e. never automatically add
  "Cookie" headers to the requests.
  
  Shortcut: If a reference to a plain hash is passed in as the
  $cookie_jar_object, then it is replaced with an instance of
  C<HTTP::Cookies> that is initialized based on the hash.  This form also
  automatically loads the C<HTTP::Cookies> module.  It means that:
  
    $ua->cookie_jar({ file => "$ENV{HOME}/.cookies.txt" });
  
  is really just a shortcut for:
  
    require HTTP::Cookies;
    $ua->cookie_jar(HTTP::Cookies->new(file => "$ENV{HOME}/.cookies.txt"));
  
  =item $ua->default_headers
  
  =item $ua->default_headers( $headers_obj )
  
  Get/set the headers object that will provide default header values for
  any requests sent.  By default this will be an empty C<HTTP::Headers>
  object.
  
  =item $ua->default_header( $field )
  
  =item $ua->default_header( $field => $value )
  
  This is just a short-cut for $ua->default_headers->header( $field =>
  $value ). Example:
  
    $ua->default_header('Accept-Encoding' => scalar HTTP::Message::decodable());
    $ua->default_header('Accept-Language' => "no, en");
  
  =item $ua->conn_cache
  
  =item $ua->conn_cache( $cache_obj )
  
  Get/set the C<LWP::ConnCache> object to use.  See L<LWP::ConnCache>
  for details.
  
  =item $ua->credentials( $netloc, $realm )
  
  =item $ua->credentials( $netloc, $realm, $uname, $pass )
  
  Get/set the user name and password to be used for a realm.
  
  The $netloc is a string of the form "<host>:<port>".  The username and
  password will only be passed to this server.  Example:
  
    $ua->credentials("www.example.com:80", "Some Realm", "foo", "secret");
  
  =item $ua->local_address
  
  =item $ua->local_address( $address )
  
  Get/set the local interface to bind to for network connections.  The interface
  can be specified as a hostname or an IP address.  This value is passed as the
  C<LocalAddr> argument to L<IO::Socket::INET>.
  
  =item $ua->max_size
  
  =item $ua->max_size( $bytes )
  
  Get/set the size limit for response content.  The default is C<undef>,
  which means that there is no limit.  If the returned response content
  is only partial, because the size limit was exceeded, then a
  "Client-Aborted" header will be added to the response.  The content
  might end up longer than C<max_size> as we abort once appending a
  chunk of data makes the length exceed the limit.  The "Content-Length"
  header, if present, will indicate the length of the full content and
  will normally not be the same as C<< length($res->content) >>.
  
  =item $ua->max_redirect
  
  =item $ua->max_redirect( $n )
  
  This reads or sets the object's limit of how many times it will obey
  redirection responses in a given request cycle.
  
  By default, the value is 7. This means that if you call request()
  method and the response is a redirect elsewhere which is in turn a
  redirect, and so on seven times, then LWP gives up after that seventh
  request.
  
  =item $ua->parse_head
  
  =item $ua->parse_head( $boolean )
  
  Get/set a value indicating whether we should initialize response
  headers from the E<lt>head> section of HTML documents. The default is
  TRUE.  Do not turn this off, unless you know what you are doing.
  
  =item $ua->protocols_allowed
  
  =item $ua->protocols_allowed( \@protocols )
  
  This reads (or sets) this user agent's list of protocols that the
  request methods will exclusively allow.  The protocol names are case
  insensitive.
  
  For example: C<$ua-E<gt>protocols_allowed( [ 'http', 'https'] );>
  means that this user agent will I<allow only> those protocols,
  and attempts to use this user agent to access URLs with any other
  schemes (like "ftp://...") will result in a 500 error.
  
  To delete the list, call: C<$ua-E<gt>protocols_allowed(undef)>
  
  By default, an object has neither a C<protocols_allowed> list, nor a
  C<protocols_forbidden> list.
  
  Note that having a C<protocols_allowed> list causes any
  C<protocols_forbidden> list to be ignored.
  
  =item $ua->protocols_forbidden
  
  =item $ua->protocols_forbidden( \@protocols )
  
  This reads (or sets) this user agent's list of protocols that the
  request method will I<not> allow. The protocol names are case
  insensitive.
  
  For example: C<$ua-E<gt>protocols_forbidden( [ 'file', 'mailto'] );>
  means that this user agent will I<not> allow those protocols, and
  attempts to use this user agent to access URLs with those schemes
  will result in a 500 error.
  
  To delete the list, call: C<$ua-E<gt>protocols_forbidden(undef)>
  
  =item $ua->requests_redirectable
  
  =item $ua->requests_redirectable( \@requests )
  
  This reads or sets the object's list of request names that
  C<$ua-E<gt>redirect_ok(...)> will allow redirection for.  By
  default, this is C<['GET', 'HEAD']>, as per RFC 2616.  To
  change to include 'POST', consider:
  
     push @{ $ua->requests_redirectable }, 'POST';
  
  =item $ua->show_progress
  
  =item $ua->show_progress( $boolean )
  
  Get/set a value indicating whether a progress bar should be displayed
  on on the terminal as requests are processed. The default is FALSE.
  
  =item $ua->timeout
  
  =item $ua->timeout( $secs )
  
  Get/set the timeout value in seconds. The default timeout() value is
  180 seconds, i.e. 3 minutes.
  
  The requests is aborted if no activity on the connection to the server
  is observed for C<timeout> seconds.  This means that the time it takes
  for the complete transaction and the request() method to actually
  return might be longer.
  
  =back
  
  =head2 Proxy attributes
  
  The following methods set up when requests should be passed via a
  proxy server.
  
  =over
  
  =item $ua->proxy(\@schemes, $proxy_url)
  
  =item $ua->proxy($scheme, $proxy_url)
  
  Set/retrieve proxy URL for a scheme:
  
   $ua->proxy(['http', 'ftp'], 'http://proxy.sn.no:8001/');
   $ua->proxy('gopher', 'http://proxy.sn.no:8001/');
  
  The first form specifies that the URL is to be used for proxying of
  access methods listed in the list in the first method argument,
  i.e. 'http' and 'ftp'.
  
  The second form shows a shorthand form for specifying
  proxy URL for a single access scheme.
  
  =item $ua->no_proxy( $domain, ... )
  
  Do not proxy requests to the given domains.  Calling no_proxy without
  any domains clears the list of domains. Eg:
  
   $ua->no_proxy('localhost', 'example.com');
  
  =item $ua->env_proxy
  
  Load proxy settings from *_proxy environment variables.  You might
  specify proxies like this (sh-syntax):
  
    gopher_proxy=http://proxy.my.place/
    wais_proxy=http://proxy.my.place/
    no_proxy="localhost,example.com"
    export gopher_proxy wais_proxy no_proxy
  
  csh or tcsh users should use the C<setenv> command to define these
  environment variables.
  
  On systems with case insensitive environment variables there exists a
  name clash between the CGI environment variables and the C<HTTP_PROXY>
  environment variable normally picked up by env_proxy().  Because of
  this C<HTTP_PROXY> is not honored for CGI scripts.  The
  C<CGI_HTTP_PROXY> environment variable can be used instead.
  
  =back
  
  =head2 Handlers
  
  Handlers are code that injected at various phases during the
  processing of requests.  The following methods are provided to manage
  the active handlers:
  
  =over
  
  =item $ua->add_handler( $phase => \&cb, %matchspec )
  
  Add handler to be invoked in the given processing phase.  For how to
  specify %matchspec see L<HTTP::Config/"Matching">.
  
  The possible values $phase and the corresponding callback signatures are:
  
  =over
  
  =item request_preprepare => sub { my($request, $ua, $h) = @_; ... }
  
  The handler is called before the C<request_prepare> and other standard
  initialization of of the request.  This can be used to set up headers
  and attributes that the C<request_prepare> handler depends on.  Proxy
  initialization should take place here; but in general don't register
  handlers for this phase.
  
  =item request_prepare => sub { my($request, $ua, $h) = @_; ... }
  
  The handler is called before the request is sent and can modify the
  request any way it see fit.  This can for instance be used to add
  certain headers to specific requests.
  
  The method can assign a new request object to $_[0] to replace the
  request that is sent fully.
  
  The return value from the callback is ignored.  If an exceptions is
  raised it will abort the request and make the request method return a
  "400 Bad request" response.
  
  =item request_send => sub { my($request, $ua, $h) = @_; ... }
  
  This handler get a chance of handling requests before it's sent to the
  protocol handlers.  It should return an HTTP::Response object if it
  wishes to terminate the processing; otherwise it should return nothing.
  
  The C<response_header> and C<response_data> handlers will not be
  invoked for this response, but the C<response_done> will be.
  
  =item response_header => sub { my($response, $ua, $h) = @_; ... }
  
  This handler is called right after the response headers have been
  received, but before any content data.  The handler might set up
  handlers for data and might croak to abort the request.
  
  The handler might set the $response->{default_add_content} value to
  control if any received data should be added to the response object
  directly.  This will initially be false if the $ua->request() method
  was called with a $content_file or $content_cb argument; otherwise true.
  
  =item response_data => sub { my($response, $ua, $h, $data) = @_; ... }
  
  This handlers is called for each chunk of data received for the
  response.  The handler might croak to abort the request.
  
  This handler need to return a TRUE value to be called again for
  subsequent chunks for the same request.
  
  =item response_done => sub { my($response, $ua, $h) = @_; ... }
  
  The handler is called after the response has been fully received, but
  before any redirect handling is attempted.  The handler can be used to
  extract information or modify the response.
  
  =item response_redirect => sub { my($response, $ua, $h) = @_; ... }
  
  The handler is called in $ua->request after C<response_done>.  If the
  handler return an HTTP::Request object we'll start over with processing
  this request instead.
  
  =back
  
  =item $ua->remove_handler( undef, %matchspec )
  
  =item $ua->remove_handler( $phase, %matchspec )
  
  Remove handlers that match the given %matchspec.  If $phase is not
  provided remove handlers from all phases.
  
  Be careful as calling this function with %matchspec that is not not
  specific enough can remove handlers not owned by you.  It's probably
  better to use the set_my_handler() method instead.
  
  The removed handlers are returned.
  
  =item $ua->set_my_handler( $phase, $cb, %matchspec )
  
  Set handlers private to the executing subroutine.  Works by defaulting
  an C<owner> field to the %matchspec that holds the name of the called
  subroutine.  You might pass an explicit C<owner> to override this.
  
  If $cb is passed as C<undef>, remove the handler.
  
  =item $ua->get_my_handler( $phase, %matchspec )
  
  =item $ua->get_my_handler( $phase, %matchspec, $init )
  
  Will retrieve the matching handler as hash ref.
  
  If C<$init> is passed passed as a TRUE value, create and add the
  handler if it's not found.  If $init is a subroutine reference, then
  it's called with the created handler hash as argument.  This sub might
  populate the hash with extra fields; especially the callback.  If
  $init is a hash reference, merge the hashes.
  
  =item $ua->handlers( $phase, $request )
  
  =item $ua->handlers( $phase, $response )
  
  Returns the handlers that apply to the given request or response at
  the given processing phase.
  
  =back
  
  =head1 REQUEST METHODS
  
  The methods described in this section are used to dispatch requests
  via the user agent.  The following request methods are provided:
  
  =over
  
  =item $ua->get( $url )
  
  =item $ua->get( $url , $field_name => $value, ... )
  
  This method will dispatch a C<GET> request on the given $url.  Further
  arguments can be given to initialize the headers of the request. These
  are given as separate name/value pairs.  The return value is a
  response object.  See L<HTTP::Response> for a description of the
  interface it provides.
  
  There will still be a response object returned when LWP can't connect to the
  server specified in the URL or when other failures in protocol handlers occur.
  These internal responses use the standard HTTP status codes, so the responses
  can't be differentiated by testing the response status code alone.  Error
  responses that LWP generates internally will have the "Client-Warning" header
  set to the value "Internal response".  If you need to differentiate these
  internal responses from responses that a remote server actually generates, you
  need to test this header value.
  
  Fields names that start with ":" are special.  These will not
  initialize headers of the request but will determine how the response
  content is treated.  The following special field names are recognized:
  
      :content_file   => $filename
      :content_cb     => \&callback
      :read_size_hint => $bytes
  
  If a $filename is provided with the C<:content_file> option, then the
  response content will be saved here instead of in the response
  object.  If a callback is provided with the C<:content_cb> option then
  this function will be called for each chunk of the response content as
  it is received from the server.  If neither of these options are
  given, then the response content will accumulate in the response
  object itself.  This might not be suitable for very large response
  bodies.  Only one of C<:content_file> or C<:content_cb> can be
  specified.  The content of unsuccessful responses will always
  accumulate in the response object itself, regardless of the
  C<:content_file> or C<:content_cb> options passed in.
  
  The C<:read_size_hint> option is passed to the protocol module which
  will try to read data from the server in chunks of this size.  A
  smaller value for the C<:read_size_hint> will result in a higher
  number of callback invocations.
  
  The callback function is called with 3 arguments: a chunk of data, a
  reference to the response object, and a reference to the protocol
  object.  The callback can abort the request by invoking die().  The
  exception message will show up as the "X-Died" header field in the
  response returned by the get() function.
  
  =item $ua->head( $url )
  
  =item $ua->head( $url , $field_name => $value, ... )
  
  This method will dispatch a C<HEAD> request on the given $url.
  Otherwise it works like the get() method described above.
  
  =item $ua->post( $url, \%form )
  
  =item $ua->post( $url, \@form )
  
  =item $ua->post( $url, \%form, $field_name => $value, ... )
  
  =item $ua->post( $url, $field_name => $value,... Content => \%form )
  
  =item $ua->post( $url, $field_name => $value,... Content => \@form )
  
  =item $ua->post( $url, $field_name => $value,... Content => $content )
  
  This method will dispatch a C<POST> request on the given $url, with
  %form or @form providing the key/value pairs for the fill-in form
  content. Additional headers and content options are the same as for
  the get() method.
  
  This method will use the POST() function from C<HTTP::Request::Common>
  to build the request.  See L<HTTP::Request::Common> for a details on
  how to pass form content and other advanced features.
  
  =item $ua->mirror( $url, $filename )
  
  This method will get the document identified by $url and store it in
  file called $filename.  If the file already exists, then the request
  will contain an "If-Modified-Since" header matching the modification
  time of the file.  If the document on the server has not changed since
  this time, then nothing happens.  If the document has been updated, it
  will be downloaded again.  The modification time of the file will be
  forced to match that of the server.
  
  The return value is the the response object.
  
  =item $ua->request( $request )
  
  =item $ua->request( $request, $content_file )
  
  =item $ua->request( $request, $content_cb )
  
  =item $ua->request( $request, $content_cb, $read_size_hint )
  
  This method will dispatch the given $request object.  Normally this
  will be an instance of the C<HTTP::Request> class, but any object with
  a similar interface will do.  The return value is a response object.
  See L<HTTP::Request> and L<HTTP::Response> for a description of the
  interface provided by these classes.
  
  The request() method will process redirects and authentication
  responses transparently.  This means that it may actually send several
  simple requests via the simple_request() method described below.
  
  The request methods described above; get(), head(), post() and
  mirror(), will all dispatch the request they build via this method.
  They are convenience methods that simply hides the creation of the
  request object for you.
  
  The $content_file, $content_cb and $read_size_hint all correspond to
  options described with the get() method above.
  
  You are allowed to use a CODE reference as C<content> in the request
  object passed in.  The C<content> function should return the content
  when called.  The content can be returned in chunks.  The content
  function will be invoked repeatedly until it return an empty string to
  signal that there is no more content.
  
  =item $ua->simple_request( $request )
  
  =item $ua->simple_request( $request, $content_file )
  
  =item $ua->simple_request( $request, $content_cb )
  
  =item $ua->simple_request( $request, $content_cb, $read_size_hint )
  
  This method dispatches a single request and returns the response
  received.  Arguments are the same as for request() described above.
  
  The difference from request() is that simple_request() will not try to
  handle redirects or authentication responses.  The request() method
  will in fact invoke this method for each simple request it sends.
  
  =item $ua->is_protocol_supported( $scheme )
  
  You can use this method to test whether this user agent object supports the
  specified C<scheme>.  (The C<scheme> might be a string (like 'http' or
  'ftp') or it might be an URI object reference.)
  
  Whether a scheme is supported, is determined by the user agent's
  C<protocols_allowed> or C<protocols_forbidden> lists (if any), and by
  the capabilities of LWP.  I.e., this will return TRUE only if LWP
  supports this protocol I<and> it's permitted for this particular
  object.
  
  =back
  
  =head2 Callback methods
  
  The following methods will be invoked as requests are processed. These
  methods are documented here because subclasses of C<LWP::UserAgent>
  might want to override their behaviour.
  
  =over
  
  =item $ua->prepare_request( $request )
  
  This method is invoked by simple_request().  Its task is to modify the
  given $request object by setting up various headers based on the
  attributes of the user agent. The return value should normally be the
  $request object passed in.  If a different request object is returned
  it will be the one actually processed.
  
  The headers affected by the base implementation are; "User-Agent",
  "From", "Range" and "Cookie".
  
  =item $ua->redirect_ok( $prospective_request, $response )
  
  This method is called by request() before it tries to follow a
  redirection to the request in $response.  This should return a TRUE
  value if this redirection is permissible.  The $prospective_request
  will be the request to be sent if this method returns TRUE.
  
  The base implementation will return FALSE unless the method
  is in the object's C<requests_redirectable> list,
  FALSE if the proposed redirection is to a "file://..."
  URL, and TRUE otherwise.
  
  =item $ua->get_basic_credentials( $realm, $uri, $isproxy )
  
  This is called by request() to retrieve credentials for documents
  protected by Basic or Digest Authentication.  The arguments passed in
  is the $realm provided by the server, the $uri requested and a boolean
  flag to indicate if this is authentication against a proxy server.
  
  The method should return a username and password.  It should return an
  empty list to abort the authentication resolution attempt.  Subclasses
  can override this method to prompt the user for the information. An
  example of this can be found in C<lwp-request> program distributed
  with this library.
  
  The base implementation simply checks a set of pre-stored member
  variables, set up with the credentials() method.
  
  =item $ua->progress( $status, $request_or_response )
  
  This is called frequently as the response is received regardless of
  how the content is processed.  The method is called with $status
  "begin" at the start of processing the request and with $state "end"
  before the request method returns.  In between these $status will be
  the fraction of the response currently received or the string "tick"
  if the fraction can't be calculated.
  
  When $status is "begin" the second argument is the request object,
  otherwise it is the response object.
  
  =back
  
  =head1 SEE ALSO
  
  See L<LWP> for a complete overview of libwww-perl5.  See L<lwpcook>
  and the scripts F<lwp-request> and F<lwp-download> for examples of
  usage.
  
  See L<HTTP::Request> and L<HTTP::Response> for a description of the
  message objects dispatched and received.  See L<HTTP::Request::Common>
  and L<HTML::Form> for other ways to build request objects.
  
  See L<WWW::Mechanize> and L<WWW::Search> for examples of more
  specialized user agents based on C<LWP::UserAgent>.
  
  =head1 COPYRIGHT
  
  Copyright 1995-2009 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
LWP_USERAGENT

$fatpacked{"Net/HTTP.pm"} = <<'NET_HTTP';
  package Net::HTTP;
  
  use strict;
  use vars qw($VERSION @ISA $SOCKET_CLASS);
  
  $VERSION = "5.834";
  unless ($SOCKET_CLASS) {
      eval { require IO::Socket::INET } || require IO::Socket;
      $SOCKET_CLASS = "IO::Socket::INET";
  }
  require Net::HTTP::Methods;
  require Carp;
  
  @ISA = ($SOCKET_CLASS, 'Net::HTTP::Methods');
  
  sub new {
      my $class = shift;
      Carp::croak("No Host option provided") unless @_;
      $class->SUPER::new(@_);
  }
  
  sub configure {
      my($self, $cnf) = @_;
      $self->http_configure($cnf);
  }
  
  sub http_connect {
      my($self, $cnf) = @_;
      $self->SUPER::configure($cnf);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Net::HTTP - Low-level HTTP connection (client)
  
  =head1 SYNOPSIS
  
   use Net::HTTP;
   my $s = Net::HTTP->new(Host => "www.perl.com") || die $@;
   $s->write_request(GET => "/", 'User-Agent' => "Mozilla/5.0");
   my($code, $mess, %h) = $s->read_response_headers;
  
   while (1) {
      my $buf;
      my $n = $s->read_entity_body($buf, 1024);
      die "read failed: $!" unless defined $n;
      last unless $n;
      print $buf;
   }
  
  =head1 DESCRIPTION
  
  The C<Net::HTTP> class is a low-level HTTP client.  An instance of the
  C<Net::HTTP> class represents a connection to an HTTP server.  The
  HTTP protocol is described in RFC 2616.  The C<Net::HTTP> class
  supports C<HTTP/1.0> and C<HTTP/1.1>.
  
  C<Net::HTTP> is a sub-class of C<IO::Socket::INET>.  You can mix the
  methods described below with reading and writing from the socket
  directly.  This is not necessary a good idea, unless you know what you
  are doing.
  
  The following methods are provided (in addition to those of
  C<IO::Socket::INET>):
  
  =over
  
  =item $s = Net::HTTP->new( %options )
  
  The C<Net::HTTP> constructor method takes the same options as
  C<IO::Socket::INET>'s as well as these:
  
    Host:            Initial host attribute value
    KeepAlive:       Initial keep_alive attribute value
    SendTE:          Initial send_te attribute_value
    HTTPVersion:     Initial http_version attribute value
    PeerHTTPVersion: Initial peer_http_version attribute value
    MaxLineLength:   Initial max_line_length attribute value
    MaxHeaderLines:  Initial max_header_lines attribute value
  
  The C<Host> option is also the default for C<IO::Socket::INET>'s
  C<PeerAddr>.  The C<PeerPort> defaults to 80 if not provided.
  
  The C<Listen> option provided by C<IO::Socket::INET>'s constructor
  method is not allowed.
  
  If unable to connect to the given HTTP server then the constructor
  returns C<undef> and $@ contains the reason.  After a successful
  connect, a C<Net:HTTP> object is returned.
  
  =item $s->host
  
  Get/set the default value of the C<Host> header to send.  The $host
  must not be set to an empty string (or C<undef>) for HTTP/1.1.
  
  =item $s->keep_alive
  
  Get/set the I<keep-alive> value.  If this value is TRUE then the
  request will be sent with headers indicating that the server should try
  to keep the connection open so that multiple requests can be sent.
  
  The actual headers set will depend on the value of the C<http_version>
  and C<peer_http_version> attributes.
  
  =item $s->send_te
  
  Get/set the a value indicating if the request will be sent with a "TE"
  header to indicate the transfer encodings that the server can choose to
  use.  The list of encodings announced as accepted by this client depends
  on availability of the following modules: C<Compress::Raw::Zlib> for
  I<deflate>, and C<IO::Compress::Gunzip> for I<gzip>.
  
  =item $s->http_version
  
  Get/set the HTTP version number that this client should announce.
  This value can only be set to "1.0" or "1.1".  The default is "1.1".
  
  =item $s->peer_http_version
  
  Get/set the protocol version number of our peer.  This value will
  initially be "1.0", but will be updated by a successful
  read_response_headers() method call.
  
  =item $s->max_line_length
  
  Get/set a limit on the length of response line and response header
  lines.  The default is 8192.  A value of 0 means no limit.
  
  =item $s->max_header_length
  
  Get/set a limit on the number of header lines that a response can
  have.  The default is 128.  A value of 0 means no limit.
  
  =item $s->format_request($method, $uri, %headers, [$content])
  
  Format a request message and return it as a string.  If the headers do
  not include a C<Host> header, then a header is inserted with the value
  of the C<host> attribute.  Headers like C<Connection> and
  C<Keep-Alive> might also be added depending on the status of the
  C<keep_alive> attribute.
  
  If $content is given (and it is non-empty), then a C<Content-Length>
  header is automatically added unless it was already present.
  
  =item $s->write_request($method, $uri, %headers, [$content])
  
  Format and send a request message.  Arguments are the same as for
  format_request().  Returns true if successful.
  
  =item $s->format_chunk( $data )
  
  Returns the string to be written for the given chunk of data.  
  
  =item $s->write_chunk($data)
  
  Will write a new chunk of request entity body data.  This method
  should only be used if the C<Transfer-Encoding> header with a value of
  C<chunked> was sent in the request.  Note, writing zero-length data is
  a no-op.  Use the write_chunk_eof() method to signal end of entity
  body data.
  
  Returns true if successful.
  
  =item $s->format_chunk_eof( %trailers )
  
  Returns the string to be written for signaling EOF when a
  C<Transfer-Encoding> of C<chunked> is used.
  
  =item $s->write_chunk_eof( %trailers )
  
  Will write eof marker for chunked data and optional trailers.  Note
  that trailers should not really be used unless is was signaled
  with a C<Trailer> header.
  
  Returns true if successful.
  
  =item ($code, $mess, %headers) = $s->read_response_headers( %opts )
  
  Read response headers from server and return it.  The $code is the 3
  digit HTTP status code (see L<HTTP::Status>) and $mess is the textual
  message that came with it.  Headers are then returned as key/value
  pairs.  Since key letter casing is not normalized and the same key can
  even occur multiple times, assigning these values directly to a hash
  is not wise.  Only the $code is returned if this method is called in
  scalar context.
  
  As a side effect this method updates the 'peer_http_version'
  attribute.
  
  Options might be passed in as key/value pairs.  There are currently
  only two options supported; C<laxed> and C<junk_out>.
  
  The C<laxed> option will make read_response_headers() more forgiving
  towards servers that have not learned how to speak HTTP properly.  The
  C<laxed> option is a boolean flag, and is enabled by passing in a TRUE
  value.  The C<junk_out> option can be used to capture bad header lines
  when C<laxed> is enabled.  The value should be an array reference.
  Bad header lines will be pushed onto the array.
  
  The C<laxed> option must be specified in order to communicate with
  pre-HTTP/1.0 servers that don't describe the response outcome or the
  data they send back with a header block.  For these servers
  peer_http_version is set to "0.9" and this method returns (200,
  "Assumed OK").
  
  The method will raise an exception (die) if the server does not speak
  proper HTTP or if the C<max_line_length> or C<max_header_length>
  limits are reached.  If the C<laxed> option is turned on and
  C<max_line_length> and C<max_header_length> checks are turned off,
  then no exception will be raised and this method will always
  return a response code.
  
  =item $n = $s->read_entity_body($buf, $size);
  
  Reads chunks of the entity body content.  Basically the same interface
  as for read() and sysread(), but the buffer offset argument is not
  supported yet.  This method should only be called after a successful
  read_response_headers() call.
  
  The return value will be C<undef> on read errors, 0 on EOF, -1 if no data
  could be returned this time, otherwise the number of bytes assigned
  to $buf.  The $buf is set to "" when the return value is -1.
  
  You normally want to retry this call if this function returns either
  -1 or C<undef> with C<$!> as EINTR or EAGAIN (see L<Errno>).  EINTR
  can happen if the application catches signals and EAGAIN can happen if
  you made the socket non-blocking.
  
  This method will raise exceptions (die) if the server does not speak
  proper HTTP.  This can only happen when reading chunked data.
  
  =item %headers = $s->get_trailers
  
  After read_entity_body() has returned 0 to indicate end of the entity
  body, you might call this method to pick up any trailers.
  
  =item $s->_rbuf
  
  Get/set the read buffer content.  The read_response_headers() and
  read_entity_body() methods use an internal buffer which they will look
  for data before they actually sysread more from the socket itself.  If
  they read too much, the remaining data will be left in this buffer.
  
  =item $s->_rbuf_length
  
  Returns the number of bytes in the read buffer.  This should always be
  the same as:
  
      length($s->_rbuf)
  
  but might be more efficient.
  
  =back
  
  =head1 SUBCLASSING
  
  The read_response_headers() and read_entity_body() will invoke the
  sysread() method when they need more data.  Subclasses might want to
  override this method to control how reading takes place.
  
  The object itself is a glob.  Subclasses should avoid using hash key
  names prefixed with C<http_> and C<io_>.
  
  =head1 SEE ALSO
  
  L<LWP>, L<IO::Socket::INET>, L<Net::HTTP::NB>
  
  =head1 COPYRIGHT
  
  Copyright 2001-2003 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
NET_HTTP

$fatpacked{"Net/HTTP/Methods.pm"} = <<'NET_HTTP_METHODS';
  package Net::HTTP::Methods;
  
  require 5.005;  # 4-arg substr
  
  use strict;
  use vars qw($VERSION);
  
  $VERSION = "5.834";
  
  my $CRLF = "\015\012";   # "\r\n" is not portable
  
  *_bytes = defined(&utf8::downgrade) ?
      sub {
          unless (utf8::downgrade($_[0], 1)) {
              require Carp;
              Carp::croak("Wide character in HTTP request (bytes required)");
          }
          return $_[0];
      }
      :
      sub {
          return $_[0];
      };
  
  
  sub new {
      my $class = shift;
      unshift(@_, "Host") if @_ == 1;
      my %cnf = @_;
      require Symbol;
      my $self = bless Symbol::gensym(), $class;
      return $self->http_configure(\%cnf);
  }
  
  sub http_configure {
      my($self, $cnf) = @_;
  
      die "Listen option not allowed" if $cnf->{Listen};
      my $explict_host = (exists $cnf->{Host});
      my $host = delete $cnf->{Host};
      my $peer = $cnf->{PeerAddr} || $cnf->{PeerHost};
      if (!$peer) {
  	die "No Host option provided" unless $host;
  	$cnf->{PeerAddr} = $peer = $host;
      }
  
      if ($peer =~ s,:(\d+)$,,) {
  	$cnf->{PeerPort} = int($1);  # always override
      }
      if (!$cnf->{PeerPort}) {
  	$cnf->{PeerPort} = $self->http_default_port;
      }
  
      if (!$explict_host) {
  	$host = $peer;
  	$host =~ s/:.*//;
      }
      if ($host && $host !~ /:/) {
  	my $p = $cnf->{PeerPort};
  	$host .= ":$p" if $p != $self->http_default_port;
      }
  
      $cnf->{Proto} = 'tcp';
  
      my $keep_alive = delete $cnf->{KeepAlive};
      my $http_version = delete $cnf->{HTTPVersion};
      $http_version = "1.1" unless defined $http_version;
      my $peer_http_version = delete $cnf->{PeerHTTPVersion};
      $peer_http_version = "1.0" unless defined $peer_http_version;
      my $send_te = delete $cnf->{SendTE};
      my $max_line_length = delete $cnf->{MaxLineLength};
      $max_line_length = 8*1024 unless defined $max_line_length;
      my $max_header_lines = delete $cnf->{MaxHeaderLines};
      $max_header_lines = 128 unless defined $max_header_lines;
  
      return undef unless $self->http_connect($cnf);
  
      $self->host($host);
      $self->keep_alive($keep_alive);
      $self->send_te($send_te);
      $self->http_version($http_version);
      $self->peer_http_version($peer_http_version);
      $self->max_line_length($max_line_length);
      $self->max_header_lines($max_header_lines);
  
      ${*$self}{'http_buf'} = "";
  
      return $self;
  }
  
  sub http_default_port {
      80;
  }
  
  # set up property accessors
  for my $method (qw(host keep_alive send_te max_line_length max_header_lines peer_http_version)) {
      my $prop_name = "http_" . $method;
      no strict 'refs';
      *$method = sub {
  	my $self = shift;
  	my $old = ${*$self}{$prop_name};
  	${*$self}{$prop_name} = shift if @_;
  	return $old;
      };
  }
  
  # we want this one to be a bit smarter
  sub http_version {
      my $self = shift;
      my $old = ${*$self}{'http_version'};
      if (@_) {
  	my $v = shift;
  	$v = "1.0" if $v eq "1";  # float
  	unless ($v eq "1.0" or $v eq "1.1") {
  	    require Carp;
  	    Carp::croak("Unsupported HTTP version '$v'");
  	}
  	${*$self}{'http_version'} = $v;
      }
      $old;
  }
  
  sub format_request {
      my $self = shift;
      my $method = shift;
      my $uri = shift;
  
      my $content = (@_ % 2) ? pop : "";
  
      for ($method, $uri) {
  	require Carp;
  	Carp::croak("Bad method or uri") if /\s/ || !length;
      }
  
      push(@{${*$self}{'http_request_method'}}, $method);
      my $ver = ${*$self}{'http_version'};
      my $peer_ver = ${*$self}{'http_peer_http_version'} || "1.0";
  
      my @h;
      my @connection;
      my %given = (host => 0, "content-length" => 0, "te" => 0);
      while (@_) {
  	my($k, $v) = splice(@_, 0, 2);
  	my $lc_k = lc($k);
  	if ($lc_k eq "connection") {
  	    $v =~ s/^\s+//;
  	    $v =~ s/\s+$//;
  	    push(@connection, split(/\s*,\s*/, $v));
  	    next;
  	}
  	if (exists $given{$lc_k}) {
  	    $given{$lc_k}++;
  	}
  	push(@h, "$k: $v");
      }
  
      if (length($content) && !$given{'content-length'}) {
  	push(@h, "Content-Length: " . length($content));
      }
  
      my @h2;
      if ($given{te}) {
  	push(@connection, "TE") unless grep lc($_) eq "te", @connection;
      }
      elsif ($self->send_te && gunzip_ok()) {
  	# gzip is less wanted since the IO::Uncompress::Gunzip interface for
  	# it does not really allow chunked decoding to take place easily.
  	push(@h2, "TE: deflate,gzip;q=0.3");
  	push(@connection, "TE");
      }
  
      unless (grep lc($_) eq "close", @connection) {
  	if ($self->keep_alive) {
  	    if ($peer_ver eq "1.0") {
  		# from looking at Netscape's headers
  		push(@h2, "Keep-Alive: 300");
  		unshift(@connection, "Keep-Alive");
  	    }
  	}
  	else {
  	    push(@connection, "close") if $ver ge "1.1";
  	}
      }
      push(@h2, "Connection: " . join(", ", @connection)) if @connection;
      unless ($given{host}) {
  	my $h = ${*$self}{'http_host'};
  	push(@h2, "Host: $h") if $h;
      }
  
      return _bytes(join($CRLF, "$method $uri HTTP/$ver", @h2, @h, "", $content));
  }
  
  
  sub write_request {
      my $self = shift;
      $self->print($self->format_request(@_));
  }
  
  sub format_chunk {
      my $self = shift;
      return $_[0] unless defined($_[0]) && length($_[0]);
      return _bytes(sprintf("%x", length($_[0])) . $CRLF . $_[0] . $CRLF);
  }
  
  sub write_chunk {
      my $self = shift;
      return 1 unless defined($_[0]) && length($_[0]);
      $self->print(_bytes(sprintf("%x", length($_[0])) . $CRLF . $_[0] . $CRLF));
  }
  
  sub format_chunk_eof {
      my $self = shift;
      my @h;
      while (@_) {
  	push(@h, sprintf "%s: %s$CRLF", splice(@_, 0, 2));
      }
      return _bytes(join("", "0$CRLF", @h, $CRLF));
  }
  
  sub write_chunk_eof {
      my $self = shift;
      $self->print($self->format_chunk_eof(@_));
  }
  
  
  sub my_read {
      die if @_ > 3;
      my $self = shift;
      my $len = $_[1];
      for (${*$self}{'http_buf'}) {
  	if (length) {
  	    $_[0] = substr($_, 0, $len, "");
  	    return length($_[0]);
  	}
  	else {
  	    return $self->sysread($_[0], $len);
  	}
      }
  }
  
  
  sub my_readline {
      my $self = shift;
      my $what = shift;
      for (${*$self}{'http_buf'}) {
  	my $max_line_length = ${*$self}{'http_max_line_length'};
  	my $pos;
  	while (1) {
  	    # find line ending
  	    $pos = index($_, "\012");
  	    last if $pos >= 0;
  	    die "$what line too long (limit is $max_line_length)"
  		if $max_line_length && length($_) > $max_line_length;
  
  	    # need to read more data to find a line ending
            READ:
              {
                  my $n = $self->sysread($_, 1024, length);
                  unless (defined $n) {
                      redo READ if $!{EINTR};
                      if ($!{EAGAIN}) {
                          # Hmm, we must be reading from a non-blocking socket
                          # XXX Should really wait until this socket is readable,...
                          select(undef, undef, undef, 0.1);  # but this will do for now
                          redo READ;
                      }
                      # if we have already accumulated some data let's at least
                      # return that as a line
                      die "$what read failed: $!" unless length;
                  }
                  unless ($n) {
                      return undef unless length;
                      return substr($_, 0, length, "");
                  }
              }
  	}
  	die "$what line too long ($pos; limit is $max_line_length)"
  	    if $max_line_length && $pos > $max_line_length;
  
  	my $line = substr($_, 0, $pos+1, "");
  	$line =~ s/(\015?\012)\z// || die "Assert";
  	return wantarray ? ($line, $1) : $line;
      }
  }
  
  
  sub _rbuf {
      my $self = shift;
      if (@_) {
  	for (${*$self}{'http_buf'}) {
  	    my $old;
  	    $old = $_ if defined wantarray;
  	    $_ = shift;
  	    return $old;
  	}
      }
      else {
  	return ${*$self}{'http_buf'};
      }
  }
  
  sub _rbuf_length {
      my $self = shift;
      return length ${*$self}{'http_buf'};
  }
  
  
  sub _read_header_lines {
      my $self = shift;
      my $junk_out = shift;
  
      my @headers;
      my $line_count = 0;
      my $max_header_lines = ${*$self}{'http_max_header_lines'};
      while (my $line = my_readline($self, 'Header')) {
  	if ($line =~ /^(\S+?)\s*:\s*(.*)/s) {
  	    push(@headers, $1, $2);
  	}
  	elsif (@headers && $line =~ s/^\s+//) {
  	    $headers[-1] .= " " . $line;
  	}
  	elsif ($junk_out) {
  	    push(@$junk_out, $line);
  	}
  	else {
  	    die "Bad header: '$line'\n";
  	}
  	if ($max_header_lines) {
  	    $line_count++;
  	    if ($line_count >= $max_header_lines) {
  		die "Too many header lines (limit is $max_header_lines)";
  	    }
  	}
      }
      return @headers;
  }
  
  
  sub read_response_headers {
      my($self, %opt) = @_;
      my $laxed = $opt{laxed};
  
      my($status, $eol) = my_readline($self, 'Status');
      unless (defined $status) {
  	die "Server closed connection without sending any data back";
      }
  
      my($peer_ver, $code, $message) = split(/\s+/, $status, 3);
      if (!$peer_ver || $peer_ver !~ s,^HTTP/,, || $code !~ /^[1-5]\d\d$/) {
  	die "Bad response status line: '$status'" unless $laxed;
  	# assume HTTP/0.9
  	${*$self}{'http_peer_http_version'} = "0.9";
  	${*$self}{'http_status'} = "200";
  	substr(${*$self}{'http_buf'}, 0, 0) = $status . ($eol || "");
  	return 200 unless wantarray;
  	return (200, "Assumed OK");
      };
  
      ${*$self}{'http_peer_http_version'} = $peer_ver;
      ${*$self}{'http_status'} = $code;
  
      my $junk_out;
      if ($laxed) {
  	$junk_out = $opt{junk_out} || [];
      }
      my @headers = $self->_read_header_lines($junk_out);
  
      # pick out headers that read_entity_body might need
      my @te;
      my $content_length;
      for (my $i = 0; $i < @headers; $i += 2) {
  	my $h = lc($headers[$i]);
  	if ($h eq 'transfer-encoding') {
  	    my $te = $headers[$i+1];
  	    $te =~ s/^\s+//;
  	    $te =~ s/\s+$//;
  	    push(@te, $te) if length($te);
  	}
  	elsif ($h eq 'content-length') {
  	    # ignore bogus and overflow values
  	    if ($headers[$i+1] =~ /^\s*(\d{1,15})(?:\s|$)/) {
  		$content_length = $1;
  	    }
  	}
      }
      ${*$self}{'http_te'} = join(",", @te);
      ${*$self}{'http_content_length'} = $content_length;
      ${*$self}{'http_first_body'}++;
      delete ${*$self}{'http_trailers'};
      return $code unless wantarray;
      return ($code, $message, @headers);
  }
  
  
  sub read_entity_body {
      my $self = shift;
      my $buf_ref = \$_[0];
      my $size = $_[1];
      die "Offset not supported yet" if $_[2];
  
      my $chunked;
      my $bytes;
  
      if (${*$self}{'http_first_body'}) {
  	${*$self}{'http_first_body'} = 0;
  	delete ${*$self}{'http_chunked'};
  	delete ${*$self}{'http_bytes'};
  	my $method = shift(@{${*$self}{'http_request_method'}});
  	my $status = ${*$self}{'http_status'};
  	if ($method eq "HEAD") {
  	    # this response is always empty regardless of other headers
  	    $bytes = 0;
  	}
  	elsif (my $te = ${*$self}{'http_te'}) {
  	    my @te = split(/\s*,\s*/, lc($te));
  	    die "Chunked must be last Transfer-Encoding '$te'"
  		unless pop(@te) eq "chunked";
  
  	    for (@te) {
  		if ($_ eq "deflate" && inflate_ok()) {
  		    #require Compress::Raw::Zlib;
  		    my ($i, $status) = Compress::Raw::Zlib::Inflate->new();
  		    die "Can't make inflator: $status" unless $i;
  		    $_ = sub { my $out; $i->inflate($_[0], \$out); $out }
  		}
  		elsif ($_ eq "gzip" && gunzip_ok()) {
  		    #require IO::Uncompress::Gunzip;
  		    my @buf;
  		    $_ = sub {
  			push(@buf, $_[0]);
  			return "" unless $_[1];
  			my $input = join("", @buf);
  			my $output;
  			IO::Uncompress::Gunzip::gunzip(\$input, \$output, Transparent => 0)
  			    or die "Can't gunzip content: $IO::Uncompress::Gunzip::GunzipError";
  			return \$output;
  		    };
  		}
  		elsif ($_ eq "identity") {
  		    $_ = sub { $_[0] };
  		}
  		else {
  		    die "Can't handle transfer encoding '$te'";
  		}
  	    }
  
  	    @te = reverse(@te);
  
  	    ${*$self}{'http_te2'} = @te ? \@te : "";
  	    $chunked = -1;
  	}
  	elsif (defined(my $content_length = ${*$self}{'http_content_length'})) {
  	    $bytes = $content_length;
  	}
          elsif ($status =~ /^(?:1|[23]04)/) {
              # RFC 2616 says that these responses should always be empty
              # but that does not appear to be true in practice [RT#17907]
              $bytes = 0;
          }
  	else {
  	    # XXX Multi-Part types are self delimiting, but RFC 2616 says we
  	    # only has to deal with 'multipart/byteranges'
  
  	    # Read until EOF
  	}
      }
      else {
  	$chunked = ${*$self}{'http_chunked'};
  	$bytes   = ${*$self}{'http_bytes'};
      }
  
      if (defined $chunked) {
  	# The state encoded in $chunked is:
  	#   $chunked == 0:   read CRLF after chunk, then chunk header
          #   $chunked == -1:  read chunk header
  	#   $chunked > 0:    bytes left in current chunk to read
  
  	if ($chunked <= 0) {
  	    my $line = my_readline($self, 'Entity body');
  	    if ($chunked == 0) {
  		die "Missing newline after chunk data: '$line'"
  		    if !defined($line) || $line ne "";
  		$line = my_readline($self, 'Entity body');
  	    }
  	    die "EOF when chunk header expected" unless defined($line);
  	    my $chunk_len = $line;
  	    $chunk_len =~ s/;.*//;  # ignore potential chunk parameters
  	    unless ($chunk_len =~ /^([\da-fA-F]+)\s*$/) {
  		die "Bad chunk-size in HTTP response: $line";
  	    }
  	    $chunked = hex($1);
  	    if ($chunked == 0) {
  		${*$self}{'http_trailers'} = [$self->_read_header_lines];
  		$$buf_ref = "";
  
  		my $n = 0;
  		if (my $transforms = delete ${*$self}{'http_te2'}) {
  		    for (@$transforms) {
  			$$buf_ref = &$_($$buf_ref, 1);
  		    }
  		    $n = length($$buf_ref);
  		}
  
  		# in case somebody tries to read more, make sure we continue
  		# to return EOF
  		delete ${*$self}{'http_chunked'};
  		${*$self}{'http_bytes'} = 0;
  
  		return $n;
  	    }
  	}
  
  	my $n = $chunked;
  	$n = $size if $size && $size < $n;
  	$n = my_read($self, $$buf_ref, $n);
  	return undef unless defined $n;
  
  	${*$self}{'http_chunked'} = $chunked - $n;
  
  	if ($n > 0) {
  	    if (my $transforms = ${*$self}{'http_te2'}) {
  		for (@$transforms) {
  		    $$buf_ref = &$_($$buf_ref, 0);
  		}
  		$n = length($$buf_ref);
  		$n = -1 if $n == 0;
  	    }
  	}
  	return $n;
      }
      elsif (defined $bytes) {
  	unless ($bytes) {
  	    $$buf_ref = "";
  	    return 0;
  	}
  	my $n = $bytes;
  	$n = $size if $size && $size < $n;
  	$n = my_read($self, $$buf_ref, $n);
  	return undef unless defined $n;
  	${*$self}{'http_bytes'} = $bytes - $n;
  	return $n;
      }
      else {
  	# read until eof
  	$size ||= 8*1024;
  	return my_read($self, $$buf_ref, $size);
      }
  }
  
  sub get_trailers {
      my $self = shift;
      @{${*$self}{'http_trailers'} || []};
  }
  
  BEGIN {
  my $gunzip_ok;
  my $inflate_ok;
  
  sub gunzip_ok {
      return $gunzip_ok if defined $gunzip_ok;
  
      # Try to load IO::Uncompress::Gunzip.
      local $@;
      local $SIG{__DIE__};
      $gunzip_ok = 0;
  
      eval {
  	require IO::Uncompress::Gunzip;
  	$gunzip_ok++;
      };
  
      return $gunzip_ok;
  }
  
  sub inflate_ok {
      return $inflate_ok if defined $inflate_ok;
  
      # Try to load Compress::Raw::Zlib.
      local $@;
      local $SIG{__DIE__};
      $inflate_ok = 0;
  
      eval {
  	require Compress::Raw::Zlib;
  	$inflate_ok++;
      };
  
      return $inflate_ok;
  }
  
  } # BEGIN
  
  1;
NET_HTTP_METHODS

$fatpacked{"Net/HTTP/NB.pm"} = <<'NET_HTTP_NB';
  package Net::HTTP::NB;
  
  use strict;
  use vars qw($VERSION @ISA);
  
  $VERSION = "5.810";
  
  require Net::HTTP;
  @ISA=qw(Net::HTTP);
  
  sub sysread {
      my $self = $_[0];
      if (${*$self}{'httpnb_read_count'}++) {
  	${*$self}{'http_buf'} = ${*$self}{'httpnb_save'};
  	die "Multi-read\n";
      }
      my $buf;
      my $offset = $_[3] || 0;
      my $n = sysread($self, $_[1], $_[2], $offset);
      ${*$self}{'httpnb_save'} .= substr($_[1], $offset);
      return $n;
  }
  
  sub read_response_headers {
      my $self = shift;
      ${*$self}{'httpnb_read_count'} = 0;
      ${*$self}{'httpnb_save'} = ${*$self}{'http_buf'};
      my @h = eval { $self->SUPER::read_response_headers(@_) };
      if ($@) {
  	return if $@ eq "Multi-read\n";
  	die;
      }
      return @h;
  }
  
  sub read_entity_body {
      my $self = shift;
      ${*$self}{'httpnb_read_count'} = 0;
      ${*$self}{'httpnb_save'} = ${*$self}{'http_buf'};
      # XXX I'm not so sure this does the correct thing in case of
      # transfer-encoding tranforms
      my $n = eval { $self->SUPER::read_entity_body(@_); };
      if ($@) {
  	$_[0] = "";
  	return -1;
      }
      return $n;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Net::HTTP::NB - Non-blocking HTTP client
  
  =head1 SYNOPSIS
  
   use Net::HTTP::NB;
   my $s = Net::HTTP::NB->new(Host => "www.perl.com") || die $@;
   $s->write_request(GET => "/");
  
   use IO::Select;
   my $sel = IO::Select->new($s);
  
   READ_HEADER: {
      die "Header timeout" unless $sel->can_read(10);
      my($code, $mess, %h) = $s->read_response_headers;
      redo READ_HEADER unless $code;
   }
  
   while (1) {
      die "Body timeout" unless $sel->can_read(10);
      my $buf;
      my $n = $s->read_entity_body($buf, 1024);
      last unless $n;
      print $buf;
   }
  
  =head1 DESCRIPTION
  
  Same interface as C<Net::HTTP> but it will never try multiple reads
  when the read_response_headers() or read_entity_body() methods are
  invoked.  This make it possible to multiplex multiple Net::HTTP::NB
  using select without risk blocking.
  
  If read_response_headers() did not see enough data to complete the
  headers an empty list is returned.
  
  If read_entity_body() did not see new entity data in its read
  the value -1 is returned.
  
  =head1 SEE ALSO
  
  L<Net::HTTP>
  
  =head1 COPYRIGHT
  
  Copyright 2001 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
NET_HTTP_NB

$fatpacked{"Net/HTTPS.pm"} = <<'NET_HTTPS';
  package Net::HTTPS;
  
  use strict;
  use vars qw($VERSION $SSL_SOCKET_CLASS @ISA);
  
  $VERSION = "5.819";
  
  # Figure out which SSL implementation to use
  if ($SSL_SOCKET_CLASS) {
      # somebody already set it
  }
  elsif ($Net::SSL::VERSION) {
      $SSL_SOCKET_CLASS = "Net::SSL";
  }
  elsif ($IO::Socket::SSL::VERSION) {
      $SSL_SOCKET_CLASS = "IO::Socket::SSL"; # it was already loaded
  }
  else {
      eval { require Net::SSL; };     # from Crypt-SSLeay
      if ($@) {
  	my $old_errsv = $@;
  	eval {
  	    require IO::Socket::SSL;
  	};
  	if ($@) {
  	    $old_errsv =~ s/\s\(\@INC contains:.*\)/)/g;
  	    die $old_errsv . $@;
  	}
  	$SSL_SOCKET_CLASS = "IO::Socket::SSL";
      }
      else {
  	$SSL_SOCKET_CLASS = "Net::SSL";
      }
  }
  
  require Net::HTTP::Methods;
  
  @ISA=($SSL_SOCKET_CLASS, 'Net::HTTP::Methods');
  
  sub configure {
      my($self, $cnf) = @_;
      $self->http_configure($cnf);
  }
  
  sub http_connect {
      my($self, $cnf) = @_;
      $self->SUPER::configure($cnf);
  }
  
  sub http_default_port {
      443;
  }
  
  # The underlying SSLeay classes fails to work if the socket is
  # placed in non-blocking mode.  This override of the blocking
  # method makes sure it stays the way it was created.
  sub blocking { }  # noop
  
  1;
NET_HTTPS

$fatpacked{"Plack.pm"} = <<'PLACK';
  package Plack;
  
  use strict;
  use warnings;
  use 5.008_001;
  our $VERSION = '0.9938';
  $VERSION = eval $VERSION;
  
  1;
  __END__
  
  =head1 NAME
  
  Plack - Perl Superglue for Web frameworks and Web Servers (PSGI toolkit)
  
  =head1 DESCRIPTION
  
  Plack is a set of tools for using PSGI stack. It contains middleware
  components, a reference server and utilities for Web application
  frameworks. Plack is like Ruby's Rack or Python's Paste for WSGI.
  
  See L<PSGI> for the PSGI specification and L<PSGI::FAQ> to know what
  PSGI and Plack are and why we need them.
  
  =head1 MODULES AND UTILITIES
  
  =head2 Plack::Handler
  
  L<Plack::Handler> and its subclasses contains adapters for web
  servers. We have adapters for the built-in standalone web server
  L<HTTP::Server::PSGI>, L<CGI|Plack::Handler::CGI>,
  L<FCGI|Plack::Handler::FCGI>, L<Apache1|Plack::Handler::Apache1>,
  L<Apache2|Plack::Handler::Apache2>,
  L<Net::FastCGI|Plack::Handler::Net::FastCGI> and
  L<HTTP::Server::Simple|Plack::Handler::HTTP::Server::Simple> included
  in the core Plack distribution.
  
  There are also many HTTP server implementations on CPAN that has Plack
  handlers.
  
  See L<Plack::Handler> how to write your own adapters.
  
  =head2 Plack::Loader
  
  L<Plack::Loader> is a loader to load one of L<Plack::Handler> adapters
  and run PSGI application code reference with it.
  
  =head2 Plack::Util
  
  L<Plack::Util> contains a lot of utility functions for server
  implementors as well as middleware authors.
  
  =head2 .psgi files
  
  PSGI application is a code reference but it's not easy to pass code
  reference in the command line or configuration files, so Plack uses a
  convention that you need a file named C<app.psgi> or alike, which
  would be loaded (via perl's core function C<do>) to return the PSGI
  application code reference.
  
    # Hello.psgi
    my $app = sub {
        my $env = shift;
        # ...
        return [ $status, $headers, $body ];
    };
  
  If you use a web framework, chances are that they provide a helper
  utility to automatically generate these C<.psgi> files for you, such
  as:
  
    # MyApp.psgi
    use MyApp;
    my $app = sub { MyApp->run_psgi(@_) };
  
  It's important that the return value of C<.psgi> file is the code
  reference. See eg/dot-psgi directory for more examples of C<.psgi>
  files.
  
  =head2 plackup, Plack::Runner
  
  L<plackup> is a command line launcher to run PSGI applications from
  command line using L<Plack::Loader> to load PSGI backends. It can be
  used to run standalone servers and FastCGI daemon processes. Other
  server backends like Apache2 needs a separate configuration but
  C<.psgi> application file can still be the same.
  
  If you want to write your own frontend that replaces, or adds
  functionalities to L<plackup>, take a look at L<Plack::Runner> module.
  
  =head2 Plack::Middleware
  
  PSGI middleware is a PSGI application that wraps existent PSGI
  application and plays both side of application and servers. From the
  servers the wrapped code reference still looks like and behaves
  exactly the same as PSGI applications.
  
  L<Plack::Middleware> gives you an easy way to wrap PSGI applications
  with a clean API, and compatibility with L<Plack::Builder> DSL.
  
  =head2 Plack::Builder
  
  L<Plack::Builder> gives you a DSL that you can enable Middleware in
  C<.psgi> files to wrap existent PSGI applications.
  
  =head2 Plack::Request, Plack::Response
  
  L<Plack::Request> gives you a nice wrapper API around PSGI C<$env>
  hash to get headers, cookies and query parameters much like
  L<Apache::Request> in mod_perl.
  
  L<Plack::Response> does the same to construct the response array
  reference.
  
  =head2 Plack::Test
  
  L<Plack::Test> is an unified interface to test your PSGI application
  using standard L<HTTP::Request> and L<HTTP::Response> pair with simple
  callbacks.
  
  =head2 Plack::Test::Suite
  
  L<Plack::Test::Suite> is a test suite to test a new PSGI server backend.
  
  =head1 CONTRIBUTING
  
  =head2 Patches and Bug Fixes
  
  Small patches and bug fixes can be either submitted via nopaste on IRC
  L<irc://irc.perl.org/#plack> or L<the github issue
  tracker|http://github.com/miyagawa/Plack/issues>.  Forking on
  L<github|http://github.com/miyagawa/Plack> is another good way if you
  intend to make larger fixes.
  
  See also L<http://contributing.appspot.com/plack> when you think this
  document is terribly outdated.
  
  =head2 Module Namespaces
  
  Modules added to the Plack:: sub-namespaces should be reasonably generic
  components which are useful as building blocks and not just simply using
  Plack.
  
  Middleware authors are free to use the Plack::Middleware:: namespace for
  their middleware components. Middleware must be written in the pipeline
  style such that they can chained together with other middleware components.
  The Plack::Middleware:: modules in the core distribution are good examples
  of such modules. It is recommended that you inherit from L<Plack::Middleware>
  for these types of modules.
  
  Not all middleware components are wrappers, but instead are more like
  endpoints in a middleware chain. These types of components should use the
  Plack::App:: namespace. Again, look in the core modules to see excellent
  examples of these (L<Plack::App::File>, L<Plack::App::Directory>, etc.).
  It is recommended that you inherit from L<Plack::Component> for these
  types of modules.
  
  B<DO NOT USE> Plack:: namespace to build a new web application or a
  framework. It's like naming your application under CGI:: namespace if
  it's supposed to run on CGI and that is a really bad choice and
  confuse people.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 COPYRIGHT
  
  The following copyright notice applies to all the files provided in
  this distribution, including binary files, unless explicitly noted
  otherwise.
  
  Copyright 2009-2010 Tatsuhiko Miyagawa
  
  =head1 CONTRIBUTORS
  
  Yuval Kogman (nothingmuch)
  
  Tokuhiro Matsuno (tokuhirom)
  
  Kazuhiro Osawa (Yappo)
  
  Kazuho Oku
  
  Florian Ragwitz (rafl)
  
  Chia-liang Kao (clkao)
  
  Masahiro Honma (hiratara)
  
  Daisuke Murase (typester)
  
  John Beppu
  
  Matt S Trout (mst)
  
  Shawn M Moore (Sartak)
  
  Stevan Little
  
  Hans Dieter Pearcey (confound)
  
  Tomas Doran (t0m)
  
  mala
  
  Mark Stosberg
  
  Aaron Trevena
  
  =head1 SEE ALSO
  
  L<PSGI> L<http://plackperl.org/>
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
PLACK

$fatpacked{"Plack/App/CGIBin.pm"} = <<'PLACK_APP_CGIBIN';
  package Plack::App::CGIBin;
  use strict;
  use warnings;
  use parent qw/Plack::App::File/;
  use Plack::App::WrapCGI;
  
  sub allow_path_info { 1 }
  
  sub serve_path {
      my($self, $env, $file) = @_;
  
      my $app = $self->{_compiled}->{$file} ||= Plack::App::WrapCGI->new(script => $file);
      $app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::CGIBin - cgi-bin replacement for Plack servers
  
  =head1 SYNOPSIS
  
    use Plack::App::CGIBin;
    use Plack::Builder;
  
    my $app = Plack::App::CGIBin->new(root => "/path/to/cgi-bin")->to_app;
    builder {
        mount "/cgi-bin" => $app;
    };
  
    # Or from the command line
    plackup -MPlack::App::CGIBin -e 'Plack::App::CGIBin->new(root => "/path/to/cgi-bin")->to_app'
  
  =head1 DESCRIPTION
  
  Plack::App::CGIBin allows you to load CGI scripts from a directory and
  convert them into a (persistent) PSGI application. This application
  uses L<CGI::Compile> to compile a cgi script into a sub (like
  L<ModPerl::Registry>) and then run it using L<CGI::Emulate::PSGI>.
  
  This would give you the extreme easiness when you have bunch of old
  CGI scripts that is loaded using I<cgi-bin> of Apache web server.
  
  This module does not (yet) stat files nor recompile files on every
  request for the interest of performance. You need to restart the
  server process to reflect the changes to the CGI scripts.
  
  See also L<Plack::App::WrapCGI> if you compile one CGI script into a
  PSGI application without serving CGI scripts from a directory, to
  remove overhead of filesystem lookups, etc.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::App::File> L<CGI::Emulate::PSGI> L<CGI::Compile> L<Plack::App::WrapCGI>
  
  =cut
PLACK_APP_CGIBIN

$fatpacked{"Plack/App/Cascade.pm"} = <<'PLACK_APP_CASCADE';
  package Plack::App::Cascade;
  use strict;
  use base qw(Plack::Component);
  
  use Plack::Util;
  use Plack::Util::Accessor qw(apps catch codes);
  
  sub add {
      my $self = shift;
      $self->apps([]) unless $self->apps;
      push @{$self->apps}, @_;
  }
  
  sub prepare_app {
      my $self = shift;
      my %codes = map { $_ => 1 } @{ $self->catch || [ 404 ] };
      $self->codes(\%codes);
  }
  
  sub call {
      my($self, $env) = @_;
  
      return sub {
          my $respond = shift;
  
          my $res = [ 404, [ 'Content-Type' => 'text/html' ], [ '404 Not Found' ] ];
  
          my $done;
          my $respond_wrapper = sub {
              my $res = shift;
              if ($self->codes->{$res->[0]}) {
                  return Plack::Util::inline_object
                      write => sub { }, close => sub { };
              } else {
                  $done = 1;
                  return $respond->($res);
              }
          };
  
          for my $app (@{$self->apps || []}) {
              $res = $app->($env);
              if (ref $res eq 'CODE') {
                  $res->($respond_wrapper);
              } else {
                  $respond_wrapper->($res);
              }
              return if $done;
          }
  
          $respond->($res);
      };
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::Cascade - Cascadable compound application
  
  =head1 SYNOPSIS
  
    use Plack::App::Cascade;
    use Plack::App::URLMap;
    use Plack::App::File;
  
    # Serve static files from multiple search paths
    my $cascade = Plack::App::Cascade->new;
    $cascade->add( Plack::App::File->new(root => "/www/example.com/foo")->to_app );
    $cascade->add( Plack::App::File->new(root => "/www/example.com/bar")->to_app );
  
    my $app = Plack::App::URLMap->new;
    $app->map("/static", $cascade);
    $app->to_app;
  
  =head1 DESCRIPTION
  
  Plack::App::Cascade is a Plack middleware component that compounds
  several apps and tries them to return the first response that is not
  404.
  
  =head1 METHODS
  
  =over 4
  
  =item new
  
    $app = Plack::App::Cascade->new(apps => [ $app1, $app2 ]);
  
  Creates a new Cascade application.
  
  =item add
  
    $app->add($app1);
    $app->add($app2, $app3);
  
  Appends a new application to the list of apps to try. You can pass the
  multiple apps to the one C<add> call.
  
  =item catch
  
    $app->catch([ 403, 404 ]);
  
  Sets which error codes to catch and process onwards. Defaults to C<404>.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::App::URLMap> Rack::Cascade
  
  =cut
PLACK_APP_CASCADE

$fatpacked{"Plack/App/Directory.pm"} = <<'PLACK_APP_DIRECTORY';
  package Plack::App::Directory;
  use parent qw(Plack::App::File);
  use strict;
  use warnings;
  use Plack::Util;
  use HTTP::Date;
  use Plack::MIME;
  use DirHandle;
  
  # Stolen from rack/directory.rb
  my $dir_file = "<tr><td class='name'><a href='%s'>%s</a></td><td class='size'>%s</td><td class='type'>%s</td><td class='mtime'>%s</td></tr>";
  my $dir_page = <<PAGE;
  <html><head>
    <title>%s</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <style type='text/css'>
  table { width:100%%; }
  .name { text-align:left; }
  .size, .mtime { text-align:right; }
  .type { width:11em; }
  .mtime { width:15em; }
    </style>
  </head><body>
  <h1>%s</h1>
  <hr />
  <table>
    <tr>
      <th class='name'>Name</th>
      <th class='size'>Size</th>
      <th class='type'>Type</th>
      <th class='mtime'>Last Modified</th>
    </tr>
  %s
  </table>
  <hr />
  </body></html>
  PAGE
  
  sub should_handle {
      my($self, $file) = @_;
      return -d $file || -f $file;
  }
  
  sub serve_path {
      my($self, $env, $dir, $fullpath) = @_;
  
      if (-f $dir) {
          return $self->SUPER::serve_path($env, $dir, $fullpath);
      }
  
      my @files = ([ "../", "Parent Directory", '', '', '' ]);
  
      my $dh = DirHandle->new($dir);
      my @children;
      while (defined(my $ent = $dh->read)) {
          push @children, $ent;
      }
  
      for my $basename (sort { $a cmp $b } @children) {
          my $file = "$dir/$basename";
          my $url = $env->{SCRIPT_NAME} . $env->{PATH_INFO} . $basename;
  
          my $is_dir = -d $file;
          my @stat = stat _;
  
          if ($is_dir) {
              $basename .= "/";
              $url      .= "/";
          }
  
          my $mime_type = $is_dir ? 'directory' : ( Plack::MIME->mime_type($file) || 'text/plain' );
          push @files, [ $url, $basename, $stat[7], $mime_type, HTTP::Date::time2str($stat[9]) ];
      }
  
      my $path  = Plack::Util::encode_html("Index of $env->{PATH_INFO}");
      my $files = join "\n", map {
          my $f = $_;
          sprintf $dir_file, map Plack::Util::encode_html($_), @$f;
      } @files;
      my $page  = sprintf $dir_page, $path, $path, $files;
  
      return [ 200, ['Content-Type' => 'text/html; charset=utf-8'], [ $page ] ];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::Directory - Serve static files from document root with directory index
  
  =head1 SYNOPSIS
  
    # app.psgi
    use Plack::App::Directory;
    my $app = Plack::App::Directory->new({ root => "/path/to/htdocs" })->to_app;
  
  =head1 DESCRIPTION
  
  This is a static file server PSGI application with directory index a la Apache's mod_autoindex.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item root
  
  Document root directory. Defaults to the current directory.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::App::File>
  
  =cut
PLACK_APP_DIRECTORY

$fatpacked{"Plack/App/FCGIDispatcher.pm"} = <<'PLACK_APP_FCGIDISPATCHER';
  package Plack::App::FCGIDispatcher;
  use strict;
  use warnings;
  use parent qw(Plack::Component);
  use Plack::Util::Accessor qw(host port socket);
  
  use FCGI::Client;
  use HTTP::Response;
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my $sock;
      if ($self->socket) {
          require IO::Socket::UNIX;
          $sock = IO::Socket::UNIX->new(
              Peer => $self->socket,
          );
      } elsif ($self->port) {
          require IO::Socket::INET;
          $sock = IO::Socket::INET->new(
              PeerAddr => $self->host || '127.0.0.1',
              PeerPort => $self->port,
          );
      } else {
          die "FCGI daemon host/port or socket is not specified";
      }
  
      $sock or die "Can't create socket to FCGI daemon: $!";
  
      my $conn = FCGI::Client::Connection->new(sock => $sock);
      my $input = delete $env->{'psgi.input'};
  
      my $content_in = '';
      if (my $cl = $env->{CONTENT_LENGTH}) {
          while ($cl > 0) {
              my $read = $input->read($content_in, $cl, length $content_in);
              $cl -= $read;
          }
      }
  
      for my $key (keys %$env) {
          delete $env->{$key} if $key =~ /\./;
      }
  
      my ($stdout, $stderr) = $conn->request(
          $env,
          $content_in,
      );
      print STDERR $stderr if $stderr;
  
      unless ( $stdout =~ /^HTTP/ ) {
          $stdout = "HTTP/1.1 200 OK\015\012" . $stdout;
      }
  
      ($stdout =~ /^(.+?\015?\012\015?\012)(.*)$/s) or die "No header/body separator";
      my ($header_part, $content) = ($1, $2);
  
      my $res = HTTP::Response->parse($header_part);
      if ($res->content) {
          # we passed only headers but has body: Bad headers
          return [ 500, [ 'Content-Type' => 'text/plain' ], [ 'Bad HTTP headers returned' ] ];
      }
  
      my $status = $res->header('Status') || 200;
         $status =~ s/\s+.*$//; # remove ' OK' in '200 OK'
  
      my $headers = [
          map {
              my $k = $_;
              map { ( $k => $_ ) } $res->headers->header($_);
          } $res->headers->header_field_names
      ];
  
      return [ $status, $headers, [ $content ] ];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::FCGIDispatcher - Dispatch requests to FCGI servers
  
  =head1 SYNOPSIS
  
    # app.psgi
    use Plack::App::FCGIDispatcher;
    my $app = Plack::App::FCGIDispatcher->new({
        port => 8080, # FastCGI daemon port
    })->to_app;
  
  =head1 DESCRIPTION
  
  Plack::App::FCGIDispatcher is not really a middleware but it's
  a PSGI application to dispatch requests to external FCGI servers.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item host, port
  
    my $app = Plack::App::FCGIDispatcher->new({
        host => '127.0.0.1', port => 8080,
    })->to_app;
  
  Specifies host and port where FastCGI daemon is listening. host defaults to C<127.0.0.1>.
  
  =item socket
  
    my $app = Plack::App::FCGIDispatcher->new({
        socket => "/tmp/fcgi.sock",
    })->to_app;
  
  Specifies UNIX socket path where FastCGI daemon is listening.
  
  =back
  
  =head1 AUTHOR
  
  Tokuhiro Matsuno
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<FCGI::Client>
  
  =cut
PLACK_APP_FCGIDISPATCHER

$fatpacked{"Plack/App/File.pm"} = <<'PLACK_APP_FILE';
  package Plack::App::File;
  use strict;
  use warnings;
  use parent qw/Plack::Component/;
  use File::Spec::Unix;
  use Cwd ();
  use Plack::Util;
  use Plack::MIME;
  use HTTP::Date;
  
  use Plack::Util::Accessor qw( root file encoding );
  
  sub should_handle {
      my($self, $file) = @_;
      return -f $file;
  }
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my($file, $path_info) = $self->file || $self->locate_file($env);
      return $file if ref $file eq 'ARRAY';
  
      local @{$env}{qw( SCRIPT_NAME PATH_INFO )} = @{$env}{qw( SCRIPT_NAME PATH_INFO )};
  
      if ($path_info) {
          $env->{PATH_INFO}   =~ s/\Q$path_info\E$//;
          $env->{SCRIPT_NAME} = $env->{SCRIPT_NAME} . $env->{PATH_INFO};
          $env->{PATH_INFO}   = $path_info;
      } else {
          $env->{SCRIPT_NAME} = $env->{SCRIPT_NAME} . $env->{PATH_INFO};
          $env->{PATH_INFO}   = '';
      }
  
      return $self->serve_path($env, $file);
  }
  
  sub locate_file {
      my($self, $env) = @_;
  
      my $path = $env->{PATH_INFO} || '';
      if ($path =~ m!\.\.[/\\]!) {
          return $self->return_403;
      }
  
      my $docroot = $self->root || ".";
      my @path = split '/', $path;
      if (@path) {
          shift @path if $path[0] eq '';
      } else {
          @path = ('.');
      }
  
      my($file, @path_info);
      while (@path) {
          my $try = File::Spec::Unix->catfile($docroot, @path);
          if ($self->should_handle($try)) {
              $file = $try;
              last;
          } elsif (!$self->allow_path_info) {
              last;
          }
          unshift @path_info, pop @path;
      }
  
      if (!$file) {
          return $self->return_404;
      }
  
      if (!-r $file) {
          return $self->return_403;
      }
  
      return $file, join("/", "", @path_info);
  }
  
  sub allow_path_info { 0 }
  
  sub serve_path {
      my($self, $env, $file) = @_;
  
      my $content_type = Plack::MIME->mime_type($file) || 'text/plain';
  
      if ($content_type =~ m!^text/!) {
          $content_type .= "; charset=" . ($self->encoding || "utf-8");
      }
  
      open my $fh, "<:raw", $file
          or return $self->return_403;
  
      my @stat = stat $file;
  
      Plack::Util::set_io_path($fh, Cwd::realpath($file));
  
      return [
          200,
          [
              'Content-Type'   => $content_type,
              'Content-Length' => $stat[7],
              'Last-Modified'  => HTTP::Date::time2str( $stat[9] )
          ],
          $fh,
      ];
  }
  
  sub return_403 {
      my $self = shift;
      return [403, ['Content-Type' => 'text/plain', 'Content-Length' => 9], ['forbidden']];
  }
  
  # Hint: subclasses can override this to return undef to pass through 404
  sub return_404 {
      my $self = shift;
      return [404, ['Content-Type' => 'text/plain', 'Content-Length' => 9], ['not found']];
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::App::File - Serve static files from root directory
  
  =head1 SYNOPSIS
  
    use Plack::App::File;
    my $app = Plack::App::File->new(root => "/path/to/htdocs")->to_app;
  
    # Or map the path to a specific file
    use Plack::Builder;
    builder {
        mount "/favicon.ico" => Plack::App::File->new(file => '/path/to/favicon.ico');
    };
  
  =head1 DESCRIPTION
  
  This is a static file server PSGI application, and internally used by
  L<Plack::Middleware::Static>. This application serves file from
  document root if the path matches with the local file. Use
  L<Plack::App::Directory> if you want to list files in the directory
  as well.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item root
  
  Document root directory. Defaults to C<.> (current directory)
  
  =item file
  
  The file path to create responses from. Optional.
  
  If it's set the application would B<ALWAYS> create a response out of
  the file and there will be no security check etc. (hence fast). If
  it's not set, the application uses C<root> to find the matching file.
  
  =item encoding
  
  Set the file encoding for text files. Defaults to C<utf-8>.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Middleware::Static> L<Plack::App::Directory>
  
  =cut
  
  
PLACK_APP_FILE

$fatpacked{"Plack/App/PSGIBin.pm"} = <<'PLACK_APP_PSGIBIN';
  package Plack::App::PSGIBin;
  use strict;
  use warnings;
  use parent qw/Plack::App::File/;
  use Plack::Util;
  
  sub allow_path_info { 1 }
  
  sub serve_path {
      my($self, $env, $file) = @_;
  
      my $app = $self->{_compiled}->{$file} ||= Plack::Util::load_psgi($file);
  
      $app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::PSGIBin - Run .psgi files from a directory
  
  =head1 SYNOPSIS
  
    use Plack::App::PSGIBin;
    use Plack::Builder;
  
    my $app = Plack::App::PSGIBin->new(root => "/path/to/psgi/scripts")->to_app;
    builder {
        mount "/psgi" => $app;
    };
  
    # Or from the command line
    plackup -MPlack::App::PSGIBin -e 'Plack::App::PSGIBin->new(root => "/path/psgi/scripts")->to_app'
  
  =head1 DESCRIPTION
  
  This application loads I<.psgi> files (or actually whichever filename
  extensions) from the root directory and run it as a PSGI
  application. Suppose you have a directory containing C<foo.psgi> and
  C<bar.psgi>, map this application to C</app> with
  L<Plack::App::URLMap> and you can access them via the URL:
  
    http://example.com/app/foo.psgi
    http://example.com/app/bar.psgi
  
  to load them. You can rename the file to the one without C<.psgi>
  extension to make the URL look nicer, or use the URL rewriting tools
  like L<Plack::Middleware::Rewrite> to do the same thing.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::App::CGIBin>
PLACK_APP_PSGIBIN

$fatpacked{"Plack/App/URLMap.pm"} = <<'PLACK_APP_URLMAP';
  package Plack::App::URLMap;
  use strict;
  use warnings;
  use parent qw(Plack::Component);
  use constant DEBUG => $ENV{PLACK_URLMAP_DEBUG};
  
  use Carp ();
  
  sub mount { shift->map(@_) }
  
  sub map {
      my $self = shift;
      my($location, $app) = @_;
  
      my $host;
      if ($location =~ m!^https?://(.*?)(/.*)!) {
          $host     = $1;
          $location = $2;
      }
  
      if ($location !~ m!^/!) {
          Carp::croak("Paths need to start with /");
      }
      $location =~ s!/$!!;
  
      push @{$self->{_mapping}}, [ $host, $location, $app ];
  }
  
  sub prepare_app {
      my $self = shift;
      # sort by path length
      $self->{_sorted_mapping} = [
          map  { [ @{$_}[2..4] ] }
          sort { $b->[0] <=> $a->[0] || $b->[1] <=> $a->[1] }
          map  { [ ($_->[0] ? length $_->[0] : 0), length($_->[1]), @$_ ] } @{$self->{_mapping}},
      ];
  }
  
  sub call {
      my ($self, $env) = @_;
  
      my $path_info   = $env->{PATH_INFO};
      my $script_name = $env->{SCRIPT_NAME};
  
      my($http_host, $server_name) = @{$env}{qw( HTTP_HOST SERVER_NAME )};
  
      if ($http_host and my $port = $env->{SERVER_PORT}) {
          $http_host =~ s/:$port$//;
      }
  
      for my $map (@{ $self->{_sorted_mapping} }) {
          my($host, $location, $app) = @$map;
          my $path = $path_info; # copy
          no warnings 'uninitialized';
          DEBUG && warn "Matching request (Host=$http_host Path=$path) and the map (Host=$host Path=$location)\n";
          next unless not defined $host     or
                      $http_host   eq $host or
                      $server_name eq $host;
          next unless $location eq '' or $path =~ s!^\Q$location\E!!;
          next unless $path eq '' or $path =~ m!^/!;
          DEBUG && warn "-> Matched!\n";
  
          my $orig_path_info   = $env->{PATH_INFO};
          my $orig_script_name = $env->{SCRIPT_NAME};
  
          $env->{PATH_INFO}  = $path;
          $env->{SCRIPT_NAME} = $script_name . $location;
          return $self->response_cb($app->($env), sub {
              $env->{PATH_INFO} = $orig_path_info;
              $env->{SCRIPT_NAME} = $orig_script_name;
          });
      }
  
      DEBUG && warn "All matching failed.\n";
  
      return [404, [ 'Content-Type' => 'text/plain' ], [ "Not Found" ]];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::URLMap - Map multiple apps in different paths
  
  =head1 SYNOPSIS
  
    use Plack::App::URLMap;
  
    my $app1 = sub { ... };
    my $app2 = sub { ... };
    my $app3 = sub { ... };
  
    my $urlmap = Plack::App::URLMap->new;
    $urlmap->map("/" => $app1);
    $urlmap->map("/foo" => $app2);
    $urlmap->map("http://bar.example.com/" => $app3);
  
    my $app = $urlmap->to_app;
  
  =head1 DESCRIPTION
  
  Plack::App::URLMap is a PSGI application that can dispatch multiple
  applications based on URL path and hostnames (a.k.a "virtual hosting")
  and takes care of rewriting C<SCRIPT_NAME> and C<PATH_INFO>. This
  module is inspired by Rack::URLMap.
  
  =head1 METHODS
  
  =over 4
  
  =item map
  
    $urlmap->map("/foo" => $app);
    $urlmap->map("http://bar.example.com/" => $another_app);
  
  Maps URL path or an absolute URL to a PSGI application. The match
  order is sorted by host name length and then path length.
  
  URL paths need to match from the beginning and should match completely
  till the path separator (or the end of the path). For example, if you
  register the path C</foo>, it B<will> match with the request C</foo>,
  C</foo/> or C</foo/bar> but it B<won't> match with C</foox>.
  
  Mapping URL with host names is also possible, and in that case the URL
  mapping works like a virtual host.
  
  =item mount
  
  Alias for C<map>.
  
  =item to_app
  
    my $handler = $urlmap->to_app;
  
  Returns the PSGI application code reference. Note that the
  Plack::App::URLMap object is callable (by overloading the code
  dereference), so returning the object itself as a PSGI application
  should also work.
  
  =back
  
  =head1 DEBUGGING
  
  You can set the environment variable C<PLACK_URLMAP_DEBUG> to see how
  this application matches with the incoming request host names and
  paths.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Builder>
  
  =cut
PLACK_APP_URLMAP

$fatpacked{"Plack/App/WrapCGI.pm"} = <<'PLACK_APP_WRAPCGI';
  package Plack::App::WrapCGI;
  use strict;
  use warnings;
  use parent qw(Plack::Component);
  use Plack::Util::Accessor qw(script _app);
  use CGI::Emulate::PSGI;
  use CGI::Compile;
  use Carp;
  
  sub prepare_app {
      my $self = shift;
      my $script = $self->script
          or croak "'script' is not set";
  
      my $sub = CGI::Compile->compile($script);
      my $app = CGI::Emulate::PSGI->handler($sub);
  
      $self->_app($app);
  }
  
  sub call {
      my($self, $env) = @_;
      $self->_app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::App::WrapCGI - Compiles a CGI script as PSGI application
  
  =head1 SYNOPSIS
  
    use Plack::App::WrapCGI;
  
    my $app = Plack::App::WrapCGI->new(script => "/path/to/script.pl")->to_app;
  
  =head1 DESCRIPTION
  
  Plack::App::WrapCGI compiles a CGI script into a PSGI application
  using L<CGI::Compile> and L<CGI::Emulate::PSGI>, and runs it with any
  PSGI server as a PSGI application.
  
  See also L<Plack::App::CGIBin> if you have a directory that contains a
  lot of CGI scripts and serve them like Apache's mod_cgi.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::App::CGIBin>
  
  =cut
PLACK_APP_WRAPCGI

$fatpacked{"Plack/Builder.pm"} = <<'PLACK_BUILDER';
  package Plack::Builder;
  use strict;
  use parent qw( Exporter );
  our @EXPORT = qw( builder add enable enable_if mount );
  
  use Carp ();
  use Plack::App::URLMap;
  use Plack::Middleware::Conditional; # TODO delayed load?
  
  sub new {
      my $class = shift;
      bless { middlewares => [ ] }, $class;
  }
  
  sub add_middleware {
      my($self, $mw, @args) = @_;
  
      if (ref $mw ne 'CODE') {
          my $mw_class = Plack::Util::load_class($mw, 'Plack::Middleware');
          $mw = sub { $mw_class->wrap($_[0], @args) };
      }
  
      push @{$self->{middlewares}}, $mw;
  }
  
  sub add_middleware_if {
      my($self, $cond, $mw, @args) = @_;
  
      if (ref $mw ne 'CODE') {
          my $mw_class = Plack::Util::load_class($mw, 'Plack::Middleware');
          $mw = sub { $mw_class->wrap($_[0], @args) };
      }
  
      push @{$self->{middlewares}}, sub {
          Plack::Middleware::Conditional->wrap($_[0], condition => $cond, builder => $mw);
      };
  }
  
  # do you want remove_middleware() etc.?
  
  sub to_app {
      my($self, $app) = @_;
  
      for my $mw (reverse @{$self->{middlewares}}) {
          $app = $mw->($app);
      }
  
      $app;
  }
  
  # DSL goes here
  our $_add = our $_add_if = our $_mount = sub {
      Carp::croak("enable/mount should be called inside builder {} block");
  };
  
  sub add      { Carp::carp("add is deprecated. Use 'enable'"); $_add->(@_) }
  sub enable         { $_add->(@_) }
  sub enable_if(&$@) { $_add_if->(@_) }
  sub mount          { $_mount->(@_) }
  
  sub builder(&) {
      my $block = shift;
  
      my $self = __PACKAGE__->new;
  
      my $mount_is_called;
      my $urlmap = Plack::App::URLMap->new;
      local $_mount = sub {
          $mount_is_called++;
          $urlmap->map(@_);
          $urlmap;
      };
      local $_add = sub {
          $self->add_middleware(@_);
      };
      local $_add_if = sub {
          $self->add_middleware_if(@_);
      };
  
      my $app = $block->();
      if ($mount_is_called && $app ne $urlmap) {
          Carp::carp("You used mount() in builder block but the last line (app) isn't using mount().\n" .
                         "This causes all mount() mappings ignored. See perldoc Plack::Builder for details.");
      }
  
      $self->to_app($app);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Builder - OO and DSL to enable Plack Middlewares
  
  =head1 SYNOPSIS
  
    # in .psgi
    use Plack::Builder;
  
    my $app = sub { ... };
  
    builder {
        enable "Plack::Middleware::Foo";
        enable "Plack::Middleware::Bar", opt => "val";
        enable "Plack::Middleware::Baz";
        enable sub {
            my $app = shift;
            sub {
                my $env = shift;
                $app->($env);
            };
        };
        $app;
    };
  
    # use URLMap
  
    builder {
        mount "/foo" => builder {
            enable "Plack::Middleware::Foo";
            $app;
        };
  
        mount "/bar" => $app2;
        mount "http://example.com/" => builder { $app3 };
    };
  
  =head1 DESCRIPTION
  
  Plack::Builder gives you a quick domain specific language (DSL) to
  wrap your application with Plack::Middleware subclasses. The
  middleware you're trying to use should use L<Plack::Middleware> as a
  base class to use this DSL, inspired by Rack::Builder.
  
  Whenever you call C<add> on any middleware, the middleware app is
  pushed to the stack inside the builder, and then reversed when it
  actually creates a wrapped application handler, so:
  
    builder {
        enable "Plack::Middleware::Foo";
        enable "Plack::Middleware::Bar", opt => "val";
        $app;
    };
  
  is syntactically equal to:
  
    $app = Plack::Middleware::Bar->wrap($app, opt => "val");
    $app = Plack::Middleware::Foo->wrap($app);
  
  In other words, you're supposed to C<add> middleware from outer to inner.
  
  Additionally, you can call C<enable> with a coderef, which would take
  C<$app> and returns a another psgi-app which consumes C<$env> in runtime.  So:
  
    my $mw = sub {
        my $app = shift;
        sub { my $env = shift; $app->($env) };
    };
  
    builder {
        enable $mw;
        $app;
    };
  
  is syntactically equal to:
  
    $app = $mw->($app);
  
  =head1 URLMap support
  
  Plack::Builder has a native support for L<Plack::App::URLMap> with C<mount> method.
  
    use Plack::Builder;
    my $app = builder {
        mount "/foo" => $app1;
        mount "/bar" => builder {
            enable "Plack::Middleware::Foo";
            $app2;
        };
    };
  
  See L<Plack::App::URLMap>'s C<map> method to see what they mean. With
  builder you can't use C<map> as a DSL, for the obvious reason :)
  
  B<Note>: Once you use C<mount> in your builder code, you have to use
  C<mount> for all the paths, including the root path (C</>). You can't
  have the default app in the last line of C<builder> like:
  
    builder {
        mount "/foo" => sub { ... };
        sub {
            my $env = shift; # THIS DOESN'T WORK
        };
    };
  
  You'll get warnings saying that your mount configuration will be
  ignored.  Instead you should use C<< mount "/" => ... >> in the last
  line to set the default fallback app.
  
  =head1 CONDITIONAL MIDDLEWARE SUPPORT
  
  You can use C<enable_if> to conditionally enable middleware based on
  the runtime environment. See L<Plack::Middleware::Conditional> for
  details.
  
  =head1 SEE ALSO
  
  L<Plack::Middleware> L<Plack::App::URLMap> L<Plack::Middleware::Conditional>
  
  =cut
  
  
  
PLACK_BUILDER

$fatpacked{"Plack/Component.pm"} = <<'PLACK_COMPONENT';
  package Plack::Component;
  use strict;
  use warnings;
  use Carp ();
  use Plack::Util;
  use overload '&{}' => sub { shift->to_app(@_) }, fallback => 1;
  
  sub new {
      my $proto = shift;
      my $class = ref $proto || $proto;
  
      my $self;
      if (@_ == 1 && ref $_[0] eq 'HASH') {
          $self = bless {%{$_[0]}}, $class;
      } else {
          $self = bless {@_}, $class;
      }
  
      $self;
  }
  
  # NOTE:
  # this is for back-compat only,
  # future modules should use
  # Plack::Util::Accessor directly
  # or their own favorite accessor
  # generator.
  # - SL
  sub mk_accessors {
      my $self = shift;
      Plack::Util::Accessor::mk_accessors( ref( $self ) || $self, @_ )
  }
  
  sub prepare_app { return }
  
  sub to_app {
      my $self = shift;
      $self->prepare_app;
      return sub { $self->call(@_) };
  }
  
  
  sub response_cb {
      my($self, $res, $cb) = @_;
  
      my $body_filter = sub {
          my($cb, $res) = @_;
          my $filter_cb = $cb->($res);
          # If response_cb returns a callback, treat it as a $body filter
          if (defined $filter_cb && ref $filter_cb eq 'CODE') {
              Plack::Util::header_remove($res->[1], 'Content-Length');
              if (defined $res->[2]) {
                  if (ref $res->[2] eq 'ARRAY') {
                      for my $line (@{$res->[2]}) {
                          $line = $filter_cb->($line);
                      }
                      # Send EOF.
                      my $eof = $filter_cb->( undef );
                      push @{ $res->[2] }, $eof if defined $eof;
                  } else {
                      my $body    = $res->[2];
                      my $getline = sub { $body->getline };
                      $res->[2] = Plack::Util::inline_object
                          getline => sub { $filter_cb->($getline->()) },
                          close => sub { $body->close };
                  }
              } else {
                  return $filter_cb;
              }
          }
      };
  
      if (ref $res eq 'ARRAY') {
          $body_filter->($cb, $res);
          return $res;
      } elsif (ref $res eq 'CODE') {
          return sub {
              my $respond = shift;
              my $cb = $cb;  # To avoid the nested closure leak for 5.8.x
              $res->(sub {
                  my $res = shift;
                  my $filter_cb = $body_filter->($cb, $res);
                  if ($filter_cb) {
                      my $writer = $respond->($res);
                      if ($writer) {
                          return Plack::Util::inline_object
                              write => sub { $writer->write($filter_cb->(@_)) },
                              close => sub { $writer->write($filter_cb->(undef)); $writer->close };
                      }
                  } else {
                      return $respond->($res);
                  }
              });
          };
      }
  
      return $res;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Component - Base class for PSGI endpoints
  
  =head1 SYNOPSIS
  
    package Plack::App::Foo;
    use parent qw( Plack::Component );
  
    sub call {
        my($self, $env) = @_;
        # Do something with $env
  
        my $res = ...; # create a response ...
  
        # return the response
        return $res;
    }
  
  =head1 DESCRIPTION
  
  Plack::Component is the base class shared between Plack::Middleware
  and Plack::App::* modules. If you are writing middleware, you should
  inherit from L<Plack::Middleware>, but if you are writing a
  Plack::App::* you should inherit from this directly.
  
  =head1 REQUIRED METHOD
  
  =over 4
  
  =item call ($env)
  
  You are expected to implement a C<call> method in your component. This is
  where all the work gets done. It receives the PSGI C<$env> hash-ref as an
  argument and is expected to return a proper PSGI response value.
  
  =back
  
  =head1 METHODS
  
  =over 4
  
  =item new (%opts | \%opts)
  
  The constructor accepts either a hash or a hash-ref and uses that to
  create the instance with. It will call no other methods and simply return
  the instance that is created.
  
  =item prepare_app
  
  This method is called by C<to_app> and is meant as a hook to be used to
  prepare your component before it is packaged as a PSGI C<$app>.
  
  =item to_app
  
  This is the method used in several parts of the Plack infrastructure to
  convert your component into a PSGI C<$app>. You should not ever need to
  override this method, it is recommended to use C<prepare_app> and C<call>
  instead.
  
  =back
  
  =head1 BACKWARDS COMPATIBILITY
  
  The L<Plack::Middleware> module used to inherit from L<Class::Accessor::Fast>,
  which has been removed in favor of the L<Plack::Util::Accessor> module. When
  developing new components it is recommended to use L<Plack::Util::Accessor>
  like so:
  
    use Plack::Util::Accessor qw( foo bar baz );
  
  However, in order to keep backwards compatibility this module provides a
  C<mk_accessors> method similar to L<Class::Accessor::Fast>. New code should
  not use this and use L<Plack::Util::Accessor> instead.
  
  =head1 SEE ALSO
  
  L<Plack> L<Plack::Builder> L<Plack::Middleware>
  
  =cut
PLACK_COMPONENT

$fatpacked{"Plack/HTTPParser.pm"} = <<'PLACK_HTTPPARSER';
  package Plack::HTTPParser;
  use strict;
  use parent qw(Exporter);
  
  our @EXPORT = qw( parse_http_request );
  
  use Try::Tiny;
  
  {
      if (!$ENV{PLACK_HTTP_PARSER_PP} && try { require HTTP::Parser::XS; 1 }) {
          *parse_http_request = \&HTTP::Parser::XS::parse_http_request;
      } else {
          require Plack::HTTPParser::PP;
          *parse_http_request = \&Plack::HTTPParser::PP::parse_http_request;
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::HTTPParser - Parse HTTP headers
  
  =head1 SYNOPSIS
  
    use Plack::HTTPParser qw(parse_http_request);
  
    my $ret = parse_http_request($header_str, \%env);
    # see HTTP::Parser::XS docs
  
  =head1 DESCRIPTION
  
  Plack::HTTPParser is a wrapper class to dispatch C<parse_http_request>
  to Kazuho Oku's XS based HTTP::Parser::XS or pure perl fallback based
  on David Robins HTTP::Parser.
  
  =head1 SEE ALSO
  
  L<HTTP::Parser::XS> L<HTTP::Parser>
  
  =cut
PLACK_HTTPPARSER

$fatpacked{"Plack/HTTPParser/PP.pm"} = <<'PLACK_HTTPPARSER_PP';
  package Plack::HTTPParser::PP;
  use strict;
  use warnings;
  use URI::Escape;
  
  sub parse_http_request {
      my($chunk, $env) = @_;
      $env ||= {};
  
      # pre-header blank lines are allowed (RFC 2616 4.1)
      $chunk =~ s/^(\x0d?\x0a)+//;
      return -2 unless length $chunk;
  
      # double line break indicates end of header; parse it
      if ($chunk =~ /^(.*?\x0d?\x0a\x0d?\x0a)/s) {
          return _parse_header($chunk, length $1, $env);
      }
      return -2;  # still waiting for unknown amount of header lines
  }
  
  sub _parse_header {
      my($chunk, $eoh, $env) = @_;
  
      my $header = substr($chunk, 0, $eoh,'');
      $chunk =~ s/^\x0d?\x0a\x0d?\x0a//;
  
      # parse into lines
      my @header  = split /\x0d?\x0a/,$header;
      my $request = shift @header;
  
      # join folded lines
      my @out;
      for(@header) {
          if(/^[ \t]+/) {
              return -1 unless @out;
              $out[-1] .= $_;
          } else {
              push @out, $_;
          }
      }
  
      # parse request or response line
      my $obj;
      my ($major, $minor);
  
      my ($method,$uri,$http) = split / /,$request;
      return -1 unless $http and $http =~ /^HTTP\/(\d+)\.(\d+)$/i;
      ($major, $minor) = ($1, $2);
  
      $env->{REQUEST_METHOD}  = $method;
      $env->{SERVER_PROTOCOL} = "HTTP/$major.$minor";
      $env->{REQUEST_URI}     = $uri;
  
      my($path, $query) = ( $uri =~ /^([^?]*)(?:\?(.*))?$/s );
      $env->{PATH_INFO}    = URI::Escape::uri_unescape($path);
      $env->{QUERY_STRING} = $query || '';
      $env->{SCRIPT_NAME}  = '';
  
      # import headers
      my $token = qr/[^][\x00-\x1f\x7f()<>@,;:\\"\/?={} \t]+/;
      my $k;
      for my $header (@out) {
          if ( $header =~ s/^($token): ?// ) {
              $k = $1;
              $k =~ s/-/_/g;
              $k = uc $k;
  
              if ($k !~ /^(?:CONTENT_LENGTH|CONTENT_TYPE)$/) {
                  $k = "HTTP_$k";
              }
          } elsif ( $header =~ /^\s+/) {
              # multiline header
          } else {
              return -1;
          }
  
          if (exists $env->{$k}) {
              $env->{$k} .= ", $header";
          } else {
              $env->{$k} = $header;
          }
      }
  
      return $eoh;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::HTTPParser::PP - Pure perl fallback of HTTP::Parser::XS
  
  =head1 DESCRIPTION
  
  Do not use this module directly. Use L<Plack::HTTPParser> instead.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
  
PLACK_HTTPPARSER_PP

$fatpacked{"Plack/Handler.pm"} = <<'PLACK_HANDLER';
  package Plack::Handler;
  use strict;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler - Connects PSGI applications and Web servers
  
  =head1 SYNOPSIS
  
    package Plack::Handler::AwesomeWebServer;
    sub new {
        my($class, %opt) = @_;
        ...
        return $self;
    }
  
    sub run {
        my($self, $app) = @_;
        # launch the AwesomeWebServer and run $app in the loop
    }
  
    # then from command line
    plackup -s AwesomeWebServer -a app.psgi
  
  =head1 DESCRIPTION
  
  Plack::Handler defines an adapter (connector) interface to adapt
  L<plackup> and L<Plack::Runner> to various PSGI web servers, such as
  Apache2 for mod_perl and Standalone for L<HTTP::Server::PSGI>.
  
  It is an empty class, and as long as they implement the methods
  defined as an Server adapter interface, they do not need to inherit
  Plack::Handler.
  
  If you write a new handler for existing web servers, I recommend you
  to include the full name of the server module after I<Plack::Handler>
  prefix, like L<Plack::Handler::Net::Server::Coro> if you write a
  handler for L<Net::Server::Coro>. That way you'll be using plackup
  command line option like:
  
    plackup -s Net::Server::Coro
  
  that makes it easy to figure out which web server you're going to use.
  
  =head1 METHODS
  
  =over 4
  
  =item new
  
    $server = FooBarServer->new(%args);
  
  Creates a new adapter object. I<%args> can take arbitrary parameters
  to configure server environments but common parameters are:
  
  =over 8
  
  =item port
  
  Port number the server listens to.
  
  =item host
  
  Address the server listens to. Set to undef to listen any interface.
  
  =back
  
  =item run
  
    $server->run($app);
  
  Starts the server process and when a request comes in, run the PSGI
  application passed in C<$app> in the loop.
  
  =item register_service
  
    $server->register_service($app);
  
  Optional interface if your server should run in parallel with other
  event loop, particularly L<AnyEvent>. This is the same as C<run> but
  doesn't run the main loop.
  
  =back
  
  =head1 SEE ALSO
  
  rackup
  
  =cut
  
PLACK_HANDLER

$fatpacked{"Plack/Handler/Apache1.pm"} = <<'PLACK_HANDLER_APACHE1';
  package Plack::Handler::Apache1;
  use strict;
  use Apache::Request;
  use Apache::Constants qw(:common :response);
  
  use Plack::Util;
  use Scalar::Util;
  
  my %apps; # psgi file to $app mapping
  
  sub preload {
      my $class = shift;
      for my $app (@_) {
          $class->load_app($app);
      }
  }
  
  sub load_app {
      my($class, $app) = @_;
      return $apps{$app} ||= do {
          local $ENV{MOD_PERL}; # trick Catalyst/CGI.pm etc.
          Plack::Util::load_psgi $app;
      };
  }
  
  sub handler {
      my $r = shift;
      my $apr = Apache::Request->new($r);
  
      my $psgi = $r->dir_config('psgi_app');
      my $app = __PACKAGE__->load_app($psgi);
  
      $r->subprocess_env; # let Apache create %ENV for us :)
  
      my $env = {
          %ENV,
          'psgi.version'        => [ 1, 1 ],
          'psgi.url_scheme'     => ($ENV{HTTPS}||'off') =~ /^(?:on|1)$/i ? 'https' : 'http',
          'psgi.input'          => $r,
          'psgi.errors'         => *STDERR,
          'psgi.multithread'    => Plack::Util::FALSE,
          'psgi.multiprocess'   => Plack::Util::TRUE,
          'psgi.run_once'       => Plack::Util::FALSE,
          'psgi.streaming'      => Plack::Util::TRUE,
          'psgi.nonblocking'    => Plack::Util::FALSE,
      };
  
      my $vpath    = $env->{SCRIPT_NAME} . $env->{PATH_INFO};
  
      my $location = $r->location || "/";
         $location =~ s{/$}{};
      (my $path_info = $vpath) =~ s/^\Q$location\E//;
  
      $env->{SCRIPT_NAME} = $location;
      $env->{PATH_INFO}   = $path_info;
  
      my $res = $app->($env);
  
      if (ref $res eq 'ARRAY') {
          _handle_response($r, $res);
      }
      elsif (ref $res eq 'CODE') {
          $res->(sub {
              _handle_response($r, $_[0]);
          });
      }
      else {
          die "Bad response $res";
      }
  
      return OK;
  }
  
  sub _handle_response {
      my ($r, $res) = @_;
      my ($status, $headers, $body) = @{ $res };
  
      my $hdrs = ($status >= 200 && $status < 300)
          ? $r->headers_out : $r->err_headers_out;
  
      Plack::Util::header_iter($headers, sub {
          my($h, $v) = @_;
          if (lc $h eq 'content-type') {
              $r->content_type($v);
          } else {
              $hdrs->add($h => $v);
          }
      });
  
      $r->status($status);
      $r->send_http_header;
  
      if (defined $body) {
          if (Plack::Util::is_real_fh($body)) {
              $r->send_fd($body);
          } else {
              Plack::Util::foreach($body, sub { $r->print(@_) });
          }
      }
      else {
          return Plack::Util::inline_object
              write => sub { $r->print(@_) },
              close => sub { };
      }
  }
  
  1;
  
  __END__
  
  
  =head1 NAME
  
  Plack::Handler::Apache1 - Apache 1.3.x handlers to run PSGI application
  
  =head1 SYNOPSIS
  
    <Location />
    SetHandler perl-script
    PerlHandler Plack::Handler::Apache1
    PerlSetVar psgi_app /path/to/app.psgi
    </Location>
  
    <Perl>
    use Plack::Handler::Apache1;
    Plack::Handler::Apache1->preload("/path/to/app.psgi");
    </Perl>
  
  =head1 DESCRIPTION
  
  This is a handler module to run any PSGI application with mod_perl on Apache 1.3.x.
  
  =head1 AUTHOR
  
  Aaron Trevena
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
  
PLACK_HANDLER_APACHE1

$fatpacked{"Plack/Handler/Apache2.pm"} = <<'PLACK_HANDLER_APACHE2';
  package Plack::Handler::Apache2;
  use strict;
  use warnings;
  use Apache2::RequestRec;
  use Apache2::RequestIO;
  use Apache2::RequestUtil;
  use Apache2::Response;
  use Apache2::Const -compile => qw(OK);
  use APR::Table;
  use IO::Handle;
  use Plack::Util;
  use Scalar::Util;
  
  my %apps; # psgi file to $app mapping
  
  sub preload {
      my $class = shift;
      for my $app (@_) {
          $class->load_app($app);
      }
  }
  
  sub load_app {
      my($class, $app) = @_;
      return $apps{$app} ||= do {
          local $ENV{MOD_PERL}; # trick Catalyst/CGI.pm etc.
          Plack::Util::load_psgi $app;
      };
  }
  
  sub call_app {
      my ($class, $r, $app) = @_;
  
      $r->subprocess_env; # let Apache create %ENV for us :)
  
      my $env = {
          %ENV,
          'psgi.version'        => [ 1, 1 ],
          'psgi.url_scheme'     => ($ENV{HTTPS}||'off') =~ /^(?:on|1)$/i ? 'https' : 'http',
          'psgi.input'          => $r,
          'psgi.errors'         => *STDERR,
          'psgi.multithread'    => Plack::Util::FALSE,
          'psgi.multiprocess'   => Plack::Util::TRUE,
          'psgi.run_once'       => Plack::Util::FALSE,
          'psgi.streaming'      => Plack::Util::TRUE,
          'psgi.nonblocking'    => Plack::Util::FALSE,
      };
  
      $class->_recalc_paths($r, $env);
  
      my $res = $app->($env);
  
      if (ref $res eq 'ARRAY') {
          _handle_response($r, $res);
      }
      elsif (ref $res eq 'CODE') {
          $res->(sub {
              _handle_response($r, $_[0]);
          });
      }
      else {
          die "Bad response $res";
      }
  
      return Apache2::Const::OK;
  }
  
  sub handler {
      my $class = __PACKAGE__;
      my $r     = shift;
      my $psgi  = $r->dir_config('psgi_app');
      $class->call_app($r, $class->load_app($psgi));
  }
  
  # The method for PH::Apache2::Regitsry to override.
  sub _recalc_paths {
      my ($class, $r, $env) = @_;
      my $vpath    = $env->{SCRIPT_NAME} . $env->{PATH_INFO};
      my $location = $r->location || "/";
         $location =~ s{/$}{};
      (my $path_info = $vpath) =~ s/^\Q$location\E//;
  
      $env->{SCRIPT_NAME} = $location;
      $env->{PATH_INFO}   = $path_info;
  }
  
  sub _handle_response {
      my ($r, $res) = @_;
  
      my ($status, $headers, $body) = @{ $res };
  
      my $hdrs = ($status >= 200 && $status < 300)
          ? $r->headers_out : $r->err_headers_out;
  
      Plack::Util::header_iter($headers, sub {
          my($h, $v) = @_;
          if (lc $h eq 'content-type') {
              $r->content_type($v);
          } elsif (lc $h eq 'content-length') {
              $r->set_content_length($v);
          } else {
              $hdrs->add($h => $v);
          }
      });
  
      $r->status($status);
  
      if (Scalar::Util::blessed($body) and $body->can('path') and my $path = $body->path) {
          $r->sendfile($path);
      } elsif (defined $body) {
          Plack::Util::foreach($body, sub { $r->print(@_) });
          $r->rflush;
      }
      else {
          return Plack::Util::inline_object
              write => sub { $r->print(@_); $r->rflush },
              close => sub { $r->rflush };
      }
  
      return Apache2::Const::OK;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::Apache2 - Apache 2.0 handlers to run PSGI application
  
  =head1 SYNOPSIS
  
    <Location />
    SetHandler perl-script
    PerlResponseHandler Plack::Handler::Apache2
    PerlSetVar psgi_app /path/to/app.psgi
    </Location>
  
    # Optional, preload the application in the parent like startup.pl
    <Perl>
    use Plack::Handler::Apache2;
    Plack::Handler::Apache2->preload("/path/to/app.psgi");
    </Perl>
  
  =head1 DESCRIPTION
  
  This is a handler module to run any PSGI application with mod_perl on Apache 2.x.
  
  =head1 CREATING CUSTOM HANDLER
  
  If you want to create a custom handler that loads or creates PSGI
  applications using other means than loading from C<.psgi> files, you
  can create your own handler class and use C<call_app> class method to
  run your application.
  
    package My::ModPerl::Handler;
    use Plack::Handler::Apache2;
  
    sub get_app {
      # magic!
    }
  
    sub handler {
      my $r = shift;
      my $app = get_app();
      Plack::Handler::Apache2->call_app($r, $app);
    }
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 CONTRIBUTORS
  
  Paul Driver
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
PLACK_HANDLER_APACHE2

$fatpacked{"Plack/Handler/Apache2/Registry.pm"} = <<'PLACK_HANDLER_APACHE2_REGISTRY';
  package Plack::Handler::Apache2::Registry;
  use strict;
  use warnings;
  use Try::Tiny;
  use Apache2::Const;
  use Apache2::Log;
  use parent qw/Plack::Handler::Apache2/;
  
  sub handler {
      my $class = __PACKAGE__;
      my ($r) = @_;
  
      return try {
          my $app = $class->load_app( $r->filename );
          $class->call_app( $r, $app );
      }catch{
          if(/no such file/i){
              $r->log_error( $_ );
              return Apache2::Const::NOT_FOUND;
          }else{
              $r->log_error( $_ );
              return Apache2::Const::SERVER_ERROR;
          }
      };
  }
  
  # Overriding
  sub _recalc_paths {}
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::Apache2::Registry - Runs .psgi files.
  
  =head1 SYNOPSIS
  
    PerlModule Plack::Handler::Apache2::Registry;
    <Location /psgi-bin>
    SetHandler modperl
    PerlHandler Plack::Handler::Apache2::Registry
    </Location>
  
  =head1 DESCRIPTION
  
  This is a handler module to run any *.psgi files with mod_perl2,
  just like ModPerl::Registry.
  
  =head1 AUTHOR
  
  Masahiro Honma E<lt>hiratara@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<Plack::Handler::Apache2>
  
  =cut
  
PLACK_HANDLER_APACHE2_REGISTRY

$fatpacked{"Plack/Handler/CGI.pm"} = <<'PLACK_HANDLER_CGI';
  package Plack::Handler::CGI;
  use strict;
  use warnings;
  use IO::Handle;
  
  sub new { bless {}, shift }
  
  sub run {
      my ($self, $app) = @_;
  
      my $env = {
          %ENV,
          'psgi.version'    => [ 1, 1 ],
          'psgi.url_scheme' => ($ENV{HTTPS}||'off') =~ /^(?:on|1)$/i ? 'https' : 'http',
          'psgi.input'      => *STDIN,
          'psgi.errors'     => *STDERR,
          'psgi.multithread'  => 0,
          'psgi.multiprocess' => 1,
          'psgi.run_once'     => 1,
          'psgi.streaming'    => 1,
          'psgi.nonblocking'  => 1,
      };
  
      delete $env->{HTTP_CONTENT_TYPE};
      delete $env->{HTTP_CONTENT_LENGTH};
      $env->{'HTTP_COOKIE'} ||= $ENV{COOKIE}; # O'Reilly server bug
  
      if (!exists $env->{PATH_INFO}) {
          $env->{PATH_INFO} = '';
      }
  
      if ($env->{SCRIPT_NAME} eq '/') {
          $env->{SCRIPT_NAME} = '';
          $env->{PATH_INFO}   = '/' . $env->{PATH_INFO};
      }
  
      my $res = $app->($env);
      if (ref $res eq 'ARRAY') {
          $self->_handle_response($res);
      }
      elsif (ref $res eq 'CODE') {
          $res->(sub {
              $self->_handle_response($_[0]);
          });
      }
      else {
          die "Bad response $res";
      }
  }
  
  sub _handle_response {
      my ($self, $res) = @_;
  
      *STDOUT->autoflush(1);
  
      my $hdrs;
      $hdrs = "Status: $res->[0]\015\012";
  
      my $headers = $res->[1];
      while (my ($k, $v) = splice(@$headers, 0, 2)) {
          $hdrs .= "$k: $v\015\012";
      }
      $hdrs .= "\015\012";
  
      print STDOUT $hdrs;
  
      my $body = $res->[2];
      my $cb = sub { print STDOUT $_[0] };
  
      # inline Plack::Util::foreach here
      if (ref $body eq 'ARRAY') {
          for my $line (@$body) {
              $cb->($line) if length $line;
          }
      }
      elsif (defined $body) {
          local $/ = \65536 unless ref $/;
          while (defined(my $line = $body->getline)) {
              $cb->($line) if length $line;
          }
          $body->close;
      }
      else {
          return Plack::Handler::CGI::Writer->new;
      }
  }
  
  package Plack::Handler::CGI::Writer;
  sub new   { bless \do { my $x }, $_[0] }
  sub write { print STDOUT $_[1] }
  sub close { }
  
  package Plack::Handler::CGI;
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Handler::CGI - CGI handler for Plack
  
  =head1 SYNOPSIS
  
  Want to run PSGI application as a CGI script? Rename .psgi to .cgi and
  change the shebang line like:
  
    #!/usr/bin/env plackup
    # rest of the file can be the same as other .psgi file
  
  You can alternatively create a .cgi file that contains something like:
  
    #!/usr/bin/perl
    use Plack::Loader;
    my $app = Plack::Util::load_psgi("/path/to/app.psgi");
    Plack::Loader->auto->run($app);
  
  This will auto-recognize the CGI environment variable to load this class.
  
  If you really want to explicitly load the CGI handler, you can. For instance
  you might do this when you want to embed a PSGI application server built into
  CGI-compatible perl-based web server:
  
    use Plack::Handler::CGI;
    Plack::Handler::CGI->new->run($app);
  
  =head1 DESCRIPTION
  
  This is a handler module to run any PSGI application as a CGI script.
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
  
  
PLACK_HANDLER_CGI

$fatpacked{"Plack/Handler/FCGI.pm"} = <<'PLACK_HANDLER_FCGI';
  package Plack::Handler::FCGI;
  use strict;
  use warnings;
  use constant RUNNING_IN_HELL => $^O eq 'MSWin32';
  
  use Plack::Util;
  use FCGI;
  
  sub new {
      my $class = shift;
      my $self  = bless {@_}, $class;
  
      $self->{leave_umask} ||= 0;
      $self->{keep_stderr} ||= 0;
      $self->{nointr}      ||= 0;
      $self->{daemonize}   ||= $self->{detach}; # compatibility
      $self->{nproc}       ||= 1;
      $self->{pid}         ||= $self->{pidfile}; # compatibility
      $self->{listen}      ||= [ ":$self->{port}" ] if $self->{port}; # compatibility
      $self->{manager}     = 'FCGI::ProcManager' unless exists $self->{manager};
  
      $self;
  }
  
  sub run {
      my ($self, $app) = @_;
  
      my $sock = 0;
      if ($self->{listen}) {
          my $old_umask = umask;
          unless ($self->{leave_umask}) {
              umask(0);
          }
          $sock = FCGI::OpenSocket( $self->{listen}->[0], 100 )
              or die "failed to open FastCGI socket: $!";
          unless ($self->{leave_umask}) {
              umask($old_umask);
          }
      }
      elsif (!RUNNING_IN_HELL) {
          -S STDIN
              or die "STDIN is not a socket: specify a listen location";
      }
  
      my %env;
      my $request = FCGI::Request(
          \*STDIN, \*STDOUT,
          ($self->{keep_stderr} ? \*STDOUT : \*STDERR), \%env, $sock,
          ($self->{nointr} ? 0 : &FCGI::FAIL_ACCEPT_ON_INTR),
      );
  
      my $proc_manager;
  
      if ($self->{listen}) {
          $self->daemon_fork if $self->{daemonize};
  
          if ($self->{manager}) {
              Plack::Util::load_class($self->{manager});
              $proc_manager = $self->{manager}->new({
                  n_processes => $self->{nproc},
                  pid_fname   => $self->{pid},
              });
  
              # detach *before* the ProcManager inits
              $self->daemon_detach if $self->{daemonize};
  
              $proc_manager->pm_manage;
          }
          elsif ($self->{daemonize}) {
              $self->daemon_detach;
          }
      }
  
      while ($request->Accept >= 0) {
          $proc_manager && $proc_manager->pm_pre_dispatch;
  
          my $env = {
              %env,
              'psgi.version'      => [1,1],
              'psgi.url_scheme'   => ($env{HTTPS}||'off') =~ /^(?:on|1)$/i ? 'https' : 'http',
              'psgi.input'        => *STDIN,
              'psgi.errors'       => *STDERR, # FCGI.pm redirects STDERR in Accept() loop, so just print STDERR
                                              # print to the correct error handle based on keep_stderr
              'psgi.multithread'  => Plack::Util::FALSE,
              'psgi.multiprocess' => Plack::Util::TRUE,
              'psgi.run_once'     => Plack::Util::FALSE,
              'psgi.streaming'    => Plack::Util::TRUE,
              'psgi.nonblocking'  => Plack::Util::FALSE,
          };
  
          delete $env->{HTTP_CONTENT_TYPE};
          delete $env->{HTTP_CONTENT_LENGTH};
  
          if ($env->{SERVER_SOFTWARE} && $env->{SERVER_SOFTWARE} =~ m!lighttpd[-/]1\.(\d+\.\d+)!) {
              no warnings;
              if ($ENV{PLACK_ENV} eq 'development' && $1 < 4.23 && $env->{PATH_INFO} eq '') {
                  warn "You're using lighttpd 1.$1 and appear to mount your FastCGI handler under the root ('/'). ",
                       "It's known to be causing issues because of the lighttpd bug. You're recommended to enable ",
                       "LighttpdScriptNameFix middleware, or upgrade lighttpd to 1.4.23 or later and include ",
                       "'fix-root-scriptname' flag in 'fastcgi.server'. See perldoc Plack::Handler::FCGI for details. ",
                       "This friendly warning will go away in the next major release of Plack.";
              }
              $env->{SERVER_NAME} =~ s/:\d+$//; # cut off port number
          }
  
          my $res = Plack::Util::run_app $app, $env;
  
          if (ref $res eq 'ARRAY') {
              $self->_handle_response($res);
          }
          elsif (ref $res eq 'CODE') {
              $res->(sub {
                  $self->_handle_response($_[0]);
              });
          }
          else {
              die "Bad response $res";
          }
  
          $proc_manager && $proc_manager->pm_post_dispatch();
      }
  }
  
  sub _handle_response {
      my ($self, $res) = @_;
  
      *STDOUT->autoflush(1);
  
      my $hdrs;
      $hdrs = "Status: $res->[0]\015\012";
  
      my $headers = $res->[1];
      while (my ($k, $v) = splice @$headers, 0, 2) {
          $hdrs .= "$k: $v\015\012";
      }
      $hdrs .= "\015\012";
  
      print STDOUT $hdrs;
  
      my $cb = sub { print STDOUT $_[0] };
      my $body = $res->[2];
      if (defined $body) {
          Plack::Util::foreach($body, $cb);
      }
      else {
          return Plack::Util::inline_object
              write => $cb,
              close => sub { };
      }
  }
  
  sub daemon_fork {
      require POSIX;
      fork && exit;
  }
  
  sub daemon_detach {
      my $self = shift;
      print "FastCGI daemon started (pid $$)\n";
      open STDIN,  "+</dev/null" or die $!; ## no critic
      open STDOUT, ">&STDIN"     or die $!;
      open STDERR, ">&STDIN"     or die $!;
      POSIX::setsid();
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::FCGI - FastCGI handler for Plack
  
  =head1 SYNOPSIS
  
    # Run as a standalone daemon
    plackup -s FCGI --listen /tmp/fcgi.sock --daemonize --nproc 10
  
    # Run from your web server like mod_fastcgi
    #!/usr/bin/env plackup -s FCGI
    my $app = sub { ... };
  
    # Roll your own
    my $server = Plack::Handler::FCGI->new(
        nproc  => $num_proc,
        listen => $listen,
        detach => 1,
    );
    $server->run($app);
  
  
  =head1 DESCRIPTION
  
  This is a handler module to run any PSGI application as a standalone
  FastCGI daemon or a .fcgi script.
  
  =head2 OPTIONS
  
  =over 4
  
  =item listen
  
      listen => '/path/to/socket'
      listen => ':8080'
  
  Listen on a socket path, hostname:port, or :port.
  
  =item port
  
  listen via TCP on port on all interfaces (Same as C<< listen => ":$port" >>)
  
  =item leave-umask
  
  Set to 1 to disable setting umask to 0 for socket open
  
  =item nointr
  
  Do not allow the listener to be interrupted by Ctrl+C
  
  =item nproc
  
  Specify a number of processes for FCGI::ProcManager
  
  =item pid
  
  Specify a filename for the pid file
  
  =item manager
  
  Specify a FCGI::ProcManager sub-class
  
  =item daemonize
  
  Daemonize the process.
  
  =item keep-stderr
  
  Send STDERR to STDOUT instead of the webserver
  
  =back
  
  =head2 WEB SERVER CONFIGURATIONS
  
  =head3 nginx
  
  This is an example nginx configuration to run your FCGI daemon on a
  Unix domain socket and run it at the server's root URL (/).
  
    http {
      server {
        listen 3001;
        location / {
          set $script "";
          set $path_info $uri;
          fastcgi_pass unix:/tmp/fastcgi.sock;
          fastcgi_param  SCRIPT_NAME      $script;
          fastcgi_param  PATH_INFO        $path_info;
          fastcgi_param  QUERY_STRING     $query_string;
          fastcgi_param  REQUEST_METHOD   $request_method;
          fastcgi_param  CONTENT_TYPE     $content_type;
          fastcgi_param  CONTENT_LENGTH   $content_length;
          fastcgi_param  REQUEST_URI      $request_uri;
          fastcgi_param  SEREVR_PROTOCOL  $server_protocol;
          fastcgi_param  REMOTE_ADDR      $remote_addr;
          fastcgi_param  REMOTE_PORT      $remote_port;
          fastcgi_param  SERVER_ADDR      $server_addr;
          fastcgi_param  SERVER_PORT      $server_port;
          fastcgi_param  SERVER_NAME      $server_name;
        }
      }
    }
  
  If you want to host your application in a non-root path, then you
  should mangle this configuration to set the path to C<SCRIPT_NAME> and
  the rest of the path in C<PATH_INFO>.
  
  See L<http://wiki.nginx.org/NginxFcgiExample> for more details.
  
  =head3 Apache mod_fastcgi
  
  You can use C<FastCgiExternalServer> as normal.
  
    FastCgiExternalServer /tmp/myapp.fcgi -socket /tmp/fcgi.sock
  
  See L<http://www.fastcgi.com/mod_fastcgi/docs/mod_fastcgi.html#FastCgiExternalServer> for more details.
  
  =head3 lighttpd
  
  To host the app in the root path, you're recommended to use lighttpd
  1.4.23 or newer with C<fix-root-scriptname> flag like below.
  
    fastcgi.server = ( "/" =>
       ((
         "socket" => "/tmp/fcgi.sock",
         "check-local" => "disable"
         "fix-root-scriptname" => "enable",
       ))
  
  If you use lighttpd older than 1.4.22 where you don't have
  C<fix-root-scriptname>, mouting apps under the root causes wrong
  C<SCRIPT_NAME> and C<PATH_INFO> set. Also, mouting under the empty
  root (C<"">) or a path that has a trailing slash would still cause
  weird values set even with C<fix-root-scriptname>. In such cases you
  can use L<Plack::Middleware::LighttpdScriptNameFix> to fix it.
  
  To mount in the non-root path over TCP:
  
    fastcgi.server = ( "/foo" =>
       ((
         "host" = "127.0.0.1"
         "port" = "5000"
         "check-local" => "disable"
       ))
  
  It's recommended that your mount path does B<NOT> have the trailing
  slash. If you I<really> need to have one, you should consider using
  L<Plack::Middleware::LighttpdScriptNameFix> to fix the wrong
  B<PATH_INFO> values set by lighttpd.
  
  =cut
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
  
PLACK_HANDLER_FCGI

$fatpacked{"Plack/Handler/HTTP/Server/PSGI.pm"} = <<'PLACK_HANDLER_HTTP_SERVER_PSGI';
  package Plack::Handler::HTTP::Server::PSGI;
  use strict;
  
  # for temporary backward compat
  use parent qw( HTTP::Server::PSGI );
  
  sub new {
      my($class, %args) = @_;
      bless { %args }, $class;
  }
  
  sub run {
      my($self, $app) = @_;
      $self->_server->run($app);
  }
  
  sub _server {
      my $self = shift;
      HTTP::Server::PSGI->new(%$self);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::HTTP::Server::PSGI - adapter for HTTP::Server::PSGI
  
  =head1 SYNOPSIS
  
    % plackup -s HTTP::Server::PSGI \
        --host 127.0.0.1 --port 9091 --timeout 120
  
  =head1 BACKWARD COMPATIBLITY
  
  Since Plack 0.99_22 this handler doesn't support preforking
  configuration i.e. C<--max-workers>. Use L<Starman> or L<Starlet> if
  you need preforking PSGI web server.
  
  =head1 CONFIGURATIONS
  
  =over 4
  
  =item host
  
  Host the server binds to. Defaults to all interfaces.
  
  =item port
  
  Port number the server listens on. Defaults to 8080.
  
  =item timeout
  
  Number of seconds a request times out. Defaults to 300.
  
  =item max-reqs-per-child
  
  Number of requests per worker to process. Defaults to 100.
  
  =back
  
  =head1 AUTHOR
  
  Kazuho Oku
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack> L<HTTP::Server::PSGI>
  
  =cut
PLACK_HANDLER_HTTP_SERVER_PSGI

$fatpacked{"Plack/Handler/HTTP/Server/Simple.pm"} = <<'PLACK_HANDLER_HTTP_SERVER_SIMPLE';
  package Plack::Handler::HTTP::Server::Simple;
  use strict;
  
  sub new {
      my($class, %args) = @_;
      bless {%args}, $class;
  }
  
  sub run {
      my($self, $app) = @_;
  
      my $server = Plack::Handler::HTTP::Server::Simple::PSGIServer->new($self->{port});
      $server->host($self->{host}) if $self->{host};
      $server->app($app);
      $server->{_server_ready} = delete $self->{server_ready} || sub {};
  
      $server->run;
  }
  
  package Plack::Handler::HTTP::Server::Simple::PSGIServer;
  use parent qw(HTTP::Server::Simple::PSGI);
  
  sub print_banner {
      my $self = shift;
  
      $self->{_server_ready}->({
          host => $self->host,
          port => $self->port,
          server_software => 'HTTP::Server::Simple::PSGI',
      });
  }
  
  package Plack::Handler::HTTP::Server::Simple;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::HTTP::Server::Simple - Adapter for HTTP::Server::Simple
  
  =head1 SYNOPSIS
  
    plackup -s HTTP::Server::Simple --port 9090
  
  =head1 DESCRIPTION
  
  Plack::Handler::HTTP::Server::Simple is an adapter to run PSGI
  applications on L<HTTP::Server::Simple>.
  
  =head1 SEE ALSO
  
  L<Plack>, L<HTTP::Server::Simple::PSGI>
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  
  =cut
PLACK_HANDLER_HTTP_SERVER_SIMPLE

$fatpacked{"Plack/Handler/Net/FastCGI.pm"} = <<'PLACK_HANDLER_NET_FASTCGI';
  package Plack::Handler::Net::FastCGI;
  use strict;
  use Plack::Util;
  use IO::Socket             qw[];
  use Net::FastCGI::Constant qw[:common :type :flag :role :protocol_status];
  use Net::FastCGI::Protocol qw[:all];
  
  sub DEBUG () { 0 }
  
  sub new {
      my $class = shift;
      my $self = bless { @_ }, $class;
      $self->{listen} ||= [ ":$self->{port}" ] if $self->{port};
      $self->{values} ||= {
          FCGI_MAX_CONNS   => 1,  # maximum number of concurrent transport connections this application will accept
          FCGI_MAX_REQS    => 1,  # maximum number of concurrent requests this application will accept
          FCGI_MPXS_CONNS  => 0,  # this implementation can't multiplex
      };
      $self;
  }
  
  sub run {
      my ($self, $app) = @_;
      $self->{app} = $app;
  
      my $socket;
      my $proto;
      my $port;
  
      if ($self->{listen}) {
          $port = $self->{listen}->[0];
          if ($port =~ s/^://) {
              $proto = 'tcp';
              $socket = IO::Socket::INET->new(
                  Listen    => 5,
                  LocalPort => $port,
                  Reuse     => 1
              ) or die "Couldn't create listener socket: $!";
          } else {
              $proto = 'unix';
              $socket = IO::Socket::UNIX->new(
                  Listen    => 5,
                  Local     => $port,
              ) or die "Couldn't create UNIX listener socket: $!";
          }
      }
      else {
          (-S STDIN)
            || die "Standard input is not a socket: specify a listen location";
          $socket = \*STDIN;
          $socket->autoflush(1);
      }
  
      $self->{server_ready}->({
          host  => 'localhost',
          port  => $port,
          proto => $proto,
          server_software => 'Plack::Handler::Net::FastCGI',
      }) if $self->{server_ready} && $proto;
  
      while (my $c = $socket->accept) {
          $self->process_connection($c);
      }
  }
  
  sub process_request {
      my($self, $env, $stdin, $stdout, $stderr) = @_;
  
      $env = {
          %$env,
          'psgi.version'      => [1,1],
          'psgi.url_scheme'   => ($env->{HTTPS}||'off') =~ /^(?:on|1)$/i ? 'https' : 'http',
          'psgi.input'        => $stdin,
          'psgi.errors'       => $stderr,
          'psgi.multithread'  => Plack::Util::FALSE,
          'psgi.multiprocess' => Plack::Util::FALSE, # xxx?
          'psgi.run_once'     => Plack::Util::FALSE,
          'psgi.streaming'    => Plack::Util::TRUE,
          'psgi.nonblocking'  => Plack::Util::FALSE,
      };
  
      delete $env->{HTTP_CONTENT_TYPE};
      delete $env->{HTTP_CONTENT_LENGTH};
  
      my $res = Plack::Util::run_app $self->{app}, $env;
  
      if (ref $res eq 'ARRAY') {
          $self->_handle_response($res, $stdout);
      } elsif (ref $res eq 'CODE') {
          $res->(sub {
              $self->_handle_response($_[0], $stdout);
          });
      } else {
          die "Bad response $res";
      }
  }
  
  sub _handle_response {
      my ($self, $res, $stdout) = @_;
  
      my $hdrs;
      $hdrs = "Status: $res->[0]\015\012";
  
      my $headers = $res->[1];
      while (my ($k, $v) = splice @$headers, 0, 2) {
          $hdrs .= "$k: $v\015\012";
      }
      $hdrs .= "\015\012";
  
      print {$stdout} $hdrs;
  
      my $cb = sub { print {$stdout} $_[0] };
      my $body = $res->[2];
      if (defined $body) {
          Plack::Util::foreach($body, $cb);
      }
      else {
          return Plack::Util::inline_object
              write => $cb,
              close => sub { };
      }
  }
  
  sub read_record {
      @_ == 1 || die(q/Usage: read_record(io)/);
      my ($io) = @_;
      no warnings 'uninitialized';
      read($io, my $header, FCGI_HEADER_LEN) == FCGI_HEADER_LEN
        || return;
      my ($type, $request_id, $clen, $plen) = parse_header($header);
         (!$clen || read($io, my $content, $clen) == $clen)
      && (!$plen || read($io, my $padding, $plen) == $plen)
        || return;
      $content = '' if !$clen;
      return ($type, $request_id, $content);
  }
  
  sub process_connection {
      my($self, $socket) = @_;
  
      my ( $current_id,  # id of the request we are currently processing
           $stdin,       # buffer for stdin
           $stdout,      # buffer for stdout
           $stderr,      # buffer for stderr
           $params,      # buffer for params (environ)
           $output,      # buffer for output
           $done,        # done with connection?
           $keep_conn ); # more requests on this connection?
  
      ($current_id, $stdin, $stdout, $stderr) = (0, '', '', '');
  
      while (!$done) {
          my ($type, $request_id, $content) = read_record($socket)
            or last;
  
          if (DEBUG) {
              warn '< ', dump_record($type, $request_id, $content), "\n";
          }
  
          if ($request_id == FCGI_NULL_REQUEST_ID) {
              if ($type == FCGI_GET_VALUES) {
                  my $query = parse_params($content);
                  my %reply = map { $_ => $self->{values}->{$_} }
                              grep { exists $self->{values}->{$_} }
                              keys %$query;
                  $output = build_record(FCGI_GET_VALUES_RESULT,
                      FCGI_NULL_REQUEST_ID, build_params(\%reply));
              }
              else {
                  $output = build_unknown_type_record($type);
              }
          }
          elsif ($request_id != $current_id && $type != FCGI_BEGIN_REQUEST) {
              # ignore inactive requests (FastCGI Specification 3.3)
          }
          elsif ($type == FCGI_ABORT_REQUEST) {
              $current_id = 0;
              ($stdin, $stdout, $stderr, $params) = ('', '', '', '');
          }
          elsif ($type == FCGI_BEGIN_REQUEST) {
              my ($role, $flags) = parse_begin_request_body($content);
              if ($current_id || $role != FCGI_RESPONDER) {
                  $output = build_end_request_record($request_id, 0, 
                      $current_id ? FCGI_CANT_MPX_CONN : FCGI_UNKNOWN_ROLE);
              }
              else {
                  $current_id = $request_id;
                  $keep_conn  = ($flags & FCGI_KEEP_CONN);
              }
          }
          elsif ($type == FCGI_PARAMS) {
              $params .= $content;
          }
          elsif ($type == FCGI_STDIN) {
              $stdin .= $content;
  
              unless (length $content) {
                  open(my $in, '<', \$stdin)
                    || die(qq/Couldn't open scalar as fh: '$!'/);
  
                  open(my $out, '>', \$stdout)
                    || die(qq/Couldn't open scalar as fh: '$!'/);
  
                  open(my $err, '>', \$stderr)
                    || die(qq/Couldn't open scalar as fh: '$!'/);
  
                  $self->process_request(parse_params($params), $in, $out, $err);
  
                  $done   = 1 unless $keep_conn;
                  $output = build_end_request($request_id, 0,
                      FCGI_REQUEST_COMPLETE, $stdout, $stderr);
  
                  # prepare for next request
                  $current_id = 0;
                  ($stdin, $stdout, $stderr, $params) = ('', '', '', '');
              }
          }
          else {
              warn(qq/Received an unknown record type '$type'/);
          }
  
          if ($output) {
              print {$socket} $output
                || die(qq/Couldn't write: '$!'/);
  
              if (DEBUG) {
                  while (length $output) {
                      my ($type, $rid, $clen, $plen) = parse_header($output);
                      my $content = substr($output, FCGI_HEADER_LEN, $clen);
                      warn '> ', dump_record($type, $rid, $content), "\n";
                      substr($output, 0, FCGI_HEADER_LEN + $clen + $plen, '');
                  }
              }
  
              $output = '';
          }
      }
  
      if (DEBUG && !$done && $!) {
          warn(qq/Request was prematurely aborted: '$!'/);
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::Net::FastCGI - FastCGI handler for Plack using Net::FastCGI
  
  =head1 SYNOPSIS
  
    # Run as a standalone daemon using TCP port
    plackup -s Net::FastCGI --listen :9090
  
  =head1 DESCRIPTION
  
  This is a handler module to run any PSGI application as a standalone
  FastCGI daemon using L<Net::FastCGI>
  
  =head2 OPTIONS
  
  =over 4
  
  =item listen
  
      listen => ':8080'
  
  Listen on a socket path, hostname:port, or :port.
  
  =item port
  
  listen via TCP on port on all interfaces (Same as C<< listen => ":$port" >>)
  
  =back
  
  =head1 AUTHORS
  
  Christian Hansesn
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Handler::FCGI>
  
  =cut
PLACK_HANDLER_NET_FASTCGI

$fatpacked{"Plack/Handler/Standalone.pm"} = <<'PLACK_HANDLER_STANDALONE';
  package Plack::Handler::Standalone;
  use strict;
  use warnings;
  use parent qw( Plack::Handler::HTTP::Server::PSGI );
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Handler::Standalone - adapter for HTTP::Server::PSGI
  
  =head1 SYNOPSIS
  
    % plackup -s Standalone \
        --host 127.0.0.1 --port 9091 --timeout 120
  
  =head1 DESCRIPTION
  
  Plack::Handler::Standalone is an adapter for default Plack server
  implementation L<HTTP::Server::PSGI>. This is just an alias for
  L<Plack::Handler::HTTP::Server::PSGI>.
  
  =head1 SEE ALSO
  
  L<Plack::Handler::HTTP::Server::PSGI>
  
  =cut
PLACK_HANDLER_STANDALONE

$fatpacked{"Plack/Loader.pm"} = <<'PLACK_LOADER';
  package Plack::Loader;
  use strict;
  use Carp ();
  use Plack::Util;
  use Try::Tiny;
  
  sub new {
      my $class = shift;
      bless {}, $class;
  }
  
  sub watch {
      # do nothing. Override in subclass
  }
  
  sub auto {
      my($class, @args) = @_;
  
      my $backend = $class->guess
          or Carp::croak("Couldn't auto-guess server server implementation. Set it with PLACK_SERVER");
  
      my $server = try {
          $class->load($backend, @args);
      } catch {
          warn "Autoloading '$backend' backend failed. Falling back to the Standalone. ",
              "(You might need to install Plack::Handler::$backend from CPAN)\n"
                  if $ENV{PLACK_DEV} && $ENV{PLACK_DEV} eq 'development';
          $class->load('Standalone' => @args);
      };
  
      return $server;
  }
  
  sub load {
      my($class, $server, @args) = @_;
  
      my($server_class, $error);
      for my $prefix (qw( Plack::Handler Plack::Server )) {
          try {
              $server_class = Plack::Util::load_class($server, $prefix);
          } catch {
              $error ||= $_;
          };
          last if $server_class;
      }
  
      if ($server_class) {
          $server_class->new(@args);
      } else {
          die $error;
      }
  }
  
  sub preload_app {
      my($self, $builder) = @_;
      $self->{app} = $builder->();
  }
  
  sub guess {
      my $class = shift;
  
      return $ENV{PLACK_SERVER} if $ENV{PLACK_SERVER};
  
      if ($ENV{PHP_FCGI_CHILDREN} || $ENV{FCGI_ROLE} || $ENV{FCGI_SOCKET_PATH}) {
          return "FCGI";
      } elsif ($ENV{GATEWAY_INTERFACE}) {
          return "CGI";
      } elsif (exists $INC{"AnyEvent.pm"}) {
          return "Twiggy";
      } elsif (exists $INC{"Coro.pm"}) {
          return "Corona";
      } elsif (exists $INC{"POE.pm"}) {
          return "POE";
      } elsif (exists $INC{"Danga/Socket.pm"}) {
          return "Danga::Socket";
      } else {
          return "Standalone";
      }
  }
  
  sub run {
      my($self, $server, $builder) = @_;
      $server->run($self->{app});
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Loader - (auto)load Plack Servers
  
  =head1 SYNOPSIS
  
    # auto-select server backends based on env vars
    use Plack::Loader;
    Plack::Loader->auto(%args)->run($app);
  
    # specify the implementation with a name
    Plack::Loader->load('FCGI', %args)->run($app);
  
  =head1 DESCRIPTION
  
  Plack::Loader is a factory class to load one of Plack::Handler subclasses based on the environment.
  
  =head1 AUTOLOADING
  
  C<< Plack::Loader->auto(%args) >> will autoload the most correct
  server implementation by guessing from environment variables and Perl INC
  hashes.
  
  =over 4
  
  =item PLACK_SERVER
  
    env PLACK_SERVER=AnyEvent ...
  
  Plack users can specify the specific implementation they want to load
  using the C<PLACK_SERVER> environment variable.
  
  =item PHP_FCGI_CHILDREN, GATEWAY_INTERFACE
  
  If there's one of FastCGI or CGI specific environment variables set,
  use the corresponding server implementation.
  
  =item %INC
  
  If one of L<AnyEvent>, L<Coro>, L<POE> or L<Danga::Socket> is loaded,
  the relevant implementation will be loaded.
  
  =back
  
  =cut
  
  
PLACK_LOADER

$fatpacked{"Plack/Loader/Delayed.pm"} = <<'PLACK_LOADER_DELAYED';
  package Plack::Loader::Delayed;
  use strict;
  use parent qw(Plack::Loader);
  
  sub preload_app {
      my($self, $builder) = @_;
      $self->{builder} = $builder;
  }
  
  sub run {
      my($self, $server) = @_;
  
      my $compiled;
      my $app = sub {
          $compiled ||= $self->{builder}->();
          $compiled->(@_);
      };
  
      $server->{psgi_app_builder} = $self->{builder};
      $server->run($app);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Loader::Delayed - Delay the loading of .psgi until the first run
  
  =head1 SYNOPSIS
  
    plackup -s Starlet -L Delayed myapp.psgi
  
  =head1 DESCRIPTION
  
  This loader delays the compilation of specified PSGI application until
  the first request time. This prevents bad things from happening with
  preforking web servers like L<Starlet>, when your application
  manipulates resources such as sockets or database connections in the
  master startup process and then shared by children.
  
  You can combine this loader with C<-M> command line option, like:
  
    plackup -s Starlet -MCatalyst -L Delayed myapp.psgi
  
  loads the module Catalyst in the master process for the better process
  management with copy-on-write, however the application C<myapp.psgi>
  is loaded per children.
  
  L<Starman> since version 0.2000 loads this loader by default unless
  you specify the command line option C<--preload-app> for the
  L<starman> executable.
  
  =head1 DEVELOPERS
  
  Web server developers can make use of C<psgi_app_builder> attribute
  callback set in Plack::Handler, to load the application earlier than
  the first request time.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<plackup>
  
  =cut
  
PLACK_LOADER_DELAYED

$fatpacked{"Plack/Loader/Restarter.pm"} = <<'PLACK_LOADER_RESTARTER';
  package Plack::Loader::Restarter;
  use strict;
  use warnings;
  use parent qw(Plack::Loader);
  use Plack::Util;
  use Try::Tiny;
  
  sub new {
      my($class, $runner) = @_;
      bless { watch => [] }, $class;
  }
  
  sub preload_app {
      my($self, $builder) = @_;
      $self->{builder} = $builder;
  }
  
  sub watch {
      my($self, @dir) = @_;
      push @{$self->{watch}}, @dir;
  }
  
  sub _fork_and_start {
      my($self, $server) = @_;
  
      my $pid = fork;
      die "Can't fork: $!" unless defined $pid;
  
      return $server->run($self->{builder}->()) if $pid == 0; # child
  
      $self->{pid} = $pid;
  }
  
  sub _kill_child {
      my $self = shift;
  
      my $pid = $self->{pid} or return;
      warn "Killing the existing server (pid:$pid)\n";
      kill 'TERM' => $pid;
      waitpid($pid, 0);
      warn "Successfully killed! Restarting the new server process.\n";
  }
  
  sub valid_file {
      my($self, $file) = @_;
      $file->{path} !~ m![/\\][\._]|\.bak$|~$!;
  }
  
  sub run {
      my($self, $server, $builder) = @_;
  
      $self->_fork_and_start($server, $builder);
      return unless $self->{pid};
  
      require Filesys::Notify::Simple;
      my $watcher = Filesys::Notify::Simple->new($self->{watch});
      warn "Watching @{$self->{watch}} for file updates.\n";
  
      while (1) {
          my @restart;
  
          # this is blocking
          $watcher->wait(sub {
              my @events = @_;
              @events = grep $self->valid_file($_), @events;
              return unless @events;
  
              @restart = @events;
          });
  
          next unless @restart;
  
          for my $ev (@restart) {
              warn "-- $ev->{path} updated.\n";
          }
  
          $self->_kill_child;
          $self->_fork_and_start($server, $builder);
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Loader::Restarter - Restarting loader
  
  =head1 SYNOPSIS
  
    plackup -r -R paths
  
  =head1 DESCRIPTION
  
  Plack::Loader::Restarter is a loader backend that implements C<-r> and
  C<-R> option for the L<plackup> script. It forks the server as a child
  process and the parent watches the directories for file updates, and
  whenever it receives the notification, kills the child server and
  restart.
  
  =head1 SEE ALSO
  
  L<Plack::Runner>, L<Catalyst::Restarter>
  
  =cut
PLACK_LOADER_RESTARTER

$fatpacked{"Plack/Loader/Shotgun.pm"} = <<'PLACK_LOADER_SHOTGUN';
  package Plack::Loader::Shotgun;
  use strict;
  use parent qw(Plack::Loader);
  use Storable;
  use Try::Tiny;
  use Plack::Middleware::BufferedStreaming;
  
  sub preload_app {
      my($self, $builder) = @_;
      $self->{builder} = sub { Plack::Middleware::BufferedStreaming->wrap($builder->()) };
  }
  
  sub run {
      my($self, $server) = @_;
  
      my $app = sub {
          my $env = shift;
  
          pipe my $read, my $write;
  
          my $pid = fork;
          if ($pid) {
              # parent
              close $write;
              my $res = Storable::thaw(join '', <$read>);
              close $read;
              waitpid($pid, 0);
  
              return $res;
          } else {
              # child
              close $read;
  
              my $res;
              try {
                  $env->{'psgi.streaming'} = 0;
                  $res = $self->{builder}->()->($env);
                  my @body;
                  Plack::Util::foreach($res->[2], sub { push @body, $_[0] });
                  $res->[2] = \@body;
              } catch {
                  $env->{'psgi.errors'}->print($_);
                  $res = [ 500, [ "Content-Type", "text/plain" ], [ "Internal Server Error" ] ];
              };
  
              print {$write} Storable::freeze($res);
              close $write;
              exit;
          }
      };
  
      $server->run($app);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Loader::Shotgun - forking implementation of plackup
  
  =head1 SYNOPSIS
  
    plackup -L Shotgun
  
  =head1 DESCRIPTIOM
  
  Shotgun loader delays the compilation and execution of your
  application until the runtime. When a new request comes in, this forks
  a new child, compiles your code and runs the application.
  
  This should be an ultimate alternative solution when reloading with
  L<Plack::Middleware::Refresh> doesn't work, or plackup's default C<-r>
  filesystem watcher causes problems. I can imagine this is useful for
  applications which expects their application is only evaluated once
  (like in-file templates) or on operating systems with broken fork
  implementation, etc.
  
  This is much like good old CGI's fork and run but you don't need a web
  server, and there's a benefit of preloading modules that are not
  likely to change. For instance if you develop a web application using
  Moose and DBIx::Class,
  
    plackup -MMoose -MDBIx::Class -L Shotgun yourapp.psgi
  
  would preload those modules and only re-evaluates your code in every
  request.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa with an inspiration from L<http://github.com/rtomayko/shotgun>
  
  =head1 SEE ALSO
  
  L<plackup>
  
  =cut
PLACK_LOADER_SHOTGUN

$fatpacked{"Plack/MIME.pm"} = <<'PLACK_MIME';
  package Plack::MIME;
  use strict;
  
  # stolen from rack.mime.rb
  our $MIME_TYPES = {
      ".3gp"     => "video/3gpp",
      ".a"       => "application/octet-stream",
      ".ai"      => "application/postscript",
      ".aif"     => "audio/x-aiff",
      ".aiff"    => "audio/x-aiff",
      ".asc"     => "application/pgp-signature",
      ".asf"     => "video/x-ms-asf",
      ".asm"     => "text/x-asm",
      ".asx"     => "video/x-ms-asf",
      ".atom"    => "application/atom+xml",
      ".au"      => "audio/basic",
      ".avi"     => "video/x-msvideo",
      ".bat"     => "application/x-msdownload",
      ".bin"     => "application/octet-stream",
      ".bmp"     => "image/bmp",
      ".bz2"     => "application/x-bzip2",
      ".c"       => "text/x-c",
      ".cab"     => "application/vnd.ms-cab-compressed",
      ".cc"      => "text/x-c",
      ".chm"     => "application/vnd.ms-htmlhelp",
      ".class"   => "application/octet-stream",
      ".com"     => "application/x-msdownload",
      ".conf"    => "text/plain",
      ".cpp"     => "text/x-c",
      ".crt"     => "application/x-x509-ca-cert",
      ".css"     => "text/css",
      ".csv"     => "text/csv",
      ".cxx"     => "text/x-c",
      ".deb"     => "application/x-debian-package",
      ".der"     => "application/x-x509-ca-cert",
      ".diff"    => "text/x-diff",
      ".djv"     => "image/vnd.djvu",
      ".djvu"    => "image/vnd.djvu",
      ".dll"     => "application/x-msdownload",
      ".dmg"     => "application/octet-stream",
      ".doc"     => "application/msword",
      ".dot"     => "application/msword",
      ".dtd"     => "application/xml-dtd",
      ".dvi"     => "application/x-dvi",
      ".ear"     => "application/java-archive",
      ".eml"     => "message/rfc822",
      ".eps"     => "application/postscript",
      ".exe"     => "application/x-msdownload",
      ".f"       => "text/x-fortran",
      ".f77"     => "text/x-fortran",
      ".f90"     => "text/x-fortran",
      ".flv"     => "video/x-flv",
      ".for"     => "text/x-fortran",
      ".gem"     => "application/octet-stream",
      ".gemspec" => "text/x-script.ruby",
      ".gif"     => "image/gif",
      ".gz"      => "application/x-gzip",
      ".h"       => "text/x-c",
      ".hh"      => "text/x-c",
      ".htm"     => "text/html",
      ".html"    => "text/html",
      ".ico"     => "image/vnd.microsoft.icon",
      ".ics"     => "text/calendar",
      ".ifb"     => "text/calendar",
      ".iso"     => "application/octet-stream",
      ".jar"     => "application/java-archive",
      ".java"    => "text/x-java-source",
      ".jnlp"    => "application/x-java-jnlp-file",
      ".jpeg"    => "image/jpeg",
      ".jpg"     => "image/jpeg",
      ".js"      => "application/javascript",
      ".json"    => "application/json",
      ".log"     => "text/plain",
      ".m3u"     => "audio/x-mpegurl",
      ".m4v"     => "video/mp4",
      ".man"     => "text/troff",
      ".manifest"=> "text/cache-manifest",
      ".mathml"  => "application/mathml+xml",
      ".mbox"    => "application/mbox",
      ".mdoc"    => "text/troff",
      ".me"      => "text/troff",
      ".mid"     => "audio/midi",
      ".midi"    => "audio/midi",
      ".mime"    => "message/rfc822",
      ".mml"     => "application/mathml+xml",
      ".mng"     => "video/x-mng",
      ".mov"     => "video/quicktime",
      ".mp3"     => "audio/mpeg",
      ".mp4"     => "video/mp4",
      ".mp4v"    => "video/mp4",
      ".mpeg"    => "video/mpeg",
      ".mpg"     => "video/mpeg",
      ".ms"      => "text/troff",
      ".msi"     => "application/x-msdownload",
      ".odp"     => "application/vnd.oasis.opendocument.presentation",
      ".ods"     => "application/vnd.oasis.opendocument.spreadsheet",
      ".odt"     => "application/vnd.oasis.opendocument.text",
      ".ogg"     => "application/ogg",
      ".ogv"     => "video/ogg",
      ".p"       => "text/x-pascal",
      ".pas"     => "text/x-pascal",
      ".pbm"     => "image/x-portable-bitmap",
      ".pdf"     => "application/pdf",
      ".pem"     => "application/x-x509-ca-cert",
      ".pgm"     => "image/x-portable-graymap",
      ".pgp"     => "application/pgp-encrypted",
      ".pkg"     => "application/octet-stream",
      ".pl"      => "text/x-script.perl",
      ".pm"      => "text/x-script.perl-module",
      ".png"     => "image/png",
      ".pnm"     => "image/x-portable-anymap",
      ".ppm"     => "image/x-portable-pixmap",
      ".pps"     => "application/vnd.ms-powerpoint",
      ".ppt"     => "application/vnd.ms-powerpoint",
      ".ps"      => "application/postscript",
      ".psd"     => "image/vnd.adobe.photoshop",
      ".py"      => "text/x-script.python",
      ".qt"      => "video/quicktime",
      ".ra"      => "audio/x-pn-realaudio",
      ".rake"    => "text/x-script.ruby",
      ".ram"     => "audio/x-pn-realaudio",
      ".rar"     => "application/x-rar-compressed",
      ".rb"      => "text/x-script.ruby",
      ".rdf"     => "application/rdf+xml",
      ".roff"    => "text/troff",
      ".rpm"     => "application/x-redhat-package-manager",
      ".rss"     => "application/rss+xml",
      ".rtf"     => "application/rtf",
      ".ru"      => "text/x-script.ruby",
      ".s"       => "text/x-asm",
      ".sgm"     => "text/sgml",
      ".sgml"    => "text/sgml",
      ".sh"      => "application/x-sh",
      ".sig"     => "application/pgp-signature",
      ".snd"     => "audio/basic",
      ".so"      => "application/octet-stream",
      ".svg"     => "image/svg+xml",
      ".svgz"    => "image/svg+xml",
      ".swf"     => "application/x-shockwave-flash",
      ".t"       => "text/troff",
      ".tar"     => "application/x-tar",
      ".tbz"     => "application/x-bzip-compressed-tar",
      ".tcl"     => "application/x-tcl",
      ".tex"     => "application/x-tex",
      ".texi"    => "application/x-texinfo",
      ".texinfo" => "application/x-texinfo",
      ".text"    => "text/plain",
      ".tif"     => "image/tiff",
      ".tiff"    => "image/tiff",
      ".torrent" => "application/x-bittorrent",
      ".tr"      => "text/troff",
      ".txt"     => "text/plain",
      ".vcf"     => "text/x-vcard",
      ".vcs"     => "text/x-vcalendar",
      ".vrml"    => "model/vrml",
      ".war"     => "application/java-archive",
      ".wav"     => "audio/x-wav",
      ".wma"     => "audio/x-ms-wma",
      ".wmv"     => "video/x-ms-wmv",
      ".wmx"     => "video/x-ms-wmx",
      ".wrl"     => "model/vrml",
      ".wsdl"    => "application/wsdl+xml",
      ".xbm"     => "image/x-xbitmap",
      ".xhtml"   => "application/xhtml+xml",
      ".xls"     => "application/vnd.ms-excel",
      ".xml"     => "application/xml",
      ".xpm"     => "image/x-xpixmap",
      ".xsl"     => "application/xml",
      ".xslt"    => "application/xslt+xml",
      ".yaml"    => "text/yaml",
      ".yml"     => "text/yaml",
      ".zip"     => "application/zip",
  };
  
  my $fallback = sub { };
  
  sub mime_type {
      my($class, $file) = @_;
      $file =~ /(\.[a-zA-Z0-9]+)$/ or return;
      $MIME_TYPES->{lc $1} || $fallback->(lc $1);
  }
  
  sub add_type {
      my $class = shift;
      while (my($ext, $type) = splice @_, 0, 2) {
          $MIME_TYPES->{lc $ext} = $type;
      }
  }
  
  sub set_fallback {
      my($class, $cb) = @_;
      $fallback = $cb;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::MIME - MIME type registry
  
  =head1 SYNOPSIS
  
    use Plack::MIME;
  
    my $mime = Plack::MIME->mime_type(".png"); # image/png
  
    # register new type(s)
    Plack::MIME->add_type(".foo" => "application/x-foo");
  
    # Use MIME::Types as a fallback
    use MIME::Types 'by_suffix';
    Plack::MIME->set_fallback(sub { (by_suffix $_[0])[0] });
  
  =head1 DESCRIPTION
  
  Plack::MIME is a simple MIME type registry for Plack applications. The
  selection of MIME types is based on Rack's Rack::Mime module.
  
  =head1 SEE ALSO
  
  Rack::Mime L<MIME::Types>
  
  =cut
  
  
PLACK_MIME

$fatpacked{"Plack/Middleware.pm"} = <<'PLACK_MIDDLEWARE';
  package Plack::Middleware;
  use strict;
  use warnings;
  use Carp ();
  use parent qw(Plack::Component);
  use Plack::Util;
  use Plack::Util::Accessor qw( app );
  
  sub import {
      my $class = shift;
      if (@_) {
          Carp::carp("use Plack::Middleware qw(Foo) is deprecated. See perldoc Plack::Builder");
      }
  }
  
  sub wrap {
      my($self, $app, @args) = @_;
      if (ref $self) {
          $self->{app} = $app;
      } else {
          $self = $self->new({ app => $app, @args });
      }
      return $self->to_app;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware - Base class for easy-to-use PSGI middleware
  
  =head1 SYNOPSIS
  
    package Plack::Middleware::Foo;
    use parent qw( Plack::Middleware );
  
    sub call {
        my($self, $env) = @_;
        # Do something with $env
  
        # $self->app is the original app
        my $res = $self->app->($env);
  
        # Do something with $res
        return $res;
    }
  
    # then in app.psgi
    use Plack::Builder;
  
    my $app = sub { ... } # as usual
  
    builder {
        enable "Plack::Middleware::Foo";
        enable "Plack::Middleware::Bar", %options;
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware is an utility base class to write PSGI
  middleware. All you have to do is to inherit from Plack::Middleware
  and then implement the callback C<call> method (or C<to_app> method
  that would return the PSGI code reference) to do the actual work. You
  can use C<< $self->app >> to call the original (wrapped) application.
  
  See L<Plack::Builder> how to actually enable middlewares in your
  I<.psgi> application file using the DSL. If you do not like our
  builder DSL, you can also use C<wrap> method to wrap your application
  with a middleware:
  
    use Plack::Middleware::Foo;
  
    my $app = sub { ... };
    $app = Plack::Middleware::Foo->wrap($app, %options);
    $app = Plack::Middleware::Bar->wrap($app, %options);
  
  =head1 SEE ALSO
  
  L<Plack> L<Plack::Builder>
  
  =cut
PLACK_MIDDLEWARE

$fatpacked{"Plack/Middleware/AccessLog.pm"} = <<'PLACK_MIDDLEWARE_ACCESSLOG';
  package Plack::Middleware::AccessLog;
  use strict;
  use warnings;
  use parent qw( Plack::Middleware );
  use Plack::Util::Accessor qw( logger format );
  
  use Carp ();
  use Plack::Util;
  
  my %formats = (
      common => "%h %l %u %t \"%r\" %>s %b",
      combined => "%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-agent}i\"",
  );
  
  use POSIX ();
  
  sub call {
      my $self = shift;
      my($env) = @_;
  
      my $res = $self->app->($env);
  
      return $self->response_cb($res, sub {
          my $res = shift;
          my $logger = $self->logger || sub { $env->{'psgi.errors'}->print(@_) };
  
          my $content_length = Plack::Util::content_length($res->[2]);
          $logger->( $self->log_line($res->[0], $res->[1], $env, { content_length => $content_length }) );
      });
  }
  
  sub log_line {
      my($self, $status, $headers, $env, $opts) = @_;
  
      my $h = Plack::Util::headers($headers);
  
      my $strftime = sub {
          my $old_locale = POSIX::setlocale(&POSIX::LC_ALL);
          POSIX::setlocale(&POSIX::LC_ALL, 'en');
          my $out = POSIX::strftime(@_);
          POSIX::setlocale(&POSIX::LC_ALL, $old_locale);
          return $out;
      };
  
      my $block_handler = sub {
          my($block, $type) = @_;
          if ($type eq 'i') {
              $block =~ s/-/_/;
              return _safe($env->{"HTTP_" . uc($block)}) || "-";
          } elsif ($type eq 'o') {
              return scalar $h->get($block) || "-";
          } elsif ($type eq 't') {
              return "[" . $strftime->($block, localtime) . "]";
          } else {
              Carp::carp("{$block}$type not supported");
              return "-";
          }
      };
  
      my %char_handler = (
          '%' => sub { '%' },
          h => sub { $env->{REMOTE_ADDR} || '-' },
          l => sub { '-' },
          u => sub { $env->{REMOTE_USER} || '-' },
          t => sub { "[" . $strftime->("%d/%b/%Y %H:%M:%S", localtime) . "]" },
          r => sub { _safe($env->{REQUEST_METHOD}) . " " . _safe($env->{REQUEST_URI}) .
                     " " . $env->{SERVER_PROTOCOL} },
          s => sub { $status },
          b => sub { $opts->{content_length} || $h->get('Content-Length') || "-" },
          T => sub { $opts->{time} ? int($opts->{time}) : "-" },
          D => sub { $opts->{time} || "-" },
      );
  
      my $char_handler = sub {
          my $char = shift;
  
          my $cb = $char_handler{$char};
          unless ($cb) {
              Carp::carp "\%$char not supported.";
              return "-";
          }
          $cb->($char);
      };
  
      my $fmt = $self->format || "combined";
      $fmt = $formats{$fmt} if exists $formats{$fmt};
  
      $fmt =~ s{
          (?:
           \%\{(.+?)\}([a-z]) |
           \%(?:[<>])?([a-zA-Z\%])
          )
      }{ $1 ? $block_handler->($1, $2) : $char_handler->($3) }egx;
  
      return $fmt . "\n";
  }
  
  sub _safe {
      my $string = shift;
      $string =~ s/([^[:print:]])/"\\x" . unpack("H*", $1)/eg
          if defined $string;
      $string;
  }
  
  
  __END__
  
  =for stopwords
  LogFormat
  
  =head1 NAME
  
  Plack::Middleware::AccessLog - Logs requests like Apache's log format
  
  =head1 SYNOPSIS
  
    # in app.psgi
    use Plack::Builder;
  
    builder {
        enable "Plack::Middleware::AccessLog", format => "combined";
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::AccessLog forwards the request to the given app and
  logs request and response details to the logger callback. The format
  can be specified using Apache-like format strings (or C<combined> or
  C<common> for the default formats).
  
  This middleware uses calculable content-length by checking body type,
  and can not log the time taken to serve requests. It also logs the
  request B<before> the response is actually sent to the client. Use
  L<Plack::Middleware::AccessLog::Timed> if you want to log details
  B<after> the response is transmitted (more like a real web server) to
  the client.
  
  This middleware is enabled by default when you run L<plackup> as a
  default C<development> environment.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item format
  
    enable "Plack::Middleware::AccessLog",
        format => "%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-agent}i\"";
  
  Takes a format string (or a preset template C<combined> or C<custom>)
  to specify the log format. This middleware implements subset of
  Apache's LogFormat templates.
  
  =item logger
  
    my $logger = Log::Dispatch->new(...);
    enable "Plack::Middleware::AccessLog",
        logger => sub { $logger->log(debug => @_) };
  
  Sets a callback to print log message to. It prints to C<psgi.errors>
  output stream by default.
  
  =back
  
  =head1 SEE ALSO
  
  L<http://httpd.apache.org/docs/2.2/mod/mod_log_config.html> Rack::CustomLogger
  
  =cut
  
PLACK_MIDDLEWARE_ACCESSLOG

$fatpacked{"Plack/Middleware/AccessLog/Timed.pm"} = <<'PLACK_MIDDLEWARE_ACCESSLOG_TIMED';
  package Plack::Middleware::AccessLog::Timed;
  use strict;
  use warnings;
  use parent qw( Plack::Middleware::AccessLog );
  
  use Time::HiRes;
  use Plack::Util;
  
  sub call {
      my $self = shift;
      my($env) = @_;
  
      my $time = Time::HiRes::gettimeofday;
      my $length = 0;
      my $logger = $self->logger || sub { $env->{'psgi.errors'}->print(@_) };
  
      my $res = $self->app->($env);
  
      return $self->response_cb($res, sub {
          my $res = shift;
          my($status, $header, $body) = @$res;
  
          if (!defined $body) {
              $logger->( $self->log_line($status, $header, $env) );
              return;
          }
  
          my $getline = ref $body eq 'ARRAY' ? sub { shift @$body } : sub { $body->getline };
  
          my $timer_body = Plack::Util::inline_object(
              getline => sub {
                  my $line = $getline->();
                  $length += length $line if defined $line;
                  return $line;
              },
              close => sub {
                  $body->close if ref $body ne 'ARRAY';
  
                  my $now = Time::HiRes::gettimeofday;
                  $logger->( $self->log_line($status, $header, $env, { time => $now - $time, content_length => $length }) );
              },
          );
  
          @$res = ($status, $header, $timer_body);
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::AccessLog::Timed - Logs requests with time and accurate body size
  
  =head1 SYNOPSIS
  
    # in app.psgi
    use Plack::Builder;
  
    builder {
        enable "Plack::Middleware::AccessLog::Timed",
            format => ""%v %h %l %u %t \"%r\" %>s %b %D";
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::AccessLog::Timed is a subclass of
  Plack::Middleware::AccessLog but uses a wrapped body handle to get the
  actual response body size C<%b> (even if it's not a chunk of array or
  a real filehandle) and the time taken to serve the request: C<%T> or
  C<%D>.
  
  This wraps the response body output stream so some server
  optimizations like sendfile(2) will be disabled if you use this
  middleware.
  
  =head1 CONFIGURATION
  
  Same as L<Plack::Middleware::AccessLog>.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Middleware::AccessLog>
  
  =cut
PLACK_MIDDLEWARE_ACCESSLOG_TIMED

$fatpacked{"Plack/Middleware/Auth/Basic.pm"} = <<'PLACK_MIDDLEWARE_AUTH_BASIC';
  package Plack::Middleware::Auth::Basic;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util::Accessor qw( realm authenticator );
  use Scalar::Util;
  use MIME::Base64;
  
  sub prepare_app {
      my $self = shift;
  
      my $auth = $self->authenticator or die 'authenticator is not set';
      if (Scalar::Util::blessed($auth) && $auth->can('authenticate')) {
          $self->authenticator(sub { $auth->authenticate(@_) });
      } elsif (ref $auth ne 'CODE') {
          die 'authenticator should be a code reference or an object that responds to authenticate()';
      }
  }
  
  sub call {
      my($self, $env) = @_;
  
      my $auth = $env->{HTTP_AUTHORIZATION}
          or return $self->unauthorized;
  
      if ($auth =~ /^Basic (.*)$/) {
          my($user, $pass) = split /:/, (MIME::Base64::decode($1) || ":");
          $pass = '' unless defined $pass;
          if ($self->authenticator->($user, $pass)) {
              $env->{REMOTE_USER} = $user;
              return $self->app->($env);
          }
      }
  
      return $self->unauthorized;
  }
  
  sub unauthorized {
      my $self = shift;
      my $body = 'Authorization required';
      return [
          401,
          [ 'Content-Type' => 'text/plain',
            'Content-Length' => length $body,
            'WWW-Authenticate' => 'Basic realm="' . ($self->realm || "restricted area") . '"' ],
          [ $body ],
      ];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Auth::Basic - Simple basic authentication middleware
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
    my $app = sub { ... };
  
    builder {
        enable "Auth::Basic", authenticator => \&authen_cb;
        $app;
    };
  
    sub authen_cb {
        my($username, $password) = @_;
        return $username eq 'admin' && $password eq 's3cr3t';
    }
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Auth::Basic is a basic authentication handler for Plack.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item authenticator
  
  A callback function that takes username and password supplied and
  returns whether the authentication succeeds. Required.
  
  Authenticator can also be an object that responds to C<authenticate>
  method that takes username and password and returns boolean, so
  backends for L<Authen::Simple> is perfect to use:
  
    use Authen::Simple::LDAP;
    enable "Auth::Basic", authenticator => Authen::Simple::LDAP->new(...);
  
  =item realm
  
  Realm name to display in the basic authentication dialog. Defaults to I<restricted area>.
  
  =back
  
  =head1 LIMITATIONS
  
  This middleware expects that the application has a full access to the
  headers sent by clients in PSGI environment. That is normally the case
  with standalone Perl PSGI web servers such as L<Starman> or
  L<HTTP::Server::Simple::PSGI>.
  
  However, in a web server configuration where you can't achieve this
  (i.e. using your application via mod_perl, CGI or FastCGI), this
  middleware does not work since your application can't know the value
  of C<Authorization:> header.
  
  If you use Apache as a web server and CGI or mod_perl to run your PSGI
  application, you can use mod_rewrite to pass the Authorization header
  to the application with the rewrite rule like following.
  
    RewriteEngine on
    RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization},L]
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
PLACK_MIDDLEWARE_AUTH_BASIC

$fatpacked{"Plack/Middleware/BufferedStreaming.pm"} = <<'PLACK_MIDDLEWARE_BUFFEREDSTREAMING';
  package Plack::Middleware::BufferedStreaming;
  use strict;
  no warnings;
  use Carp;
  use Plack::Util;
  use Scalar::Util qw(weaken);
  use parent qw(Plack::Middleware);
  
  sub call {
      my ( $self, $env ) = @_;
  
      my $caller_supports_streaming = $env->{'psgi.streaming'};
      $env->{'psgi.streaming'} = Plack::Util::TRUE;
  
      my $res = $self->app->($env);
      return $res if $caller_supports_streaming;
  
      if ( ref($res) eq 'CODE' ) {
          my $ret;
  
          $res->(sub {
              my $write = shift;
  
              if ( @$write == 2 ) {
                  my @body;
  
                  $ret = [ @$write, \@body ];
  
                  return Plack::Util::inline_object(
                      write => sub { push @body, $_[0] },
                      close => sub { },
                  );
              } else {
                  $ret = $write;
                  return;
              }
          });
  
          return $ret;
      } else {
          return $res;
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::BufferedStreaming - Enable buffering for non-streaming aware servers
  
  =head1 SYNOPSIS
  
    enable "BufferedStreaming";
  
  =head1 DESCRIPTION
  
  Plack::Middleware::BufferedStreaming is a PSGI middleware component
  that wraps the application that uses C<psgi.streaming> interface to
  run on the servers that do not support the interface, by buffering the
  writer output to a temporary buffer.
  
  This middleware doesn't do anything and bypass the application if the
  server supports C<psgi.streaming> interface.
  
  =head1 AUTHOR
  
  Yuval Kogman
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_MIDDLEWARE_BUFFEREDSTREAMING

$fatpacked{"Plack/Middleware/Chunked.pm"} = <<'PLACK_MIDDLEWARE_CHUNKED';
  package Plack::Middleware::Chunked;
  use strict;
  use parent qw(Plack::Middleware);
  
  use Plack::Util;
  
  sub call {
      my($self, $env) = @_;
      my $res = $self->app->($env);
      $self->response_cb($res, sub {
          my $res = shift;
          my $h = Plack::Util::headers($res->[1]);
          if ($env->{'SERVER_PROTOCOL'} ne 'HTTP/1.0' and
              ! Plack::Util::status_with_no_entity_body($res->[0]) and
              ! $h->exists('Content-Length') and
              ! $h->exists('Transfer-Encoding')
          ) {
              $h->set('Transfer-Encoding' => 'chunked');
              my $done;
              return sub {
                  my $chunk = shift;
                  return if $done;
                  unless (defined $chunk) {
                      $done = 1;
                      return "0\015\012\015\012";
                  }
                  return '' unless length $chunk;
                  return sprintf('%x', length $chunk) . "\015\012$chunk\015\012";
              };
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Chunked - Applies chunked encoding to the response body
  
  =head1 SYNOPSIS
  
    # Mostly from server implemenations
    $app = Plack::Middeware::Chunked->wrap($app);
  
  =head1 DESCRIPTION
  
  Plack::Middeware::Chunked is a middleware, or rather a library for
  PSGI server to automatically add chunked encoding to the response body
  when Content-Length is not set in the response header.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  Rack::Chunked
  
  =cut
PLACK_MIDDLEWARE_CHUNKED

$fatpacked{"Plack/Middleware/Conditional.pm"} = <<'PLACK_MIDDLEWARE_CONDITIONAL';
  package Plack::Middleware::Conditional;
  use strict;
  use parent qw(Plack::Middleware);
  
  use Plack::Util::Accessor qw( condition middleware builder );
  
  sub new {
      my $class = shift;
      my $self = $class->SUPER::new(@_);
  
      $self->middleware( $self->builder->($self->app) );
      $self;
  }
  
  sub call {
      my($self, $env) = @_;
  
      my $app = $self->condition->($env) ? $self->middleware : $self->app;
      return $app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Conditional - Conditional wrapper for Plack middleware
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    builder {
        enable_if { $_[0]->{REMOTE_ADDR} eq '127.0.0.1' } 'StackTrace';
        $app;
    };
  
    # Or more raw version of it
    $app = Plack::Middleware::Conditional->wrap(
        $app,
        condition  => sub { my $env = shift; $env->{HTTP_USER_AGENT} =~ /WebKit/ },
        builder => sub { Plack::Middleware::SuperAdminConsole->wrap($_[0], @args) },
    );
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Conditional is a piece of meta-middleware, to run a
  specific middleware component under the runtime condition. The goal of
  this middleware is to avoid baking runtime configuration options in
  individual middleware components, and rather share them as another
  middleware component.
  
  =head1 EXAMPLES
  
  Note that some of the middleware component names are just made up for
  the explanation and might not exist.
  
    # Minify JavaScript if the browser is Firefox
    enable_if { $_[0]->{HTTP_USER_AGENT} =~ /Firefox/ } 'JavaScriptMinifier';
  
    # Enable Stacktrace when being accessed from the local network
    enable_if { $_[0]->{REMOTE_ADDR} =~ /^10\.0\.1\.*/ } 'StackTrace';
  
    # Work with other conditional setter middleware:
    # Transcode Jpeg on the fly for mobile clients
    builder {
        enable 'MobileDetector';
        enable_if { $_[0]->{'plack.mobile_detected'} }
          'TranscodeJpeg', max_size => 30_000;
        $app;
    };
  
  Note that in the last example I<MobileDetector> should come first
  because the conditional check runs in I<pre-run> condition, which is
  from outer to inner and that is from the top to the bottom in the
  Builder DSL code.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  Steve Cook
  
  =head1 SEE ALSO
  
  L<Plack::Builder>
  
  =cut
PLACK_MIDDLEWARE_CONDITIONAL

$fatpacked{"Plack/Middleware/ConditionalGET.pm"} = <<'PLACK_MIDDLEWARE_CONDITIONALGET';
  package Plack::Middleware::ConditionalGET;
  use strict;
  use parent qw( Plack::Middleware );
  use Plack::Util;
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my $res = $self->app->($env);
      return $res unless $env->{REQUEST_METHOD} =~ /^(GET|HEAD)$/;
  
      $self->response_cb($res, sub {
          my $res = shift;
          my $h = Plack::Util::headers($res->[1]);
          if ( $self->etag_matches($h, $env) || $self->not_modified_since($h, $env) ) {
              $res->[0] = 304;
              $h->remove($_) for qw( Content-Type Content-Length Content-Disposition );
              $res->[2] = [];
          }
      });
  }
  
  no warnings 'uninitialized';
  
  sub etag_matches {
      my($self, $h, $env) = @_;
      $h->exists('ETag') && $h->get('ETag') eq _value($env->{HTTP_IF_NONE_MATCH});
  }
  
  sub not_modified_since {
      my($self, $h, $env) = @_;
      $h->exists('Last-Modified') && $h->get('Last-Modified') eq _value($env->{HTTP_IF_MODIFIED_SINCE});
  }
  
  sub _value {
      my $str = shift;
      # IE sends wrong formatted value(i.e. "Thu, 03 Dec 2009 01:46:32 GMT; length=17936")
      $str =~ s/;.*$//;
      return $str;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::ConditionalGET - Middleware to add "conditional", GET
  
  =head1 SYNOPSIS
  
    builder {
        enable "Plack::Middleware::ConditionalGET";
        ....
    };
  
  =head1 DESCRIPTION
  
  This middleware enables conditional GET and HEAD using
  C<If-None-Match> and C<If-Modified-Since> header. The application
  should set either or both of C<Last-Modified> or C<ETag> response
  headers per RFC 2616. When either of the conditions is met, the
  response body is set to be zero length and the status is set to 304
  Not Modified.
  
  =head1 SEE ALSO
  
  Rack::ConditionalGet
  
  =cut
PLACK_MIDDLEWARE_CONDITIONALGET

$fatpacked{"Plack/Middleware/ContentLength.pm"} = <<'PLACK_MIDDLEWARE_CONTENTLENGTH';
  package Plack::Middleware::ContentLength;
  use strict;
  use warnings;
  use parent qw( Plack::Middleware );
  
  use Plack::Util;
  
  sub call {
      my $self = shift;
      my $res  = $self->app->(@_);
  
      return $self->response_cb($res, sub {
          my $res = shift;
          my $h = Plack::Util::headers($res->[1]);
          if (!Plack::Util::status_with_no_entity_body($res->[0]) &&
              !$h->exists('Content-Length') &&
              !$h->exists('Transfer-Encoding') &&
              defined(my $content_length = Plack::Util::content_length($res->[2]))) {
              $h->push('Content-Length' => $content_length);
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::ContentLength - Adds Content-Length header automatically
  
  =head1 SYNOPSIS
  
    # in app.psgi
  
    builder {
        enable "Plack::Middleware::ContentLength";
        $app;
    }
  
    # Or in Plack::Handler::*
    $app = Plack::Middleware::ContentLength->wrap($app);
  
  =head1 DESCRIPTION
  
  Plack::Middleware::ContentLength is a middleware that automatically
  adds C<Content-Length> header when it's appropriate i.e. the response
  has a content body with calculable size (array of chunks or a real
  filehandle).
  
  This middleware can also be used as a library from PSGI server
  implementations to automatically set C<Content-Length> rather than in
  the end user level.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  Rack::ContentLength
  
  =cut
  
PLACK_MIDDLEWARE_CONTENTLENGTH

$fatpacked{"Plack/Middleware/ContentMD5.pm"} = <<'PLACK_MIDDLEWARE_CONTENTMD5';
  package Plack::Middleware::ContentMD5;
  
  use strict;
  use warnings;
  use parent qw( Plack::Middleware );
  
  use Plack::Util;
  use Digest::MD5 qw/md5_hex/;
  
  sub call {
      my $self = shift;
      my $res  = $self->app->(@_);
      
      $self->response_cb($res, sub {
          my $res = shift;
  
          return unless defined $res->[2];
          return if (Plack::Util::status_with_no_entity_body($res->[0]));
          
          my $h = Plack::Util::headers($res->[1]);
          return if ( $h->exists('Content-MD5') );
          
          my $body = $res->[2];
          if (ref $body eq 'ARRAY') {
              $h->set('Content-MD5', md5_hex(@$body));
          }
          # Do we need support $fh?
  
          return;
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::ContentMD5 - Automatically sets the Content-MD5 header on all String bodies
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    my $app = sub {
        return [ 200, [ 'Content-Type' => 'text/plain' ], [ 'Hello Foo' ] ];
    };
  
    builder {
        enable "Plack::Middleware::ContentMD5";
        $app;
    };
  
  =head1 DESCRIPTION
  
  Automatically sets the Content-MD5 header on all String bodies
  
  =head1 AUTHOR
  
  Fayland Lam
  
  =cut
PLACK_MIDDLEWARE_CONTENTMD5

$fatpacked{"Plack/Middleware/ErrorDocument.pm"} = <<'PLACK_MIDDLEWARE_ERRORDOCUMENT';
  package Plack::Middleware::ErrorDocument;
  use strict;
  use warnings;
  use parent qw(Plack::Middleware);
  use Plack::MIME;
  use Plack::Util;
  use Plack::Util::Accessor qw( subrequest );
  
  use HTTP::Status qw(is_error);
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my $r = $self->app->($env);
  
      $self->response_cb($r, sub {
          my $r = shift;
          unless (is_error($r->[0]) && exists $self->{$r->[0]}) {
              return;
          }
  
          my $path = $self->{$r->[0]};
          if ($self->subrequest) {
              for my $key (keys %$env) {
                  unless ($key =~ /^psgi/) {
                      $env->{'psgix.errordocument.' . $key} = $env->{$key};
                  }
              }
  
              # TODO: What if SCRIPT_NAME is not empty?
              $env->{REQUEST_METHOD} = 'GET';
              $env->{REQUEST_URI}    = $path;
              $env->{PATH_INFO}      = $path;
              $env->{QUERY_STRING}   = '';
              delete $env->{CONTENT_LENGTH};
  
              my $sub_r = $self->app->($env);
              if ($sub_r->[0] == 200) {
                  $r->[1] = $sub_r->[1];
                  $r->[2] = $sub_r->[2];
              }
              # TODO: allow 302 here?
          } else {
              open my $fh, "<", $path or die "$path: $!";
              $r->[2] = $fh;
              my $h = Plack::Util::headers($r->[1]);
              $h->set('Content-Type', Plack::MIME->mime_type($path));
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::ErrorDocument - Set Error Document based on HTTP status code
  
  =head1 SYNOPSIS
  
    # in app.psgi
    use Plack::Builder;
  
    builder {
        enable "Plack::Middleware::ErrorDocument",
            500 => '/uri/errors/500.html', 404 => '/uri/errors/404.html',
            subrequest => 1;
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::ErrorDocument allows you to customize error screen
  by setting paths (file system path or URI path) of error pages per
  status code.
  
  =head1 CONFIGURATIONS
  
  =over 4
  
  =item subrequest
  
  A boolean flag to serve error pages using a new GET sub request.
  Defaults to false, which means it serves error pages using file
  system path.
  
    builder {
        enable "Plack::Middleware::ErrorDocument",
            502 => '/home/www/htdocs/errors/maint.html';
        enable "Plack::Middleware::ErrorDocument",
            404 => '/static/404.html', 403 => '/static/403.html', subrequest => 1;
        $app;
    };
  
  This configuration serves 502 error pages from file system directly
  assuming that's when you probably maintain database etc. but serves
  404 and 403 pages using a sub request so your application can do some
  logic there like logging or doing suggestions.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  =cut
PLACK_MIDDLEWARE_ERRORDOCUMENT

$fatpacked{"Plack/Middleware/HTTPExceptions.pm"} = <<'PLACK_MIDDLEWARE_HTTPEXCEPTIONS';
  package Plack::Middleware::HTTPExceptions;
  use strict;
  use parent qw(Plack::Middleware);
  
  use Carp ();
  use Try::Tiny;
  use Scalar::Util 'blessed';
  use HTTP::Status ();
  
  sub call {
      my($self, $env) = @_;
  
      my $res = try {
          $self->app->($env);
      } catch {
          $self->transform_error($_, $env);
      };
  
      return $res if ref $res eq 'ARRAY';
  
      return sub {
          my $respond = shift;
  
          my $writer;
          try {
              $res->(sub { return $writer = $respond->(@_) });
          } catch {
              if ($writer) {
                  Carp::cluck $_;
                  $writer->close;
              } else {
                  my $res = $self->transform_error($_, $env);
                  $respond->($res);
              }
          };
      };
  }
  
  sub transform_error {
      my($self, $e, $env) = @_;
  
      my($code, $message);
      if (blessed $e && $e->can('code')) {
          $code = $e->code;
          $message =
              $e->can('as_string')       ? $e->as_string :
              overload::Method($e, '""') ? "$e"          : undef;
      } else {
          $code = 500;
          $env->{'psgi.errors'}->print($e);
      }
  
      if ($code !~ /^[3-5]\d\d$/) {
          die $e; # rethrow
      }
  
      $message ||= HTTP::Status::status_message($code);
  
      return [ $code, [ 'Content-Type' => 'text/plain', 'Content-Length' => length($message) ], [ $message ] ];
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::HTTPExceptions - Catch HTTP exceptions
  
  =head1 SYNOPSIS
  
    use HTTP::Exception;
  
    my $app = sub {
        # ...
        HTTP::Exception::500->throw;
    };
  
    builder {
        enable "HTTPExceptions";
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::HTTPExceptions is a PSGI middleware component to
  catch exceptions from applicaitions that can be translated into HTTP
  status code.
  
  Your application is supposed to throw an object that implements
  C<code> method which returns the HTTP status code such as 501 or
  404. This middleware catches them and creates a valid response out of
  the code.
  
  The exception object may also implement C<as_string>, or overload the
  stringification, to represent the text of the error, which defaults to
  the status message of error codes, such as I<Service Unavailable> for
  C<503>.
  
  There's a CPAN module L<HTTP::Exception> and they are pefect to throw
  from your application to let this middleware catch and display, but
  you can also implement your own exception class to throw.
  
  All the other errors that can't be translated into HTTP errors are
  just rethrown to the outer frame.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  paste.httpexceptions L<HTTP::Exception>
  
  =cut
PLACK_MIDDLEWARE_HTTPEXCEPTIONS

$fatpacked{"Plack/Middleware/Head.pm"} = <<'PLACK_MIDDLEWARE_HEAD';
  package Plack::Middleware::Head;
  use strict;
  use warnings;
  use parent qw(Plack::Middleware);
  
  sub call {
      my($self, $env) = @_;
  
      return $self->app->($env)
          unless $env->{REQUEST_METHOD} eq 'HEAD';
  
      $self->response_cb($self->app->($env), sub {
          my $res = shift;
          $res->[2] = [];
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Head - auto delete response body in HEAD requests
  
  =head1 SYNOPSIS
  
    enable "Head";
  
  =head1 DESCRIPTION
  
  This middleware deletes response body in HEAD requests.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  Rack::Head
  
  =cut
  
PLACK_MIDDLEWARE_HEAD

$fatpacked{"Plack/Middleware/JSONP.pm"} = <<'PLACK_MIDDLEWARE_JSONP';
  package Plack::Middleware::JSONP;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util;
  use URI::Escape ();
  
  sub call {
      my($self, $env) = @_;
      my $res = $self->app->($env);
      $self->response_cb($res, sub {
          my $res = shift;
          if (defined $res->[2] && ref $res->[2] eq 'ARRAY' && @{$res->[2]} == 1) {
              my $h = Plack::Util::headers($res->[1]);
              if ($h->get('Content-Type') =~ m!/(?:json|javascript)! &&
                  $env->{QUERY_STRING} =~ /(?:^|&)callback=([^&]+)/) {
                  # TODO: support callback params other than 'callback'
                  my $cb = URI::Escape::uri_unescape($1);
                  if ($cb =~ /^[\w\.\[\]]+$/) {
                      my $jsonp = "$cb($res->[2][0])";
                      $res->[2] = [ $jsonp ];
                      $h->set('Content-Length', length $jsonp);
                      $h->set('Content-Type', 'text/javascript');
                  }
              }
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::JSONP - Wraps JSON response in JSONP if callback parameter is specified
  
  =head1 DESCRIPTION
  
  Plack::Middleware::JSONP wraps JSON response, which has Content-Type
  value either C<text/javascript> or C<application/json> as a JSONP
  response which is specified with the C<callback> query parameter.
  
  This middleware only works with an application response with content
  body set as a single element array ref and doesn't touch the response
  otherwise.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
  
PLACK_MIDDLEWARE_JSONP

$fatpacked{"Plack/Middleware/LighttpdScriptNameFix.pm"} = <<'PLACK_MIDDLEWARE_LIGHTTPDSCRIPTNAMEFIX';
  package Plack::Middleware::LighttpdScriptNameFix;
  use strict;
  use parent qw/Plack::Middleware/;
  use Plack::Util::Accessor qw(script_name);
  
  sub prepare_app {
      my $self = shift;
  
      my $script_name = $self->script_name;
      $script_name = '' unless defined($script_name);
      $script_name =~ s!/$!!;
      $self->script_name($script_name);
  }
  
  sub call {
      my($self, $env) = @_;
  
      if ($env->{SERVER_SOFTWARE} && $env->{SERVER_SOFTWARE} =~ /lighttpd/) {
          $env->{PATH_INFO}   = $env->{SCRIPT_NAME} . $env->{PATH_INFO};
          $env->{SCRIPT_NAME} = $self->script_name;
          $env->{PATH_INFO}  =~ s/^\Q$env->{SCRIPT_NAME}\E//;
      }
  
      return $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::LighttpdScriptNameFix - fixes wrong SCRIPT_NAME and PATH_INFO that lighttpd sets
  
  =head1 SYNOPSIS
  
    # in your app.psgi
    use Plack::Builder;
  
    builder {
      enable "LighttpdScriptNameFix";
      $app;
    };
  
    # Or from the command line
    plackup -s FCGI -e 'enable "LighttpdScriptNameFix"' /path/to/app.psgi
  
  =head1 DESCRIPTION
  
  This middleware fixes wrong C<SCRIPT_NAME> and C<PATH_INFO> set by
  lighttpd when you mount your app under the root path ("/"). If you use
  lighttpd 1.4.23 or later you can instead enable C<fix-root-scriptname>
  flag inside C<fastcgi.server> instead of using this middleware.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item script_name
  
  Even with C<fix-root-scriptname>, lighttpd I<still> sets weird
  C<SCRIPT_NAME> and C<PATH_INFO> if you mount your application at C<"">
  or something that ends with C</>. Setting C<script_name> option tells
  the middleware how to reconstruct the new correct C<SCRIPT_NAME> and
  C<PATH_INFO>.
  
  If you mount the app under C</something/>, you should set:
  
    enable "LighttpdScriptNameFix", script_name => "/something";
  
  and when a request for C</something/a/b?param=1> comes, C<SCRIPT_NAME>
  becomes C</something> and C<PATH_INFO> becomes C</a/b>.
  
  C<script_name> option is set to empty by default, which means all the
  request path is set to C<PATH_INFO> and it behaves like your fastcgi
  application is mounted in the root path.
  
  =back
  
  =head1 AUTHORS
  
  Yury Zavarin
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Handler::FCGI>
  L<http://github.com/miyagawa/Plack/issues#issue/68>
  L<https://redmine.lighttpd.net/issues/729>
  
  =cut
  
PLACK_MIDDLEWARE_LIGHTTPDSCRIPTNAMEFIX

$fatpacked{"Plack/Middleware/Lint.pm"} = <<'PLACK_MIDDLEWARE_LINT';
  package Plack::Middleware::Lint;
  use strict;
  no warnings;
  use Carp ();
  use parent qw(Plack::Middleware);
  use Scalar::Util qw(blessed);
  use Plack::Util;
  
  sub wrap {
      my($self, $app) = @_;
  
      unless (ref $app eq 'CODE' or overload::Method($app, '&{}')) {
          Carp::croak("PSGI app should be a code reference: ", (defined $app ? $app : "undef"));
      }
  
      $self->SUPER::wrap($app);
  }
  
  sub call {
      my $self = shift;
      my $env = shift;
  
      $self->validate_env($env);
      my $res = $self->app->($env);
      return $self->validate_res($res);
  }
  
  sub validate_env {
      my ($self, $env) = @_;
      unless ($env->{'REQUEST_METHOD'}) {
          Carp::croak('missing env param: REQUEST_METHOD');
      }
      unless ($env->{'REQUEST_METHOD'} =~ /^[A-Z]+$/) {
          Carp::croak("invalid env param: REQUEST_METHOD($env->{REQUEST_METHOD})");
      }
      unless (defined($env->{'SCRIPT_NAME'})) { # allows empty string
          Carp::croak('missing mandatory env param: SCRIPT_NAME');
      }
      unless (defined($env->{'PATH_INFO'})) { # allows empty string
          Carp::croak('missing mandatory env param: PATH_INFO');
      }
      unless (defined($env->{'SERVER_NAME'})) {
          Carp::croak('missing mandatory env param: SERVER_NAME');
      }
      unless ($env->{'SERVER_NAME'} ne '') {
          Carp::croak('SERVER_NAME must not be empty string');
      }
      unless (defined($env->{'SERVER_PORT'})) {
          Carp::croak('missing mandatory env param: SERVER_PORT');
      }
      unless ($env->{'SERVER_PORT'} ne '') {
          Carp::croak('SERVER_PORT must not be empty string');
      }
      unless (!defined($env->{'SERVER_PROTOCOL'}) || $env->{'SERVER_PROTOCOL'} =~ m{^HTTP/1.\d$}) {
          Carp::croak('invalid SERVER_PROTOCOL');
      }
      for my $param (qw/version url_scheme input errors multithread multiprocess/) {
          unless (exists $env->{"psgi.$param"}) {
              Carp::croak("missing psgi.$param");
          }
      }
      unless (ref($env->{'psgi.version'}) eq 'ARRAY') {
          Carp::croak('psgi.version should be ArrayRef');
      }
      unless (scalar(@{$env->{'psgi.version'}}) == 2) {
          Carp::croak('psgi.version should contain 2 elements');
      }
      unless ($env->{'psgi.url_scheme'} =~ /^https?$/) {
          Carp::croak('psgi.version should be "http" or "https"');
      }
      if ($env->{"psgi.version"}->[1] == 1) { # 1.1
          for my $param (qw(streaming nonblocking run_once)) {
              unless (exists $env->{"psgi.$param"}) {
                  Carp::croak("missing psgi.$param");
              }
          }
      }
      if ($env->{HTTP_CONTENT_TYPE}) {
          Carp::croak('HTTP_CONTENT_TYPE should not exist');
      }
      if ($env->{HTTP_CONTENT_LENGTH}) {
          Carp::croak('HTTP_CONTENT_LENGTH should not exist');
      }
  }
  
  sub validate_res {
      my ($self, $res, $streaming) = @_;
  
      my $croak = $streaming ? \&Carp::confess : \&Carp::croak;
  
      unless (ref($res) and ref($res) eq 'ARRAY' || ref($res) eq 'CODE') {
          $croak->('response should be array ref or code ref');
      }
  
      if (ref $res eq 'CODE') {
          return $self->response_cb($res, sub { $self->validate_res(@_, 1) });
      }
  
      unless (@$res == 3 || ($streaming && @$res == 2)) {
          $croak->('response needs to be 3 element array, or 2 element in streaming');
      }
  
      unless ($res->[0] =~ /^\d+$/ && $res->[0] >= 100) {
          $croak->('status code needs to be an integer greater than or equal to 100');
      }
  
      unless (ref $res->[1] eq 'ARRAY') {
          $croak->('Headers needs to be an array ref');
      }
  
      # @$res == 2 is only right in psgi.streaming, and it's already checked.
      unless (@$res == 2 ||
              ref $res->[2] eq 'ARRAY' ||
              Plack::Util::is_real_fh($res->[2]) ||
              (blessed($res->[2]) && $res->[2]->can('getline'))) {
          $croak->('body should be an array ref or filehandle');
      }
  
      if (ref $res->[2] eq 'ARRAY' && grep utf8::is_utf8($_), @{$res->[2]}) {
          $croak->('body must be bytes and should not contain wide characters (UTF-8 strings).');
      }
  
      return $res;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Lint - Validate request and response
  
  =head1 SYNOPSIS
  
    use Plack::Middleware::Lint;
  
    my $app = sub { ... }; # your app or middleware
    $app = Plack::Middleware::Lint->wrap($app);
  
    # Or from plackup
    plackup -e 'enable "Lint"' myapp.psgi
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Lint is a middleware component to validate request
  and response environment formats. You are strongly suggested to use
  this middleware when you develop a new framework adapter or a new PSGI
  web server that implements the PSGI interface.
  
  This middleware is enabled by default when you run plackup or other
  launcher tools with the default environment I<development> value.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  Tokuhiro Matsuno
  
  =head1 SEE ALSO
  
  L<Plack>
  
  =cut
  
PLACK_MIDDLEWARE_LINT

$fatpacked{"Plack/Middleware/Log4perl.pm"} = <<'PLACK_MIDDLEWARE_LOG4PERL';
  package Plack::Middleware::Log4perl;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util::Accessor qw(category logger conf);
  use Carp ();
  
  sub prepare_app {
      my $self = shift;
  
      if ($self->conf) {
          require Log::Log4perl;
          Log::Log4perl::init($self->conf);
      }
  
      $self->logger( Log::Log4perl->get_logger($self->category || '') );
  }
  
  sub call {
      my($self, $env) = @_;
  
      $env->{'psgix.logger'} = sub {
          my $args = shift;
          my $level = $args->{level};
          local $Log::Log4perl::caller_depth
              = $Log::Log4perl::caller_depth + 1;
          $self->logger->$level($args->{message});
      };
  
      $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Log4perl - Uses Log::Log4perl to configure logger
  
  =head1 SYNOPSIS
  
    use Log::Log4perl;
  
    Log::Log4perl::init('/path/to/log4perl.conf');
  
    builder {
        enable "Log4perl", category => "plack";
        $app;
    }
  
    # in log4perl.conf
    log4perl.logger.plack = INFO, Logfile
    log4perl.appender.Logfile = Log::Log4perl::Appender::File
    log4perl.appender.Logfile.filename = /path/to/logfile.log
    log4perl.appender.Logfile.layout   = Log::Log4perl::Layout::SimpleLayout
  
    # Or let middleware to configure log4perl
    enable "Log4perl", category => "plack", conf => '/path/to/log.conf';
  
  =head1 DESCRIPTION
  
  Log4perl is a Plack::Middleware component that allows you to use
  L<Log::Log4perl> to configure logging object.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item category
  
  The log4perl category to send logs to. Defaults to C<''> which means
  it send to the root logger.
  
  =item conf
  
  The configuration file path (or a scalar ref containing the config
  string) for Log::Log4perl to automatically configure.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Log::Dispatch>
  
  =cut
  
PLACK_MIDDLEWARE_LOG4PERL

$fatpacked{"Plack/Middleware/LogDispatch.pm"} = <<'PLACK_MIDDLEWARE_LOGDISPATCH';
  package Plack::Middleware::LogDispatch;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util::Accessor qw(logger);
  use Carp ();
  
  sub prepare_app {
      my $self = shift;
      unless ($self->logger) {
          Carp::croak "logger is not defined";
      }
  }
  
  sub call {
      my($self, $env) = @_;
  
      $env->{'psgix.logger'} = sub {
          my $args = shift;
          $args->{level} = 'critical' if $args->{level} eq 'fatal';
          $self->logger->log(%$args);
      };
  
      $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::LogDispatch - Uses Log::Dispatch to configure logger
  
  =head1 SYNOPSIS
  
    use Log::Dispatch;
  
    my $logger = Log::Dispatch->new;
    $logger->add( Log::Dispatch::File->new(...) );
    $logger->add( Log::Dispatch::DesktopNotification->new(...) );
  
    builder {
        enable "LogDispatch", logger => $logger;
        $app;
    }
  
    # use with Log::Dispatch::Config
    use Log::Dispatch::Config;
    Log::Dispatch::Config->configure('/path/to/log.conf');
  
    builder {
        enable "LogDispatch", logger => Log::Dispatch::Config->instance;
        ...
    }
  
  =head1 DESCRIPTION
  
  LogDispatch is a Plack::Middleware component that allows you to use
  L<Log::Dispatch> to configure logging object.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item logger
  
  Log::Dispatch object to send logs to. Required.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Log::Dispatch>
  
  =cut
  
PLACK_MIDDLEWARE_LOGDISPATCH

$fatpacked{"Plack/Middleware/MethodOverride.pm"} = <<'PLACK_MIDDLEWARE_METHODOVERRIDE';
  package Plack::Middleware::MethodOverride;
  use strict;
  use warnings;
  use parent qw(Plack::Middleware);
  use Plack::Util::Accessor qw( header );
  
  my %allowed_method = map { $_ => 1 } qw( GET HEAD POST PUT DELETE );
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my $key = $self->header || 'X-HTTP-Method-Override';
         $key =~ tr/-/_/;
  
      my $method = $env->{"HTTP_" . uc($key)};
      if (defined $method && $allowed_method{$method}) {
          $env->{REQUEST_METHOD} = $method;
      }
  
      $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::MethodOverride - Overrides HTTP method with X-HTTP-Method-Override header
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    builder {
        enable "Plack::Middleware::MethodOverride";
        $handler;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::MethodOverride allows your application to override
  HTTP request method with the value specified in HTTP header value.
  
  =head1 CONFIGURATIONS
  
  =over 4
  
  =item header
  
     enable "Plack::Middleware::MethodOverride",
         header => 'X-HTTP-Method';
  
  Specifies the HTTP header name to specify the overriding HTTP
  method. Defaults to C<X-HTTP-Method-Override>.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  Based on L<HTTP::Engine::Middleware::MethodOverride>
  
  =head1 SEE ALSO
  
  L<Plack::Middleware>
  
  =cut
PLACK_MIDDLEWARE_METHODOVERRIDE

$fatpacked{"Plack/Middleware/NullLogger.pm"} = <<'PLACK_MIDDLEWARE_NULLLOGGER';
  package Plack::Middleware::NullLogger;
  use strict;
  
  sub call {
      my($self, $env) = @_;
      $env->{'psgix.logger'} = sub { };
      $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::NullLogger - Send logs to /dev/null
  
  =head1 SYNOPSIS
  
    enable "NullLogger";
  
  =head1 DESCRIPTIOM
  
  NullLogger is a middleware component that receives logs and does
  nothing but discarding them. Might be useful to shut up all the logs
  from frameworks in one shot.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_MIDDLEWARE_NULLLOGGER

$fatpacked{"Plack/Middleware/RearrangeHeaders.pm"} = <<'PLACK_MIDDLEWARE_REARRANGEHEADERS';
  package Plack::Middleware::RearrangeHeaders;
  use strict;
  use warnings;
  use parent qw( Plack::Middleware );
  
  use HTTP::Headers;
  
  sub call {
      my $self = shift;
  
      my $res = $self->app->(@_);
      $self->response_cb($res, sub {
          my $res = shift;
  
          my $h = HTTP::Headers->new(@{$res->[1]});
          my @new_headers;
          $h->scan(sub { push @new_headers, @_ });
  
          $res->[1] = \@new_headers;
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::RearrangeHeaders - Reorder HTTP headers for buggy clients
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    my $app = sub {
        return [ 200, [
            'Last-Modified' => 'Wed, 23 Sep 2009 13:36:33 GMT',
            'Content-Type' => 'text/plain',
            'ETag' => 'foo bar',
        ], [ 'Hello Foo' ] ];
    };
  
    builder {
        enable "Plack::Middleware::RearrangeHeaders";
        $app;
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::RearrangeHeaders sorts HTTP headers based on "Good Practice" i.e.:
  
    # "Good Practice" order of HTTP message headers:
    #    - Response-Headers
    #    - Entity-Headers
  
  to work around buggy clients like very old MSIE or broken HTTP proxy
  servers. Most clients today don't (and shouldn't) care about HTTP
  header order but if you're too pedantic or have some environments
  where you need to deal with buggy clients like above, this might be
  useful.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<HTTP::Headers>
  
  =cut
PLACK_MIDDLEWARE_REARRANGEHEADERS

$fatpacked{"Plack/Middleware/Recursive.pm"} = <<'PLACK_MIDDLEWARE_RECURSIVE';
  package Plack::Middleware::Recursive;
  use strict;
  use parent qw(Plack::Middleware);
  
  use Try::Tiny;
  use Scalar::Util qw(blessed);
  
  open my $null_io, "<", \"";
  
  sub call {
      my($self, $env) = @_;
  
      $env->{'plack.recursive.include'} = $self->recurse_callback($env, 1);
  
      my $res = try {
          $self->app->($env);
      } catch {
          if (blessed $_ && $_->isa('Plack::Recursive::ForwardRequest')) {
              return $self->recurse_callback($env)->($_->path);
          }
      };
  
      return $res if ref $res eq 'ARRAY';
  
      return sub {
          my $respond = shift;
  
          my $writer;
          try {
              $res->(sub { return $writer = $respond->(@_) });
          } catch {
              if (!$writer && blessed $_ && $_->isa('Plack::Recursive::ForwardRequest')) {
                  $res = $self->recurse_callback($env)->($_->path);
                  return ref $res eq 'CODE' ? $res->($respond) : $respond->($res);
              } else {
                  die $_;
              }
          };
      };
  }
  
  sub recurse_callback {
      my($self, $env, $include) = @_;
  
      my $old_path_info = $env->{PATH_INFO};
  
      return sub {
          my $new_path_info = shift;
          my($path, $query) = split /\?/, $new_path_info, 2;
  
          Scalar::Util::weaken($env);
  
          $env->{PATH_INFO}      = $path;
          $env->{QUERY_STRING}   = $query;
          $env->{REQUEST_METHOD} = 'GET';
          $env->{CONTENT_LENGTH} = 0;
          $env->{CONTENT_TYPE}   = '';
          $env->{'psgi.input'}   = $null_io;
          push @{$env->{'plack.recursive.old_path_info'}}, $old_path_info;
  
          $include ? $self->app->($env) : $self->call($env);
      };
  }
  
  package Plack::Recursive::ForwardRequest;
  use overload q("") => \&as_string, fallback => 1;
  
  sub new {
      my($class, $path) = @_;
      bless { path => $path }, $class;
  }
  
  sub path { $_[0]->{path} }
  
  sub throw {
      my($class, @args) = @_;
      die $class->new(@args);
  }
  
  sub as_string {
      my $self = shift;
      return "Forwarding to $self->{path}: Your application should be wrapped with Plack::Middleware::Recursive.";
  }
  
  package Plack::Middleware::Recursive;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Recursive - Allows PSGI apps to include or forward requests recursively
  
  =head1 SYNOPSIS
  
    # with Builder
    enable "Recursive";
  
    # in apps
    my $res = $env->{'plack.recursive.include'}->("/new_path");
  
    # Or, use exceptions
    my $app = sub {
        # ...
        Plack::Recursive::ForwardRequest->throw("/new_path");
    };
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Recursive allows PSGI applications to recursively
  include or forward requests to other paths. Applications can make use
  of callbacks stored in C<< $env->{'plack.recursive.include'} >> to
  I<include> another path to get the response (whether it's an array ref
  or a code ref depending on your application), or throw an exception
  Plack::Recursive::ForwardRequest anywhere in the code to I<forward>
  the current request (i.e. abort the current and redo the request).
  
  =head1 AUTHORS
  
  Tatsuhiko Miyagawa
  
  Masahiro Honma
  
  =head1 SEE ALSO
  
  L<Plack> L<Plack::Middleware::HTTPExceptions>
  
  The idea, code and interface are stolen from Rack::Recursive and paste.recursive.
  
  =cut
  
  
PLACK_MIDDLEWARE_RECURSIVE

$fatpacked{"Plack/Middleware/Refresh.pm"} = <<'PLACK_MIDDLEWARE_REFRESH';
  package Plack::Middleware::Refresh;
  use strict;
  use parent qw(Plack::Middleware);
  use Module::Refresh;
  use Plack::Util::Accessor qw(last cooldown);
  
  sub prepare_app {
      my $self = shift;
      $self->cooldown(10) unless defined $self->cooldown;
  
      Module::Refresh->new;
      $self->last(time - $self->cooldown);
  }
  
  sub call {
      my($self, $env) = @_;
  
      if (time > $self->last + $self->cooldown) {
          Module::Refresh->refresh;
          $self->last(time);
      }
  
      $self->app->($env);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Refresh - Refresh all modules in %INC
  
  =head1 SYNOPSIS
  
    enable "Refresh", cooldown => 3;
    $app;
  
  =head1 DESCRIPTION
  
  This is I<yet another> approach to refresh modules in C<%INC> during
  the development cycle, without the need to have a forking process to
  watch for filesystem updates. This middleware, in a request time,
  compares the last refresh time and the current time and if the
  difference is bigger than I<cooldown> seconds which defaults to 10,
  call L<Module::Refresh> to reload all Perl modules in C<%INC> if the
  files have been modified.
  
  Note that this only reloads modules and not other files such as
  templates.
  
  This middleware is quite similar to what Rack::Reoader does. If you
  have issues with this reloading technique, for instance when you have
  in-file templates that needs to be recompiled, or Moose classes that
  has C<make_immutable>, take a look at L<plackup>'s default -r option
  or L<Plack::Loader::Shotgun> instead.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Module::Refresh> Rack::Reloader
  
  =cut
  
PLACK_MIDDLEWARE_REFRESH

$fatpacked{"Plack/Middleware/Runtime.pm"} = <<'PLACK_MIDDLEWARE_RUNTIME';
  package Plack::Middleware::Runtime;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util;
  use Plack::Util::Accessor qw(header_name);
  use Time::HiRes;
  
  sub call {
      my($self, $env) = @_;
  
      my $start = [ Time::HiRes::gettimeofday ];
      my $res = $self->app->($env);
  
      $self->response_cb($res, sub {
          my $res = shift;
          my $req_time = sprintf '%.6f', Time::HiRes::tv_interval($start);
          Plack::Util::header_set($res->[1], 'X-Runtime', $req_time);
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Runtime - Sets an X-Runtime response header
  
  =head1 SYNOPSIS
  
    enable "Runtime";
  
  =head1 DESCRIPTION
  
  Plack::Middleware::Runtime is a Plack middleware component that sets
  application's response time, in seconds to I<X-Runtime> HTTP response
  header.
  
  =head1 OPTIONS
  
  =over 4
  
  =item header_name
  
  Name of the header. Defaults to I<X-Runtime>.
  
  =back
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Time::HiRes> Rack::Runtime
  
  =cut
PLACK_MIDDLEWARE_RUNTIME

$fatpacked{"Plack/Middleware/SimpleContentFilter.pm"} = <<'PLACK_MIDDLEWARE_SIMPLECONTENTFILTER';
  package Plack::Middleware::SimpleContentFilter;
  use strict;
  use warnings;
  use parent qw( Plack::Middleware );
  
  use Plack::Util;
  use Plack::Util::Accessor qw( filter );
  
  sub call {
      my $self = shift;
  
      my $res = $self->app->(@_);
      $self->response_cb($res, sub {
          my $res = shift;
          my $h = Plack::Util::headers($res->[1]);
          if ($h->get('Content-Type') =~ m!^text/!) {
              return sub {
                  my $chunk = shift;
                  return unless defined $chunk;
                  local $_ = $chunk;
                  $self->filter->();
                  return $_;
              };
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::SimpleContentFilter - Filters response content
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    my $app = sub {
        return [ 200, [ 'Content-Type' => 'text/plain' ], [ 'Hello Foo' ] ];
    };
  
    builder {
        enable "Plack::Middleware::SimpleContentFilter",
            filter => sub { s/Foo/Bar/g; };
        $app;
    };
  
  =head1 DESCRIPTION
  
  B<This middleware should be considered as a demo. Running this against
  your application might break your HTML unless you code the filter
  callback carefully>.
  
  Plack::Middleware::SimpleContentFilter is a simple content text filter
  to run against response body. This middleware is only enabled against
  responses with C<text/*> Content-Type.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_MIDDLEWARE_SIMPLECONTENTFILTER

$fatpacked{"Plack/Middleware/SimpleLogger.pm"} = <<'PLACK_MIDDLEWARE_SIMPLELOGGER';
  package Plack::Middleware::SimpleLogger;
  use strict;
  use parent qw(Plack::Middleware);
  use Plack::Util::Accessor qw(level);
  use POSIX;
  
  # Should this be in Plack::Util?
  my $i = 0;
  my %level_numbers = map { $_ => $i++ } qw(debug info warn error fatal);
  
  sub call {
      my($self, $env) = @_;
  
      my $min = $level_numbers{ $self->level || "debug" };
  
      $env->{'psgix.logger'} = sub {
          my $args = shift;
  
          if ($level_numbers{$args->{level}} >= $min) {
              $env->{'psgi.errors'}->print($self->format_message($args->{level}, $args->{message}));
          }
      };
  
      $self->app->($env);
  }
  
  sub format_time {
      my $old_locale = POSIX::setlocale(&POSIX::LC_ALL);
      POSIX::setlocale(&POSIX::LC_ALL, 'en');
      my $out = POSIX::strftime(@_);
      POSIX::setlocale(&POSIX::LC_ALL, $old_locale);
      return $out;
  }
  
  sub format_message {
      my($self, $level, $message) = @_;
  
      my $time = format_time("%Y-%m-%dT%H:%M:%S", localtime);
      sprintf "%s [%s #%d] %s: %s\n", uc substr($level, 0, 1), $time, $$, uc $level, $message;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::SimpleLogger - Simple logger that prints to psgi.errors
  
  =head1 SYNOPSIS
  
    enable "SimpleLogger", level => "warn";
  
  =head1 DESCRIPTION
  
  SimpleLogger is a middleware component that formats the log message
  with information such as the time and PID and prints them to
  I<psgi.errors> stream, which is mostly STDERR or server log output.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_MIDDLEWARE_SIMPLELOGGER

$fatpacked{"Plack/Middleware/StackTrace.pm"} = <<'PLACK_MIDDLEWARE_STACKTRACE';
  package Plack::Middleware::StackTrace;
  use strict;
  use warnings;
  use parent qw/Plack::Middleware/;
  use Devel::StackTrace;
  use Devel::StackTrace::AsHTML;
  use Try::Tiny;
  use Plack::Util::Accessor qw( force no_print_errors );
  
  our $StackTraceClass = "Devel::StackTrace";
  
  # Optional since it needs PadWalker
  if ($ENV{PLACK_STACKTRACE_LEXICALS} && try { require Devel::StackTrace::WithLexicals; 1 }) {
      $StackTraceClass = "Devel::StackTrace::WithLexicals";
  }
  
  sub call {
      my($self, $env) = @_;
  
      my $trace;
      local $SIG{__DIE__} = sub {
          $trace = $StackTraceClass->new;
          die @_;
      };
  
      my $caught;
      my $res = try { $self->app->($env) } catch { $caught = $_ };
  
      if ($trace && ($caught || ($self->force && ref $res eq 'ARRAY' && $res->[0] == 500)) ) {
          my $text = trace_as_string($trace);
          $env->{'psgi.errors'}->print($text) unless $self->no_print_errors;
          if (($env->{HTTP_ACCEPT} || '*/*') =~ /html/) {
              $res = [500, ['Content-Type' => 'text/html; charset=utf-8'], [ utf8_safe($trace->as_html) ]];
          } else {
              $res = [500, ['Content-Type' => 'text/plain; charset=utf-8'], [ utf8_safe($text) ]];
          }
      }
  
      # break $trace here since $SIG{__DIE__} holds the ref to it, and
      # $trace has refs to Standalone.pm's args ($conn etc.) and
      # prevents garbage collection to be happening.
      undef $trace;
  
      return $res;
  }
  
  sub trace_as_string {
      my $trace = shift;
  
      my $st = '';
      my $first = 1;
      foreach my $f ( $trace->frames() ) {
          $st .= "\t" unless $first;
          $st .= $f->as_string($first) . "\n";
          $first = 0;
      }
  
      return $st;
  
  }
  
  sub utf8_safe {
      my $str = shift;
  
      # NOTE: I know messing with utf8:: in the code is WRONG, but
      # because we're running someone else's code that we can't
      # guarnatee which encoding an exception is encoded, there's no
      # better way than doing this. The latest Devel::StackTrace::AsHTML
      # (0.08 or later) encodes high-bit chars as HTML entities, so this
      # path won't be executed.
      if (utf8::is_utf8($str)) {
          utf8::encode($str);
      }
  
      $str;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::StackTrace - Displays stack trace when your app dies
  
  =head1 SYNOPSIS
  
    enable "StackTrace";
  
  =head1 DESCRIPTION
  
  This middleware catches exceptions (run-time errors) happening in your
  application and displays nice stack trace screen.
  
  This middleware is enabled by default when you run L<plackup> in the
  default I<development> mode.
  
  You're recommended to use this middleware during the development and
  use L<Plack::Middleware::HTTPExceptions> in the deployment mode as a
  replacement, so that all the exceptions thrown from your application
  still get caught and rendered as a 500 error response, rather than
  crashing the web server.
  
  Catching errors in streaming response is not supported.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item force
  
    enable "StackTrace", force => 1;
  
  Force display the stack trace when an error occurs within your
  application and the response code from your application is
  500. Defaults to off.
  
  The use case of this option is that when your framework catches all
  the exceptions in the main handler and returns all failures in your
  code as a normal 500 PSGI error response. In such cases, this
  middleware would never have a chance to display errors because it
  can't tell if it's an application error or just random C<eval> in your
  code. This option enforces the middleware to display stack trace even
  if it's not the direct error thrown by the application.
  
  =item no_print_errors
  
    enable "StackTrace", no_print_errors => 1;
  
  Skips printing the text stacktrace to console
  (C<psgi.errors>). Defaults to 0, which means the text version of the
  stack trace error is printed to the errors handle, which usually is a
  standard error.
  
  =back
  
  =head1 AUTHOR
  
  Tokuhiro Matsuno
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Devel::StackTrace::AsHTML> L<Plack::Middleware> L<Plack::Middleware::HTTPExceptions>
  
  =cut
  
PLACK_MIDDLEWARE_STACKTRACE

$fatpacked{"Plack/Middleware/Static.pm"} = <<'PLACK_MIDDLEWARE_STATIC';
  package Plack::Middleware::Static;
  use strict;
  use warnings;
  use parent qw/Plack::Middleware/;
  use Plack::App::File;
  
  use Plack::Util::Accessor qw( path root encoding );
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my $res = $self->_handle_static($env);
      return $res if $res;
  
      return $self->app->($env);
  }
  
  sub _handle_static {
      my($self, $env) = @_;
  
      my $path_match = $self->path or return;
      my $path = $env->{PATH_INFO};
  
      for ($path) {
          my $matched = 'CODE' eq ref $path_match ? $path_match->($_) : $_ =~ $path_match;
          return unless $matched;
      }
  
      $self->{file} ||= Plack::App::File->new({ root => $self->root || '.', encoding => $self->encoding });
      local $env->{PATH_INFO} = $path; # rewrite PATH
      return $self->{file}->call($env);
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Static - serve static files with Plack
  
  =head1 SYNOPSIS
  
    use Plack::Builder;
  
    builder {
        enable "Plack::Middleware::Static",
            path => qr{^/(images|js|css)/}, root => './htdocs/';
        $app;
    };
  
  =head1 DESCRIPTION
  
  Enable this middleware to allow your Plack-based application to serve static
  files. If a static file exists for the requested path, it will be served.
  Otherwise, the request will be passed on to the application for further
  processing.
  
  If the requested document is not within the C<root> (i.e. directory
  traversal) or the file is there but not readable, this middleware will
  return a 403 Forbidden response.
  
  The content type returned will be determined from the file extension
  based on L<Plack::MIME>.
  
  =head1 CONFIGURATIONS
  
  =over 4
  
  =item path, root
  
    enable "Plack::Middleware::Static",
        path => qr{^/static/}, root => 'htdocs/';
  
  C<path> specifies the URL pattern (regular expression) or a callback
  to match with requests to serve static files for. C<root> specifies
  the root directory to serve those static files from. The default value
  of C<root> is the current directory.
  
  This examples configuration serves C</static/foo.jpg> from
  C<htdocs/static/foo.jpg>. Note that the matched C</static/> portion is
  still appears in the local mapped path. If you don't like it, use a
  callback instead to munge C<$_>:
  
    enable "Plack::Middleware::Static",
        path => sub { s!^/static/!! }, root => 'static-files/';
  
  This configuration would serve C</static/foo.png> from
  C<static-files/foo.png> (not C<static-files/static/foo.png>). The
  callback specified in C<path> option matches against C<$_> and then
  updates the value since it does s///, and returns the number of
  matches, so it will pass through when C</static/> doesn't match.
  
  If you want to map multiple static directories from different root,
  simply add "this", middleware multiple times with different
  configuration options.
  
  =back
  
  =head1 AUTHOR
  
  Tokuhiro Matsuno, Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Middleware> L<Plack::Builder>
  
  =cut
  
  
PLACK_MIDDLEWARE_STATIC

$fatpacked{"Plack/Middleware/Writer.pm"} = <<'PLACK_MIDDLEWARE_WRITER';
  package Plack::Middleware::Writer;
  use strict;
  use parent qw(Plack::Middleware::BufferedStreaming);
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::Writer - DEPRECATED
  
  =head1 SEE ALSO
  
  L<Plack::Middleware::BufferedStreaming>
  
  =cut
PLACK_MIDDLEWARE_WRITER

$fatpacked{"Plack/Middleware/XFramework.pm"} = <<'PLACK_MIDDLEWARE_XFRAMEWORK';
  package Plack::Middleware::XFramework;
  use strict;
  use warnings;
  use parent qw/Plack::Middleware/;
  
  use Plack::Util;
  use Plack::Util::Accessor qw( framework );
  
  sub call {
      my $self = shift;
  
      my $res = $self->app->( @_ );
      $self->response_cb($res, sub {
          my $res = shift;
          if ($self->framework) {
              Plack::Util::header_set $res->[1], 'X-Framework' => $self->framework;
          }
      });
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::XFramework - Sample middleware to add X-Framework
  
  =head1 SYNOPSIS
  
    enable "Plack::Middleware::XFramework", framework => "Catalyst";
  
  =head1 DESCRIPTION
  
  This middleware adds C<X-Framework> header to the HTTP response.
  
  =head1 CONFIGURATION
  
  =over 4
  
  =item framework
  
  Sets the string value of C<X-Framework> header. If not set, the header is not set to the response.
  
  =back
  
  =head1 SEE ALSO
  
  L<Plack::Middleware>
  
  =cut
  
PLACK_MIDDLEWARE_XFRAMEWORK

$fatpacked{"Plack/Middleware/XSendfile.pm"} = <<'PLACK_MIDDLEWARE_XSENDFILE';
  package Plack::Middleware::XSendfile;
  use strict;
  use warnings;
  use parent qw(Plack::Middleware);
  
  use Plack::Util;
  use Scalar::Util;
  use Plack::Util::Accessor qw( variation );
  
  sub call {
      my $self = shift;
      my $env  = shift;
  
      my $res = $self->app->($env);
      $self->response_cb($res, sub {
          my $res = shift;
          my($status, $headers, $body) = @$res;
          return unless defined $body;
  
          if (Scalar::Util::blessed($body) && $body->can('path')) {
              my $type = $self->_variation($env) || '';
              my $h = Plack::Util::headers($headers);
              if ($type && !$h->exists($type)) {
                  if ($type eq 'X-Accel-Redirect') {
                      my $path = $body->path;
                      my $url = $self->map_accel_path($env, $path);
                      $h->set($type => $url) if $url;
                      $body = [];
                  } elsif ($type eq 'X-Sendfile' or $type eq 'X-Lighttpd-Send-File') {
                      my $path = $body->path;
                      $h->set($type => $path) if defined $path;
                      $body = [];
                  } else {
                      $env->{'psgi.errors'}->print("Unknown x-sendfile variation: $type");
                  }
              }
          }
  
          @$res = ( $status, $headers, $body );
      });
  }
  
  sub map_accel_path {
      my($self, $env, $path) = @_;
  
      if (my $mapping = $env->{HTTP_X_ACCEL_MAPPING}) {
          my($internal, $external) = split /=/, $mapping, 2;
          $path =~ s!^\Q$internal\E!$external!i;
      }
  
      return $path;
  }
  
  sub _variation {
      my($self, $env) = @_;
      $self->variation || $env->{'plack.xsendfile.type'} || $env->{HTTP_X_SENDFILE_TYPE};
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Middleware::XSendfile - Sets X-Sendfile (or a like) header for frontends
  
  =head1 SYNOPSIS
  
    enable "Plack::Middleware::XSendfile";
  
  =head1 DESCRIPTION
  
  You should use L<IO::File::WithPath> or L<Plack::Util>'s
  C<set_io_path> to add C<path> method to an IO object in the body.
  
  See L<http://github.com/rtomayko/rack-contrib/blob/master/lib/rack/sendfile.rb>
  for the frontend configuration.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_MIDDLEWARE_XSENDFILE

$fatpacked{"Plack/Request.pm"} = <<'PLACK_REQUEST';
  package Plack::Request;
  use strict;
  use warnings;
  use 5.008_001;
  our $VERSION = '0.9938';
  $VERSION = eval $VERSION;
  
  use HTTP::Headers;
  use Carp ();
  use Hash::MultiValue;
  use HTTP::Body;
  
  use Plack::Request::Upload;
  use Plack::TempBuffer;
  use URI;
  use URI::Escape ();
  
  sub _deprecated {
      my $alt = shift;
      my $method = (caller(1))[3];
      Carp::carp("$method is deprecated. Use '$alt' instead.");
  }
  
  sub new {
      my($class, $env) = @_;
      Carp::croak(q{$env is required})
          unless defined $env && ref($env) eq 'HASH';
  
      bless { env => $env }, $class;
  }
  
  sub env { $_[0]->{env} }
  
  sub address     { $_[0]->env->{REMOTE_ADDR} }
  sub remote_host { $_[0]->env->{REMOTE_HOST} }
  sub protocol    { $_[0]->env->{SERVER_PROTOCOL} }
  sub method      { $_[0]->env->{REQUEST_METHOD} }
  sub port        { $_[0]->env->{SERVER_PORT} }
  sub user        { $_[0]->env->{REMOTE_USER} }
  sub request_uri { $_[0]->env->{REQUEST_URI} }
  sub path_info   { $_[0]->env->{PATH_INFO} }
  sub path        { $_[0]->env->{PATH_INFO} || '/' }
  sub script_name { $_[0]->env->{SCRIPT_NAME} }
  sub scheme      { $_[0]->env->{'psgi.url_scheme'} }
  sub secure      { $_[0]->scheme eq 'https' }
  sub body        { $_[0]->env->{'psgi.input'} }
  sub input       { $_[0]->env->{'psgi.input'} }
  
  sub content_length   { $_[0]->env->{CONTENT_LENGTH} }
  sub content_type     { $_[0]->env->{CONTENT_TYPE} }
  
  sub session         { $_[0]->env->{'psgix.session'} }
  sub session_options { $_[0]->env->{'psgix.session.options'} }
  sub logger          { $_[0]->env->{'psgix.logger'} }
  
  sub cookies {
      my $self = shift;
  
      return {} unless $self->env->{HTTP_COOKIE};
  
      # HTTP_COOKIE hasn't changed: reuse the parsed cookie
      if (   $self->env->{'plack.cookie.parsed'}
          && $self->env->{'plack.cookie.string'} eq $self->env->{HTTP_COOKIE}) {
          return $self->env->{'plack.cookie.parsed'};
      }
  
      $self->env->{'plack.cookie.string'} = $self->env->{HTTP_COOKIE};
  
      my %results;
      my @pairs = split "[;,] ?", $self->env->{'plack.cookie.string'};
      for my $pair ( @pairs ) {
          # trim leading trailing whitespace
          $pair =~ s/^\s+//; $pair =~ s/\s+$//;
  
          my ($key, $value) = map URI::Escape::uri_unescape($_), split( "=", $pair, 2 );
  
          # Take the first one like CGI.pm or rack do
          $results{$key} = $value unless exists $results{$key};
      }
  
      $self->env->{'plack.cookie.parsed'} = \%results;
  }
  
  sub query_parameters {
      my $self = shift;
      $self->env->{'plack.request.query'} ||= Hash::MultiValue->new($self->uri->query_form);
  }
  
  sub content {
      my $self = shift;
  
      unless ($self->env->{'psgix.input.buffered'}) {
          $self->_parse_request_body;
      }
  
      my $fh = $self->input                 or return '';
      my $cl = $self->env->{CONTENT_LENGTH} or return'';
      $fh->read(my($content), $cl, 0);
      $fh->seek(0, 0);
  
      return $content;
  }
  
  sub raw_body { $_[0]->content }
  
  # XXX you can mutate headers with ->headers but it's not written through to the env
  
  sub headers {
      my $self = shift;
      if (!defined $self->{headers}) {
          my $env = $self->env;
          $self->{headers} = HTTP::Headers->new(
              map {
                  (my $field = $_) =~ s/^HTTPS?_//;
                  ( $field => $env->{$_} );
              }
                  grep { /^(?:HTTP|CONTENT|COOKIE)/i } keys %$env
              );
      }
      $self->{headers};
  }
  
  sub content_encoding { shift->headers->content_encoding(@_) }
  sub header           { shift->headers->header(@_) }
  sub referer          { shift->headers->referer(@_) }
  sub user_agent       { shift->headers->user_agent(@_) }
  
  sub body_parameters {
      my $self = shift;
  
      unless ($self->env->{'plack.request.body'}) {
          $self->_parse_request_body;
      }
  
      return $self->env->{'plack.request.body'};
  }
  
  # contains body + query
  sub parameters {
      my $self = shift;
  
      $self->env->{'plack.request.merged'} ||= do {
          my $query = $self->query_parameters;
          my $body  = $self->body_parameters;
          Hash::MultiValue->new($query->flatten, $body->flatten);
      };
  }
  
  sub uploads {
      my $self = shift;
  
      if ($self->env->{'plack.request.upload'}) {
          return $self->env->{'plack.request.upload'};
      }
  
      $self->_parse_request_body;
      return $self->env->{'plack.request.upload'};
  }
  
  sub hostname     { _deprecated 'remote_host';      $_[0]->remote_host || $_[0]->address }
  sub url_scheme   { _deprecated 'scheme';           $_[0]->scheme }
  sub params       { _deprecated 'parameters';       shift->parameters(@_) }
  sub query_params { _deprecated 'query_parameters'; shift->query_parameters(@_) }
  sub body_params  { _deprecated 'body_parameters';  shift->body_parameters(@_) }
  
  sub cookie {
      my $self = shift;
      _deprecated 'cookies';
  
      return keys %{ $self->cookies } if @_ == 0;
  
      my $name = shift;
      return $self->cookies->{$name};
  }
  
  sub param {
      my $self = shift;
  
      return keys %{ $self->parameters } if @_ == 0;
  
      my $key = shift;
      return $self->parameters->{$key} unless wantarray;
      return $self->parameters->get_all($key);
  }
  
  sub upload {
      my $self = shift;
  
      return keys %{ $self->uploads } if @_ == 0;
  
      my $key = shift;
      return $self->uploads->{$key} unless wantarray;
      return $self->uploads->get_all($key);
  }
  
  sub raw_uri {
      my $self = shift;
      _deprecated 'base';
  
      my $base = $self->base;
      $base->path_query($self->env->{REQUEST_URI});
  
      $base;
  }
  
  sub uri {
      my $self = shift;
  
      my $base = $self->_uri_base;
  
      my $path = $self->env->{PATH_INFO} || '';
      $path .= '?' . $self->env->{QUERY_STRING}
          if defined $self->env->{QUERY_STRING} && $self->env->{QUERY_STRING} ne '';
  
      $base =~ s!/$!! if $path =~ m!^/!;
  
      return URI->new($base . $path)->canonical;
  }
  
  sub base {
      my $self = shift;
      URI->new($self->_uri_base)->canonical;
  }
  
  sub _uri_base {
      my $self = shift;
  
      my $env = $self->env;
  
      my $uri = ($env->{'psgi.url_scheme'} || "http") .
          "://" .
          ($env->{HTTP_HOST} || (($env->{SERVER_NAME} || "") . ":" . ($env->{SERVER_PORT} || 80))) .
          ($env->{SCRIPT_NAME} || '/');
  
      return $uri;
  }
  
  sub new_response {
      my $self = shift;
      require Plack::Response;
      Plack::Response->new(@_);
  }
  
  sub _parse_request_body {
      my $self = shift;
  
      my $ct = $self->env->{CONTENT_TYPE};
      my $cl = $self->env->{CONTENT_LENGTH};
      if (!$ct && !$cl) {
          # No Content-Type nor Content-Length -> GET/HEAD
          $self->env->{'plack.request.body'}   = Hash::MultiValue->new;
          $self->env->{'plack.request.upload'} = Hash::MultiValue->new;
          return;
      }
  
      my $body = HTTP::Body->new($ct, $cl);
  
      my $input = $self->input;
  
      my $buffer;
      if ($self->env->{'psgix.input.buffered'}) {
          # Just in case if input is read by middleware/apps beforehand
          $input->seek(0, 0);
      } else {
          $buffer = Plack::TempBuffer->new($cl);
      }
  
      my $spin = 0;
      while ($cl) {
          $input->read(my $chunk, $cl < 8192 ? $cl : 8192);
          my $read = length $chunk;
          $cl -= $read;
          $body->add($chunk);
          $buffer->print($chunk) if $buffer;
  
          if ($read == 0 && $spin++ > 2000) {
              Carp::croak "Bad Content-Length: maybe client disconnect? ($cl bytes remaining)";
          }
      }
  
      if ($buffer) {
          $self->env->{'psgix.input.buffered'} = 1;
          $self->env->{'psgi.input'} = $buffer->rewind;
      } else {
          $input->seek(0, 0);
      }
  
      $self->env->{'plack.request.body'}   = Hash::MultiValue->from_mixed($body->param);
  
      my @uploads = Hash::MultiValue->from_mixed($body->upload)->flatten;
      my @obj;
      while (my($k, $v) = splice @uploads, 0, 2) {
          push @obj, $k, $self->_make_upload($v);
      }
  
      $self->env->{'plack.request.upload'} = Hash::MultiValue->new(@obj);
  
      1;
  }
  
  sub _make_upload {
      my($self, $upload) = @_;
      Plack::Request::Upload->new(
          headers => HTTP::Headers->new( %{delete $upload->{headers}} ),
          %$upload,
      );
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Request - Portable HTTP request object from PSGI env hash
  
  =head1 SYNOPSIS
  
    use Plack::Request;
  
    my $app_or_middleware = sub {
        my $env = shift; # PSGI env
  
        my $req = Plack::Request->new($env);
  
        my $path_info = $req->path_info;
        my $query     = $req->param('query');
  
        my $res = $req->new_response(200); # new Plack::Response
        $res->finalize;
    };
  
  =head1 DESCRIPTION
  
  L<Plack::Request> provides a consistent API for request objects across
  web server environments.
  
  =head1 CAVEAT
  
  Note that this module is intended to be used by Plack middleware
  developers and web application framework developers rather than
  application developers (end users).
  
  Writing your web application directly using Plack::Request is
  certainly possible but not recommended: it's like doing so with
  mod_perl's Apache::Request: yet too low level.
  
  If you're writing a web application, not a framework, then you're
  encouraged to use one of the web application frameworks that support
  PSGI, or see L<Piglet> or L<HTTP::Engine> to provide higher level
  Request and Response API on top of PSGI.
  
  =head1 METHODS
  
  Some of the methods defined in the earlier versions are deprecated in
  version 1.00. Take a look at L</"INCOMPATIBILITIES">.
  
  Unless otherwise noted, all methods and attributes are B<read-only>,
  and passing values to the method like an accessor doesn't work like
  you expect it to.
  
  =head2 new
  
      Plack::Request->new( $env );
  
  Creates a new request object.
  
  =head1 ATTRIBUTES
  
  =over 4
  
  =item env
  
  Returns the shared PSGI environment hash reference. This is a
  reference, so writing to this environment passes through during the
  whole PSGI request/response cycle.
  
  =item address
  
  Returns the IP address of the client (C<REMOTE_ADDR>).
  
  =item remote_host
  
  Returns the remote host (C<REMOTE_HOST>) of the client. It may be
  empty, in which case you have to get the IP address using C<address>
  method and resolve by your own.
  
  =item method
  
  Contains the request method (C<GET>, C<POST>, C<HEAD>, etc).
  
  =item protocol
  
  Returns the protocol (HTTP/1.0 or HTTP/1.1) used for the current request.
  
  =item request_uri
  
  Returns the raw, undecoded request URI path. You probably do B<NOT>
  want to use this to dispatch requests.
  
  =item path_info
  
  Returns B<PATH_INFO> in the environment. Use this to get the local
  path for the requests.
  
  =item path
  
  Similar to C<path_info> but returns C</> in case it is empty. In other
  words, it returns the virtual path of the request URI after C<<
  $req->base >>. See L</"DISPATCHING"> for details.
  
  =item script_name
  
  Returns B<SCRIPT_NAME> in the environment. This is the absolute path
  where your application is hosted.
  
  =item scheme
  
  Returns the scheme (C<http> or C<https>) of the request.
  
  =item secure
  
  Returns true or false, indicating whether the connection is secure (https).
  
  =item body, input
  
  Returns C<psgi.input> handle.
  
  =item session
  
  Returns (optional) C<psgix.session> hash. When it exists, you can
  retrieve and store per-session data from and to this hash.
  
  =item session_options
  
  Returns (optional) C<psgix.session.options> hash.
  
  =item logger
  
  Returns (optional) C<psgix.logger> code reference. When it exists,
  your application is supposed to send the log message to this logger,
  using:
  
    $req->logger->({ level => 'debug', message => "This is a debug message" });
  
  =item cookies
  
  Returns a reference to a hash containing the cookies. Values are
  strings that are sent by clients and are URI decoded.
  
  =item query_parameters
  
  Returns a reference to a hash containing query string (GET)
  parameters. This hash reference is L<Hash::MultiValue> object.
  
  =item body_parameters
  
  Returns a reference to a hash containing posted parameters in the
  request body (POST). Similarly to C<query_parameters>, the hash
  reference is a L<Hash::MultiValue> object.
  
  =item parameters
  
  Returns a L<Hash::MultiValue> hash reference containing (merged) GET
  and POST parameters.
  
  =item content, raw_body
  
  Returns the request content in an undecoded byte string for POST requests.
  
  =item uri
  
  Returns an URI object for the current request. The URI is constructed
  using various environment values such as C<SCRIPT_NAME>, C<PATH_INFO>,
  C<QUERY_STRING>, C<HTTP_HOST>, C<SERVER_NAME> and C<SERVER_PORT>.
  
  Every time this method is called it returns a new, cloned URI object.
  
  =item base
  
  Returns an URI object for the base path of current request. This is
  like C<uri> but only contains up to C<SCRIPT_NAME> where your
  application is hosted at.
  
  Every time this method is called it returns a new, cloned URI object.
  
  =item user
  
  Returns C<REMOTE_USER> if it's set.
  
  =item headers
  
  Returns an L<HTTP::Headers> object containing the headers for the current request.
  
  =item uploads
  
  Returns a reference to a hash containing uploads. The hash reference
  is L<Hash::MultiValue> object and values are L<Plack::Request::Upload>
  objects.
  
  =item content_encoding
  
  Shortcut to $req->headers->content_encoding.
  
  =item content_length
  
  Shortcut to $req->headers->content_length.
  
  =item content_type
  
  Shortcut to $req->headers->content_type.
  
  =item header
  
  Shortcut to $req->headers->header.
  
  =item referer
  
  Shortcut to $req->headers->referer.
  
  =item user_agent
  
  Shortcut to $req->headers->user_agent.
  
  =item param
  
  Returns GET and POST parameters with a CGI.pm-compatible param
  method. This is an alternative method for accessing parameters in
  $req->parameters.
  
      $value  = $req->param( 'foo' );
      @values = $req->param( 'foo' );
      @params = $req->param;
  
  =item upload
  
  A convenient method to access $req->uploads.
  
      $upload  = $req->upload('field');
      @uploads = $req->upload('field');
      @fields  = $req->upload;
  
      for my $upload ( $req->upload('field') ) {
          print $upload->filename;
      }
  
  =item new_response
  
    my $res = $req->new_response;
  
  Creates a new L<Plack::Response> object. Handy to remove dependency on
  L<Plack::Response> in your code for easy subclassing and duck typing
  in web application frameworks, as well as overriding Response
  generation in middlewares.
  
  =back
  
  =head2 Hash::MultiValue parameters
  
  Parameters that can take one or multiple values i.e. C<parameters>,
  C<query_parameters>, C<body_parameters> and C<uploads> store those
  hash reference as a L<Hash::MultiValue> object. This means you can use
  the hash reference as a plain hash where values are B<always> scalars
  (B<NOT> array reference), so you don't need to code ugly and unsafe
  C<< ref ... eq 'ARRAY' >> anymore.
  
  And if you explicitly want to get multiple values of the same key, you
  can call the method on it, such as:
  
    my @foo = $req->query_parameters->get_all('foo');
  
  You can also call C<get_one> to always get one parameter independent
  of the context (unlike C<param>), and eve call C<mixed> (with
  Hash::MultiValue 0.05 or later) to get the I<traditional> hash
  reference,
  
    my $params = $req->prameters->mixed;
  
  where values are either a scalar or an array reference depending on
  input, so it might be useful if you already have the code to deal with
  that ugliness.
  
  =head2 PARSING POST BODY and MULTIPLE OBJECTS
  
  The methods to parse request body (C<content>, C<body_parameters> and
  C<uploads>) are carefully coded to save the parsed body in the
  environment hash as well as in the temporary buffer, so you can call
  them multiple times and create Plack::Request objects multiple times
  in a request and they should work safely, and won't parse request body
  more than twice for the efficiency.
  
  =head1 DISPATCHING
  
  If your application or framework wants to dispatch (or route) actions
  based on request paths, be sure to use C<< $req->path_info >> not C<<
  $req->uri->path >>.
  
  It is because C<path_info> gives you the virtual path of the request,
  regardless of how your application is mounted. If your application is
  hosted with mod_perl or CGI scripts, or even multiplexed with tools
  like L<Plack::App::URLMap>, request's C<path_info> always gives you
  the action path.
  
  Note that C<path_info> might give you an empty string, in which case
  you should assume just like C</>.
  
  You will also like to use C<< $req->base >> as a base prefix when
  building URLs in your templates or in redirections. It's a good idea
  for you to subclass Plack::Request and define methods such as:
  
    sub uri_for {
        my($self, $path, $args) = @_;
        my $uri = $self->base;
        $uri->path($uri->path . $path);
        $uri->query_form(@$args) if $args;
        $uri;
    }
  
  So you can say:
  
    my $link = $req->uri_for('/logout', [ signoff => 1 ]);
  
  and if C<< $req->base >> is C</app> you'll get the full URI for
  C</app/logout?signoff=1>.
  
  =head1 INCOMPATIBILITIES
  
  In version 1.0, many utility methods are removed or deprecated, and
  most methods are made read-only.
  
  The following methods are deprecated: C<hostname>, C<url_scheme>,
  C<params>, C<query_params>, C<body_params>, C<cookie> and
  C<raw_uri>. They will be removed in the next major release.
  
  All parameter-related methods such as C<parameters>,
  C<body_parameters>, C<query_parameters> and C<uploads> now contains
  L<Hash::MultiValue> objects, rather than I<scalar or an array
  reference depending on the user input> which is insecure. See
  L<Hash::MultiValue> for more about this change.
  
  C<< $req->path >> method had a bug, where the code and the document
  was mismatching. The document was suggesting it returns the sub
  request path after C<< $req->base >> but the code was always returning
  the absolute URI path. The code is now updated to be an alias of C<<
  $req->path_info >> but returns C</> in case it's empty. If you need
  the older behavior, just call C<< $req->uri->path >> instead.
  
  Cookie handling is simplified, and doesn't use L<CGI::Simple::Cookie>
  anymore, which means you B<CAN NOT> set array reference or hash
  reference as a cookie value and expect it be serialized. You're always
  required to set string value, and encoding or decoding them is totally
  up to your application or framework. Also, C<cookies> hash reference
  now returns I<strings> for the cookies rather than CGI::Simple::Cookie
  objects, which means you no longer have to write a wacky code such as:
  
    $v = $req->cookie->{foo} ? $req->cookie->{foo}->value : undef;
  
  and instead, simply do:
  
    $v = $req->cookie->{foo};
  
  =head1 AUTHORS
  
  Tatsuhiko Miyagawa
  
  Kazuhiro Osawa
  
  Tokuhiro Matsuno
  
  =head1 SEE ALSO
  
  L<Plack::Response> L<HTTP::Request>, L<Catalyst::Request>
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
PLACK_REQUEST

$fatpacked{"Plack/Request/Upload.pm"} = <<'PLACK_REQUEST_UPLOAD';
  package Plack::Request::Upload;
  use strict;
  use warnings;
  use Carp ();
  
  sub new {
      my($class, %args) = @_;
  
      bless {
          headers  => $args{headers},
          tempname => $args{tempname},
          size     => $args{size},
          filename => $args{filename},
      }, $class;
  }
  
  sub filename { $_[0]->{filename} }
  sub headers  { $_[0]->{headers} }
  sub size     { $_[0]->{size} }
  sub tempname { $_[0]->{tempname} }
  sub path     { $_[0]->{tempname} }
  
  sub content_type {
      my $self = shift;
      $self->{headers}->content_type(@_);
  }
  
  sub type { shift->content_type(@_) }
  
  sub basename {
      my $self = shift;
      unless (defined $self->{basename}) {
          require File::Spec::Unix;
          my $basename = $self->{filename};
          $basename =~ s|\\|/|g;
          $basename = ( File::Spec::Unix->splitpath($basename) )[2];
          $basename =~ s|[^\w\.-]+|_|g;
          $self->{basename} = $basename;
      }
      $self->{basename};
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Request::Upload - handles file upload requests
  
  =head1 SYNOPSIS
  
    # $req is Plack::Request
    my $upload = $req->uploads->{field};
  
    $upload->size;
    $upload->path;
    $upload->content_type;
    $upload->basename;
  
  =head1 METHODS
  
  =over 4
  
  =item size
  
  Returns the size of Uploaded file.
  
  =item path
  
  Returns the path to the temporary file where uploaded file is saved.
  
  =item content_type
  
  Returns the content type of the uploaded file.
  
  =item filename
  
  Returns the original filename in the client.
  
  =item basename
  
  Returns basename for "filename".
  
  =back
  
  =head1 AUTHORS
  
  Kazuhiro Osawa
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Request>, L<Catalyst::Request::Upload>
  
  =cut
PLACK_REQUEST_UPLOAD

$fatpacked{"Plack/Response.pm"} = <<'PLACK_RESPONSE';
  package Plack::Response;
  use strict;
  use warnings;
  our $VERSION = '0.9938';
  $VERSION = eval $VERSION;
  
  use Plack::Util::Accessor qw(body status);
  use Carp ();
  use Scalar::Util ();
  use HTTP::Headers;
  use URI::Escape ();
  
  sub code    { shift->status(@_) }
  sub content { shift->body(@_)   }
  
  sub new {
      my($class, $rc, $headers, $content) = @_;
  
      my $self = bless {}, $class;
      $self->status($rc)       if defined $rc;
      $self->headers($headers) if defined $headers;
      $self->body($content)    if defined $content;
  
      $self;
  }
  
  sub headers {
      my $self = shift;
  
      if (@_) {
          my $headers = shift;
          if (ref $headers eq 'ARRAY') {
              Carp::carp("Odd number of headers") if @$headers % 2 != 0;
              $headers = HTTP::Headers->new(@$headers);
          } elsif (ref $headers eq 'HASH') {
              $headers = HTTP::Headers->new(%$headers);
          }
          return $self->{headers} = $headers;
      } else {
          return $self->{headers} ||= HTTP::Headers->new();
      }
  }
  
  sub cookies {
      my $self = shift;
      if (@_) {
          $self->{cookies} = shift;
      } else {
          return $self->{cookies} ||= +{ };
      }
  }
  
  sub header { shift->headers->header(@_) } # shortcut
  
  sub content_length {
      shift->headers->content_length(@_);
  }
  
  sub content_type {
      shift->headers->content_type(@_);
  }
  
  sub content_encoding {
      shift->headers->content_encoding(@_);
  }
  
  sub location {
      shift->headers->header('Location' => @_);
  }
  
  sub redirect {
      my $self = shift;
  
      if (@_) {
          my $url = shift;
          my $status = shift || 302;
          $self->location($url);
          $self->status($status);
      }
  
      return $self->location;
  }
  
  sub finalize {
      my $self = shift;
      Carp::croak "missing status" unless $self->status();
  
      $self->_finalize_cookies();
  
      return [
          $self->status,
          +[
              map {
                  my $k = $_;
                  map { ( $k => $_ ) } $self->headers->header($_);
              } $self->headers->header_field_names
          ],
          $self->_body,
      ];
  }
  
  sub _body {
      my $self = shift;
      my $body = $self->body;
         $body = [] unless defined $body;
      if (!ref $body or Scalar::Util::blessed($body) && overload::Method($body, q(""))) {
          return [ $body ];
      } else {
          return $body;
      }
  }
  
  sub _finalize_cookies {
      my $self = shift;
  
      while (my($name, $val) = each %{$self->cookies}) {
          my $cookie = $self->_bake_cookie($name, $val);
          $self->headers->push_header( 'Set-Cookie' => $cookie );
      }
  }
  
  sub _bake_cookie {
      my($self, $name, $val) = @_;
  
      return '' unless defined $val;
      $val = { value => $val } unless ref $val eq 'HASH';
  
      my @cookie = ( URI::Escape::uri_escape($name) . "=" . URI::Escape::uri_escape($val->{value}) );
      push @cookie, "domain=" . $val->{domain}   if $val->{domain};
      push @cookie, "path=" . $val->{path}       if $val->{path};
      push @cookie, "expires=" . $self->_date($val->{expires}) if $val->{expires};
      push @cookie, "secure"                     if $val->{secure};
      push @cookie, "HttpOnly"                   if $val->{httponly};
  
      return join "; ", @cookie;
  }
  
  my @MON  = qw( Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec );
  my @WDAY = qw( Sun Mon Tue Wed Thu Fri Sat );
  
  sub _date {
      my($self, $expires) = @_;
  
      if ($expires =~ /^\d+$/) {
          # all numbers -> epoch date
          # (cookies use '-' as date separator, HTTP uses ' ')
          my($sec, $min, $hour, $mday, $mon, $year, $wday) = gmtime($expires);
          $year += 1900;
  
          return sprintf("%s, %02d-%s-%04d %02d:%02d:%02d GMT",
                         $WDAY[$wday], $mday, $MON[$mon], $year, $hour, $min, $sec);
  
      }
  
      return $expires;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Response - Portable HTTP Response object for PSGI response
  
  =head1 SYNOPSIS
  
    use Plack::Response;
  
    sub psgi_handler {
        my $env = shift;
  
        my $res = Plack::Response->new(200);
        $res->content_type('text/html');
        $res->body("Hello World");
  
        return $res->finalize;
    }
  
  =head1 DESCRIPTION
  
  Plack::Response allows you a way to create PSGI response array ref through a simple API.
  
  =head1 METHODS
  
  =over 4
  
  =item new
  
    $res = Plack::Response->new;
    $res = Plack::Response->new($status);
    $res = Plack::Response->new($status, $headers);
    $res = Plack::Response->new($status, $headers, $body);
  
  Creates a new Plack::Response object.
  
  =item status
  
    $res->status(200);
    $status = $res->status;
  
  Sets and gets HTTP status code. C<code> is an alias.
  
  =item headers
  
    $headers = $res->headers;
    $res->headers([ 'Content-Type' => 'text/html' ]);
    $res->headers({ 'Content-Type' => 'text/html' });
    $res->headers( HTTP::Headers->new );
  
  Sets and gets HTTP headers of the response. Setter can take either an
  array ref, a hash ref or L<HTTP::Headers> object containing a list of
  headers.
  
  =item body
  
    $res->body($body_str);
    $res->body([ "Hello", "World" ]);
    $res->body($io);
  
  Gets and sets HTTP response body. Setter can take either a string, an
  array ref, or an IO::Handle-like object. C<content> is an alias.
  
  =item header
  
    $res->header('X-Foo' => 'bar');
    my $val = $res->header('X-Foo');
  
  Shortcut for C<< $res->headers->header >>.
  
  =item content_type, content_length, content_encoding
  
    $res->content_type('text/plain');
    $res->content_length(123);
    $res->content_encoding('gzip');
  
  Shortcut for the equivalent get/set methods in C<< $res->headers >>.
  
  =item redirect
  
    $res->redirect($url);
    $res->redirect($url, 301);
  
  Sets redirect URL with an optional status code, which defaults to 302.
  
  =item location
  
  Gets and sets C<Location> header.
  
  =item cookies
  
    $res->cookies->{foo} = 123;
    $res->cookies->{foo} = { value => '123' };
  
  Returns a hash reference containing cookies to be set in the
  response. The keys of the hash are the cookies' names, and their
  corresponding values are a plain string (for C<value> with everything
  else defaults) or a hash reference that can contain keys such as
  C<value>, C<domain>, C<expires>, C<path>, C<httponly>, C<secure>.
  
  C<expires> can take a string or an integer (as an epoch time) and
  B<does not> convert string formats such as C<+3M>.
  
    $res->cookies->{foo} = {
        value => 'test',
        path  => "/",
        domain => '.example.com',
        expires => time + 24 * 60 * 60,
    };
  
  =back
  
  =head1 AUTHOR
  
  Tokuhiro Matsuno
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Request>
  
  =cut
PLACK_RESPONSE

$fatpacked{"Plack/Runner.pm"} = <<'PLACK_RUNNER';
  package Plack::Runner;
  use strict;
  use warnings;
  use Carp ();
  use Plack::Util;
  use Try::Tiny;
  
  sub new {
      my $class = shift;
      bless {
          env      => $ENV{PLACK_ENV},
          loader   => 'Plack::Loader',
          includes => [],
          modules  => [],
          @_,
      }, $class;
  }
  
  # delay the build process for reloader
  sub build(&;$) {
      my $block = shift;
      my $app   = shift || sub { };
      return sub { $block->($app->()) };
  }
  
  sub parse_options {
      my $self = shift;
  
      local @ARGV = @_;
  
      # From 'prove': Allow cuddling the paths with -I, -M and -e
      @ARGV = map { /^(-[IMe])(.+)/ ? ($1,$2) : $_ } @ARGV;
  
      my($host, $port, $socket, @listen);
  
      require Getopt::Long;
      Getopt::Long::Configure("no_ignore_case", "pass_through");
      Getopt::Long::GetOptions(
          "a|app=s"      => \$self->{app},
          "o|host=s"     => \$host,
          "p|port=i"     => \$port,
          "s|server=s"   => \$self->{server},
          "S|socket=s"   => \$socket,
          'l|listen=s@'  => \@listen,
          'D|daemonize'  => \$self->{daemonize},
          "E|env=s"      => \$self->{env},
          "e=s"          => \$self->{eval},
          'I=s@'         => $self->{includes},
          'M=s@'         => $self->{modules},
          'r|reload'     => sub { $self->{loader} = "Restarter" },
          'R|Reload=s'   => sub { $self->{loader} = "Restarter"; $self->loader->watch(split ",", $_[1]) },
          'L|loader=s'   => \$self->{loader},
          "h|help"       => \$self->{help},
          "v|version"    => \$self->{version},
      );
  
      my(@options, @argv);
      while (defined($_ = shift @ARGV)) {
          if (s/^--?//) {
              my @v = split '=', $_, 2;
              $v[0] =~ tr/-/_/;
              if (@v == 2) {
                  push @options, @v;
              } elsif ($v[0] =~ s/^(disable|enable)_//) {
                  push @options, $v[0], $1 eq 'enable';
              } else {
                  push @options, $v[0], shift @ARGV;
              }
          } else {
              push @argv, $_;
          }
      }
  
      push @options, $self->mangle_host_port_socket($host, $port, $socket, @listen);
      push @options, daemonize => 1 if $self->{daemonize};
  
      $self->{options} = \@options;
      $self->{argv}    = \@argv;
  }
  
  sub set_options {
      my $self = shift;
      push @{$self->{options}}, @_;
  }
  
  sub mangle_host_port_socket {
      my($self, $host, $port, $socket, @listen) = @_;
  
      for my $listen (reverse @listen) {
          if ($listen =~ /:\d+$/) {
              ($host, $port) = split /:/, $listen, 2;
              $host = undef if $host eq '';
          } else {
              $socket ||= $listen;
          }
      }
  
      unless (@listen) {
          if ($socket) {
              @listen = ($socket);
          } else {
              $port ||= 5000;
              @listen = ($host ? "$host:$port" : ":$port");
          }
      }
  
      return host => $host, port => $port, listen => \@listen, socket => $socket;
  }
  
  sub version_cb {
      my $self = shift;
      $self->{version_cb} || sub {
          require Plack;
          print "Plack $Plack::VERSION\n";
      };
  }
  
  sub setup {
      my $self = shift;
  
      if ($self->{help}) {
          require Pod::Usage;
          Pod::Usage::pod2usage(0);
      }
  
      if ($self->{version}) {
          $self->version_cb->();
          exit;
      }
  
      if (@{$self->{includes}}) {
          require lib;
          lib->import(@{$self->{includes}});
      }
  
      if ($self->{eval}) {
          push @{$self->{modules}}, 'Plack::Builder';
      }
  
      for (@{$self->{modules}}) {
          my($module, @import) = split /[=,]/;
          eval "require $module" or die $@;
          $module->import(@import);
      }
  }
  
  sub locate_app {
      my($self, @args) = @_;
  
      my $psgi = $self->{app} || $args[0];
  
      if (ref $psgi eq 'CODE') {
          return sub { $psgi };
      }
  
      if ($self->{eval}) {
          $self->loader->watch("lib");
          return build {
              no strict;
              no warnings;
              my $eval = "builder { $self->{eval};";
              $eval .= "Plack::Util::load_psgi(\$psgi);" if $psgi;
              $eval .= "}";
              eval $eval or die $@;
          };
      }
  
      $psgi ||= "app.psgi";
  
      require File::Basename;
      $self->loader->watch( File::Basename::dirname($psgi) . "/lib", $psgi );
      build { Plack::Util::load_psgi $psgi };
  }
  
  sub watch {
      my($self, @dir) = @_;
  
      push @{$self->{watch}}, @dir
          if $self->{loader} eq 'Restarter';
  }
  
  sub apply_middleware {
      my($self, $app, $class, @args) = @_;
  
      my $mw_class = Plack::Util::load_class($class, 'Plack::Middleware');
      build { $mw_class->wrap($_[0], @args) } $app;
  }
  
  sub prepare_devel {
      my($self, $app) = @_;
  
      $app = $self->apply_middleware($app, 'Lint');
      $app = $self->apply_middleware($app, 'StackTrace');
      unless ($ENV{GATEWAY_INTERFACE}) {
          $app = $self->apply_middleware($app, 'AccessLog', logger => sub { print STDERR @_ });
      }
  
      push @{$self->{options}}, server_ready => sub {
          my($args) = @_;
          my $name  = $args->{server_software} || ref($args); # $args is $server
          my $host  = $args->{host} || 0;
          my $proto = $args->{proto} || 'http';
          print STDERR "$name: Accepting connections at $proto://$host:$args->{port}/\n";
      };
  
      $app;
  }
  
  sub loader {
      my $self = shift;
      $self->{_loader} ||= Plack::Util::load_class($self->{loader}, 'Plack::Loader')->new;
  }
  
  sub load_server {
      my($self, $loader) = @_;
  
      if ($self->{server}) {
          return $loader->load($self->{server}, @{$self->{options}});
      } else {
          return $loader->auto(@{$self->{options}});
      }
  }
  
  sub run {
      my $self = shift;
  
      unless (ref $self) {
          $self = $self->new;
          $self->parse_options(@_);
          return $self->run;
      }
  
      my @args = @_ ? @_ : @{$self->{argv}};
  
      $self->setup;
  
      my $app = $self->locate_app(@args);
  
      $ENV{PLACK_ENV} ||= $self->{env} || 'development';
      if ($ENV{PLACK_ENV} eq 'development') {
          $app = $self->prepare_devel($app);
      }
  
      my $loader = $self->loader;
      $loader->preload_app($app);
  
      my $server = $self->load_server($loader);
      $loader->run($server);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Runner - plackup core
  
  =head1 SYNOPSIS
  
    # Your bootstrap script
    use Plack::Runner;
    my $app = sub { ... };
  
    my $runner = Plack::Runner->new;
    $runner->parse_options(@ARGV);
    $runner->run($app);
  
  =head1 DESCRIPTION
  
  Plack::Runner is the core of L<plackup> runner script. You can create
  your own frontend to run your application or framework, munge command
  line options and pass that to C<run> method of this class.
  
  C<run> method does exactly the same thing as the L<plackup> script
  does, but one notable addition is that you can pass a PSGI application
  code reference directly with C<--app> option, rather than via C<.psgi>
  file path or with C<-e> switch. This would be useful if you want to
  make an installable PSGI application.
  
  Also, when C<-h> or C<--help> switch is passed, the usage text is
  automatically extracted from your own script using L<Pod::Usage>.
  
  =head1 NOTES
  
  Do not directly call this module from your C<.psgi>, since that makes
  your PSGI application unnecessarily depend on L<plackup> and won't run
  other backends like L<Plack::Handler::Apache2> or mod_psgi.
  
  If you I<really> want to make your C<.psgi> runnable as a standalone
  script, you can do this:
  
    # foo.psgi
    if (__FILE__ eq $0) {
        require Plack::Runner;
        Plack::Runner->run(@ARGV, $0);
    }
  
    # This should always come last
    my $app = sub { ... };
  
  =head1 SEE ALSO
  
  L<plackup>
  
  =cut
  
  
PLACK_RUNNER

$fatpacked{"Plack/Server.pm"} = <<'PLACK_SERVER';
  package Plack::Server;
  use strict;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Server - DEPRECATED. See Plack::Handler
  
  =head1 SEE ALSO
  
  L<Plack::Handler>
  
  =cut
  
PLACK_SERVER

$fatpacked{"Plack/Server/Apache1.pm"} = <<'PLACK_SERVER_APACHE1';
  package Plack::Server::Apache1;
  use strict;
  use parent qw(Plack::Handler::Apache1);
  use Carp;
  
  sub new {
      my $class = shift;
      Carp::carp "Use of $class is deprecated. Use Plack::Handler::Apache1 or Plack::Loader to upgrade.";
      $class->SUPER::new(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Server::Apache1 - DEPRECATED
  
  =head1 DESCRIPTION
  
  B<This module is deprecated>. See L<Plack::Handler::Apache1>.
  
  =cut
PLACK_SERVER_APACHE1

$fatpacked{"Plack/Server/Apache2.pm"} = <<'PLACK_SERVER_APACHE2';
  package Plack::Server::Apache2;
  use strict;
  use parent qw(Plack::Handler::Apache2);
  use Carp;
  
  sub new {
      my $class = shift;
      Carp::carp "Use of $class is deprecated. Use Plack::Handler::Apache2 or Plack::Loader to upgrade.";
      $class->SUPER::new(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Server::Apache2 - DEPRECATED
  
  =head1 DESCRIPTION
  
  B<This module is deprecated>. See L<Plack::Handler::Apache2>.
  
  =cut
PLACK_SERVER_APACHE2

$fatpacked{"Plack/Server/CGI.pm"} = <<'PLACK_SERVER_CGI';
  package Plack::Server::CGI;
  use strict;
  use parent qw(Plack::Handler::CGI);
  
  sub new {
      my $class = shift;
      print STDERR "Use of $class is deprecated. Use Plack::Handler::CGI or Plack::Loader to upgrade.\n";
      $class->SUPER::new(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Server::CGI - DEPRECATED
  
  =head1 DESCRIPTION
  
  B<This module is deprecated>. See L<Plack::Handler::CGI>.
  
  =cut
PLACK_SERVER_CGI

$fatpacked{"Plack/Server/FCGI.pm"} = <<'PLACK_SERVER_FCGI';
  package Plack::Server::FCGI;
  use strict;
  use parent qw(Plack::Handler::FCGI);
  use Carp;
  
  sub new {
      my $class = shift;
      Carp::carp "Use of $class is deprecated. Use Plack::Handler::FCGI or Plack::Loader to upgrade.";
      $class->SUPER::new(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Server::FCGI - DEPRECATED
  
  =head1 DESCRIPTION
  
  B<This module is deprecated>. See L<Plack::Handler::FCGI>.
  
  =cut
PLACK_SERVER_FCGI

$fatpacked{"Plack/Server/ServerSimple.pm"} = <<'PLACK_SERVER_SERVERSIMPLE';
  package Plack::Server::ServerSimple;
  use strict;
  our $VERSION = '0.9938';
  $VERSION = eval $VERSION;
  
  use parent qw(Plack::Handler::HTTP::Server::Simple);
  use Carp;
  
  sub new {
      my $class = shift;
      Carp::carp "$class is deprecated. Use -s HTTP::Server::Simple";
      $class->SUPER::new(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Server::ServerSimple - DEPRECATED
  
  =head1 DESCRIPTION
  
  B<DEPRECATED>. Use Plack::Handler::HTTP::Server::Simple.
  
  =cut
PLACK_SERVER_SERVERSIMPLE

$fatpacked{"Plack/Server/Standalone.pm"} = <<'PLACK_SERVER_STANDALONE';
  package Plack::Server::Standalone;
  use strict;
  use parent qw(Plack::Handler::Standalone);
  use Carp;
  
  sub new {
      my $class = shift;
      Carp::carp "Use of $class is deprecated. Use Plack::Handler::Standalone or Plack::Loader to upgrade.";
      $class->SUPER::new(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Server::Standalone - DEPRECATED
  
  =head1 DESCRIPTION
  
  B<This module is deprecated>. See L<Plack::Handler::Standalone>.
  
  =cut
PLACK_SERVER_STANDALONE

$fatpacked{"Plack/Server/Standalone/Prefork.pm"} = <<'PLACK_SERVER_STANDALONE_PREFORK';
  package Plack::Server::Standalone::Prefork;
  use strict;
  use parent qw(HTTP::Server::PSGI); # because Standalone is a wrapper
  use Carp;
  
  sub new {
      my $class = shift;
      Carp::carp "Use of $class is deprecated. Use Starman or Starlet for preforking servers.";
      $class->SUPER::new(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Server::Standalone::Prefork - DEPRECATED use Starman or Starlet instead
  
  =head1 DESCRIPTION
  
  B<This module is deprecated>.
  
  =head1 SEE ALSO
  
  L<HTTP::Server::PSGI> L<Starman> L<Starlet>
  
  =cut
PLACK_SERVER_STANDALONE_PREFORK

$fatpacked{"Plack/TempBuffer.pm"} = <<'PLACK_TEMPBUFFER';
  package Plack::TempBuffer;
  use strict;
  use warnings;
  use Plack::Util;
  use FileHandle; # for seek etc.
  
  our $MaxMemoryBufferSize = 1024 * 1024;
  
  sub new {
      my($class, $length) = @_;
  
      # $MaxMemoryBufferSize = 0  -> Always temp file
      # $MaxMemoryBufferSize = -1 -> Always PerlIO
      my $backend;
      if ($MaxMemoryBufferSize < 0) {
          $backend = "PerlIO";
      } elsif ($MaxMemoryBufferSize == 0) {
          $backend = "File";
      } elsif (!$length) {
          $backend = "Auto";
      } elsif ($length > $MaxMemoryBufferSize) {
          $backend = "File";
      } else {
          $backend = "PerlIO";
      }
  
      $class->create($backend, $length, $MaxMemoryBufferSize);
  }
  
  sub create {
      my($class, $backend, $length, $max) = @_;
      Plack::Util::load_class($backend, $class)->new($length, $max);
  }
  
  sub print;
  sub rewind;
  sub size;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::TempBuffer - temporary buffer to save bytes
  
  =head1 SYNOPSIS
  
    my $buf = Plack::TempBuffer->new($length);
    $buf->print($bytes);
  
    my $size = $buf->size;
    my $fh   = $buf->rewind;
  
  =head1 DESCRIPTION
  
  Plack::TempBuffer is a buffer class to store arbitrary length of byte
  strings and then get a seekable filehandle once everything is
  buffered. It uses PerlIO and/or temporary file to save the buffer
  depending on the length of the size.
  
  =head1 SEE ALSO
  
  L<Plack> L<Plack::Request>
  
  =cut
  
PLACK_TEMPBUFFER

$fatpacked{"Plack/TempBuffer/Auto.pm"} = <<'PLACK_TEMPBUFFER_AUTO';
  package Plack::TempBuffer::Auto;
  use strict;
  use parent 'Plack::TempBuffer';
  
  sub new {
      my($class, undef, $max_memory_size) = @_;
      bless {
          _buffer => Plack::TempBuffer->create('PerlIO'),
          _max => $max_memory_size,
      }, $class;
  }
  
  sub print {
      my $self = shift;
      $self->{_buffer}->print(@_);
  
      if ($self->{_max} && $self->{_buffer}->size > $self->{_max}) {
          my $buf = $self->{_buffer}->{buffer};
          $self->{_buffer} = Plack::TempBuffer->create('File'),
          $self->{_buffer}->print($buf);
          delete $self->{_max};
      }
  }
  
  sub size {
      my $self = shift;
      $self->{_buffer}->size;
  }
  
  sub rewind {
      my $self = shift;
      $self->{_buffer}->rewind;
  }
  
  1;
PLACK_TEMPBUFFER_AUTO

$fatpacked{"Plack/TempBuffer/File.pm"} = <<'PLACK_TEMPBUFFER_FILE';
  package Plack::TempBuffer::File;
  use strict;
  use parent 'Plack::TempBuffer';
  
  use IO::File;
  
  sub new {
      my $class = shift;
  
      my $fh = IO::File->new_tmpfile;
      $fh->binmode;
  
      bless { fh => $fh }, $class;
  }
  
  sub print {
      my $self = shift;
      $self->{fh}->print(@_);
  }
  
  sub size {
      my $self = shift;
      $self->{fh}->flush;
      -s $self->{fh};
  }
  
  sub rewind {
      my $self = shift;
      $self->{fh}->seek(0, 0);
      $self->{fh};
  }
  
  1;
PLACK_TEMPBUFFER_FILE

$fatpacked{"Plack/TempBuffer/PerlIO.pm"} = <<'PLACK_TEMPBUFFER_PERLIO';
  package Plack::TempBuffer::PerlIO;
  use strict;
  use parent 'Plack::TempBuffer';
  
  sub new {
      my $class = shift;
      bless { buffer => '' }, $class;
  }
  
  sub print {
      my $self = shift;
      $self->{buffer} .= "@_";
  }
  
  sub size {
      my $self = shift;
      length $self->{buffer};
  }
  
  sub rewind {
      my $self = shift;
      my $buffer = $self->{buffer};
      open my $io, "<", \$buffer;
      bless $io, 'FileHandle'; # This makes $io work as FileHandle under 5.8, .10 and .11 :/
      return $io;
  }
  
  1;
PLACK_TEMPBUFFER_PERLIO

$fatpacked{"Plack/Test.pm"} = <<'PLACK_TEST';
  package Plack::Test;
  use strict;
  use warnings;
  use parent qw(Exporter);
  our @EXPORT = qw(test_psgi);
  
  our $Impl;
  $Impl ||= $ENV{PLACK_TEST_IMPL} || "MockHTTP";
  
  sub test_psgi {
      eval "require Plack::Test::$Impl;";
      die $@ if $@;
      no strict 'refs';
      if (ref $_[0] && @_ == 2) {
          @_ = (app => $_[0], client => $_[1]);
      }
      &{"Plack::Test::$Impl\::test_psgi"}(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Test - Test PSGI applications with various backends
  
  =head1 SYNOPSIS
  
    use Plack::Test;
  
    # named params
    test_psgi
        app => sub {
            my $env = shift;
            return [ 200, [ 'Content-Type' => 'text/plain' ], [ "Hello World" ] ],
        },
        client => sub {
            my $cb = shift;
            my $req = HTTP::Request->new(GET => "http://localhost/hello");
            my $res = $cb->($req);
            like $res->content, qr/Hello World/;
        };
  
     use HTTP::Request::Common;
  
     # positional params (app, client)
     my $app = sub { return [ 200, [], [ "Hello "] ] };
     test_psgi $app, sub {
         my $cb = shift;
         my $res = $cb->(GET "/");
         is $res->content, "Hello";
     };
  
  
  =head1 DESCRIPTION
  
  Plack::Test is an unified interface to test PSGI applications using
  standard HTTP::Request and HTTP::Response objects. It also allows you
  to run PSGI applications in various ways, by default using C<MockHTTP>
  backend but can also use C<Server> backend, which uses one of
  L<Plack::Handler> implementations to run the web server to do live HTTP
  requests.
  
  =head1 FUNCTIONS
  
  =over 4
  
  =item test_psgi
  
    test_psgi $app, $client;
    test_psgi app => $app, client => $client;
  
  Runs the client test code C<$client> against a PSGI application
  C<$app>. The client callback gets one argument C<$cb>, that is a
  callback that accepts an HTTP::Request object and returns an
  HTTP::Response object.
  
  For the convenience, HTTP::Request given to the callback is
  automatically adjusted to the correct protocol (I<http>) and host
  names (I<127.0.0.1> by default), so the following code just works.
  
    use HTTP::Request::Common;
    test_psgi $app, sub {
        my $cb = shift;
        my $res = $cb->(GET "/hello");
    };
  
  =back
  
  =head1 OPTIONS
  
  You can specify the L<Plack::Test> backend using the environment
  variable C<PLACK_TEST_IMPL> or C<$Plack::Test::Impl> package variable.
  
  The available values for the backend are:
  
  =over 4
  
  =item MockHTTP
  
  (Default) Creates a PSGI env hash out of HTTP::Request object, runs
  the PSGI application in-process and returns HTTP::Response.
  
  =item Server
  
  Runs one of Plack::Handler backends (C<Standalone> by default) and
  sends live HTTP requests to test.
  
  =item ExternalServer
  
  Runs tests against an external server specified in the
  C<PLACK_TEST_EXTERNALSERVER_URI> environment variable instead of spawning the
  application in a server locally.
  
  =back
  
  For instance, you can test your application with C<ServerSimple> server backends with:
  
    > env PLACK_TEST_IMPL=Server PLACK_SERVER=ServerSimple prove -l t/test.t
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =cut
PLACK_TEST

$fatpacked{"Plack/Test/MockHTTP.pm"} = <<'PLACK_TEST_MOCKHTTP';
  package Plack::Test::MockHTTP;
  use strict;
  use warnings;
  
  use Carp;
  use HTTP::Request;
  use HTTP::Response;
  use HTTP::Message::PSGI;
  use Try::Tiny;
  
  sub test_psgi {
      my %args = @_;
  
      my $client = delete $args{client} or croak "client test code needed";
      my $app    = delete $args{app}    or croak "app needed";
  
      my $cb = sub {
          my $req = shift;
          $req->uri->scheme('http')    unless defined $req->uri->scheme;
          $req->uri->host('localhost') unless defined $req->uri->host;
          my $env = $req->to_psgi;
  
          my $res = try {
              HTTP::Response->from_psgi($app->($env));
          } catch {
              HTTP::Response->from_psgi([ 500, [ 'Content-Type' => 'text/plain' ], [ $_ ] ]);
          };
  
          $res->request($req);
          return $res;
      };
  
      $client->($cb);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Test::MockHTTP - Run mocked HTTP tests through PSGI applications
  
  =head1 DESCRIPTION
  
  Plack::Test::MockHTTP is an utility to run PSGI application given
  HTTP::Request objects and return HTTP::Response object out of PSGI
  application response. See L<Plack::Test> how to use this module.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  =head1 SEE ALSO
  
  L<Plack::Test>
  
  =cut
  
  
PLACK_TEST_MOCKHTTP

$fatpacked{"Plack/Test/Server.pm"} = <<'PLACK_TEST_SERVER';
  package Plack::Test::Server;
  use strict;
  use warnings;
  use Carp;
  use LWP::UserAgent;
  use Test::TCP;
  use Plack::Loader;
  
  sub test_psgi {
      my %args = @_;
  
      my $client = delete $args{client} or croak "client test code needed";
      my $app    = delete $args{app}    or croak "app needed";
      my $ua     = delete $args{ua} || LWP::UserAgent->new;
  
      test_tcp(
          client => sub {
              my $port = shift;
              my $cb = sub {
                  my $req = shift;
                  $req->uri->scheme('http');
                  $req->uri->host($args{host} || '127.0.0.1');
                  $req->uri->port($port);
                  return $ua->request($req);
              };
              $client->($cb);
          },
          server => $args{server} || sub {
              my $port = shift;
              my $server = Plack::Loader->auto(port => $port, host => ($args{host} || '127.0.0.1'));
              $server->run($app);
          },
      );
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Test::Server - Run HTTP tests through live Plack servers
  
  =head1 DESCRIPTION
  
  Plack::Test::Server is an utility to run PSGI application with Plack
  server implementations, and run the live HTTP tests with the server
  using a callback. See L<Plack::Test> how to use this module.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa
  
  Tokuhiro Matsuno
  
  =head1 SEE ALSO
  
  L<Plack::Loader> L<Test::TCP> L<Plack::Test>
  
  =cut
  
PLACK_TEST_SERVER

$fatpacked{"Plack/Test/Suite.pm"} = <<'PLACK_TEST_SUITE';
  package Plack::Test::Suite;
  use strict;
  use warnings;
  use Digest::MD5;
  use File::ShareDir;
  use HTTP::Request;
  use HTTP::Request::Common;
  use LWP::UserAgent;
  use Test::More;
  use Test::TCP;
  use Plack::Loader;
  use Plack::Middleware::Lint;
  use Plack::Util;
  use Plack::Request;
  use Try::Tiny;
  
  my $share_dir = try { File::ShareDir::dist_dir('Plack') } || 'share';
  
  # 0: test name
  # 1: request generator coderef.
  # 2: request handler
  # 3: test case for response
  our @TEST = (
      [
          'GET',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/?name=miyagawa");
              is $res->code, 200;
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'Hello, name=miyagawa';
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ 'Hello, ' . $env->{QUERY_STRING} ],
              ];
          },
      ],
      [
          'POST',
          sub {
              my $cb = shift;
              my $res = $cb->(POST "http://127.0.0.1/", [name => 'tatsuhiko']);
              is $res->code, 200;
              is $res->header('Client-Content-Length'), 14;
              is $res->header('Client-Content-Type'), 'application/x-www-form-urlencoded';
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'Hello, name=tatsuhiko';
          },
          sub {
              my $env = shift;
              my $body;
              $env->{'psgi.input'}->read($body, $env->{CONTENT_LENGTH});
              return [
                  200,
                  [ 'Content-Type' => 'text/plain',
                    'Client-Content-Length' => $env->{CONTENT_LENGTH},
                    'Client-Content-Type' => $env->{CONTENT_TYPE},
                ],
                  [ 'Hello, ' . $body ],
              ];
          },
      ],
      [
          'big POST',
          sub {
              my $cb = shift;
              my $chunk = "abcdefgh" x 12000;
              my $req = HTTP::Request->new(POST => "http://127.0.0.1");
              $req->content_length(length $chunk);
              $req->content_type('application/octet-stream');
              $req->content($chunk);
  
              my $res = $cb->($req);
              is $res->code, 200;
              is $res->header('Client-Content-Length'), length $chunk;
              is length $res->content, length $chunk;
              is Digest::MD5::md5_hex($res->content), Digest::MD5::md5_hex($chunk);
          },
          sub {
              my $env = shift;
              my $len = $env->{CONTENT_LENGTH};
              my $body = '';
              my $spin;
              while ($len > 0) {
                  my $rc = $env->{'psgi.input'}->read($body, $env->{CONTENT_LENGTH}, length $body);
                  $len -= $rc;
                  last if $spin++ > 2000;
              }
              return [
                  200,
                  [ 'Content-Type' => 'text/plain',
                    'Client-Content-Length' => $env->{CONTENT_LENGTH},
                    'Client-Content-Type' => $env->{CONTENT_TYPE},
                ],
                  [ $body ],
              ];
          },
      ],
      [
          'psgi.url_scheme',
          sub {
              my $cb = shift;
              my $res = $cb->(POST "http://127.0.0.1/");
              is $res->code, 200;
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'http';
          },
          sub {
              my $env = $_[0];
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{'psgi.url_scheme'} ],
              ];
          },
      ],
      [
          'return glob',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is $res->code, 200;
              is $res->header('content_type'), 'text/plain';
              like $res->content, qr/^package /;
              like $res->content, qr/END_MARK_FOR_TESTING$/;
          },
          sub {
              my $env = shift;
              open my $fh, '<', __FILE__ or die $!;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  $fh,
              ];
          },
      ],
      [
          'filehandle',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo.jpg");
              is $res->code, 200;
              is $res->header('content_type'), 'image/jpeg';
              is length $res->content, 4745;
          },
          sub {
              my $env = shift;
              open my $fh, '<', "$share_dir/face.jpg";
              return [
                  200,
                  [ 'Content-Type' => 'image/jpeg', 'Content-Length' => -s $fh ],
                  $fh
              ];
          },
      ],
      [
          'bigger file',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/baybridge.jpg");
              is $res->code, 200;
              is $res->header('content_type'), 'image/jpeg';
              is length $res->content, 79838;
              is Digest::MD5::md5_hex($res->content), '983726ae0e4ce5081bef5fb2b7216950';
          },
          sub {
              my $env = shift;
              open my $fh, '<', "$share_dir/baybridge.jpg";
              binmode $fh;
              return [
                  200,
                  [ 'Content-Type' => 'image/jpeg', 'Content-Length' => -s $fh ],
                  $fh
              ];
          },
      ],
      [
          'handle HTTP-Header',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan", Foo => "Bar");
              is $res->code, 200;
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'Bar';
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$env->{HTTP_FOO}],
              ];
          },
      ],
      [
          'handle HTTP-Cookie',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan", Cookie => "foo");
              is $res->code, 200;
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'foo';
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$env->{HTTP_COOKIE}],
              ];
          },
      ],
      [
          'validate env',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan");
              is $res->code, 200;
              is $res->header('content_type'), 'text/plain';
              is $res->content, join("\n",
                  'REQUEST_METHOD:GET',
                  'PATH_INFO:/foo/',
                  'QUERY_STRING:dankogai=kogaidan',
                  'SERVER_NAME:127.0.0.1',
                  "SERVER_PORT:" . $res->request->uri->port,
              )."\n";
          },
          sub {
              my $env = shift;
              my $body;
              $body .= $_ . ':' . $env->{$_} . "\n" for qw/REQUEST_METHOD PATH_INFO QUERY_STRING SERVER_NAME SERVER_PORT/;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$body],
              ];
          },
      ],
      [
          '% encoding in PATH_INFO',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/bar%2cbaz");
              is $res->content, "/foo/bar,baz", "PATH_INFO should be decoded per RFC 3875";
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{PATH_INFO} ],
              ];
          },
      ],
      [
          '% double encoding in PATH_INFO',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/bar%252cbaz");
              is $res->content, "/foo/bar%2cbaz", "PATH_INFO should be decoded only once, per RFC 3875";
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{PATH_INFO} ],
              ];
          },
      ],
      [
          'SERVER_PROTOCOL is required',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan");
              is $res->code, 200;
              is $res->header('content_type'), 'text/plain';
              like $res->content, qr{^HTTP/1\.[01]$};
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$env->{SERVER_PROTOCOL}],
              ];
          },
      ],
      [
          'SCRIPT_NAME should not be undef',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan");
              is $res->content, 1;
          },
          sub {
              my $env = shift;
              my $cont = defined $env->{'SCRIPT_NAME'};
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$cont],
              ];
          },
      ],
      [
          'call close after read IO::Handle-like',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/call_close");
              is($res->content, '1234');
          },
          sub {
              my $env = shift;
              {
                  our $closed = -1;
                  sub CalledClose::new { $closed = 0; my $i=0; bless \$i, 'CalledClose' }
                  sub CalledClose::getline {
                      my $self = shift;
                      return $$self++ < 4 ? $$self : undef;
                  }
                  sub CalledClose::close { ::ok(1, 'closed') if defined &::ok }
              }
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  CalledClose->new(),
              ];
          },
      ],
      [
          'has errors',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/has_errors");
              is $res->content, 1;
          },
          sub {
              my $env = shift;
              my $err = $env->{'psgi.errors'};
              my $has_errors = defined $err;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [$has_errors]
              ];
          },
      ],
      [
          'status line',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/?dankogai=kogaidan");
              is($res->status_line, '200 OK');
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [1]
              ];
          },
      ],
      [
          'Do not crash when the app dies',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is $res->code, 500;
          },
          sub {
              my $env = shift;
              open my $io, '>', \my $error;
              $env->{'psgi.errors'} = $io;
              die "Throwing an exception from app handler. Server shouldn't crash.";
          },
      ],
      [
          'multi headers (request)',
          sub {
              my $cb  = shift;
              my $req = HTTP::Request->new(
                  GET => "http://127.0.0.1/",
              );
              $req->push_header(Foo => "bar");
              $req->push_header(Foo => "baz");
              my $res = $cb->($req);
              like($res->content, qr/^bar,\s*baz$/);
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', ],
                  [ $env->{HTTP_FOO} ]
              ];
          },
      ],
      [
          'multi headers (response)',
          sub {
              my $cb  = shift;
              my $res = $cb->(HTTP::Request->new(GET => "http://127.0.0.1/"));
              my $foo = $res->header('X-Foo');
              like $foo, qr/foo,\s*bar,\s*baz/;
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', 'X-Foo', 'foo', 'X-Foo', 'bar, baz' ],
                  [ 'hi' ]
              ];
          },
      ],
      [
          'Do not set $env->{COOKIE}',
          sub {
              my $cb  = shift;
              my $req = HTTP::Request->new(
                  GET => "http://127.0.0.1/",
              );
              $req->push_header(Cookie => "foo=bar");
              my $res = $cb->($req);
              is($res->header('X-Cookie'), 0);
              is $res->content, 'foo=bar';
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain', 'X-Cookie' => $env->{COOKIE} ? 1 : 0 ],
                  [ $env->{HTTP_COOKIE} ]
              ];
          },
      ],
      [
          'no entity headers on 304',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is $res->code, 304;
              is $res->content, '';
              ok ! defined $res->header('content_type'), "No Content-Type";
              ok ! defined $res->header('content_length'), "No Content-Length";
              ok ! defined $res->header('transfer_encoding'), "No Transfer-Encoding";
          },
          sub {
              my $env = shift;
              return [ 304, [], [] ];
          },
      ],
      [
          'REQUEST_URI is set',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo/bar%20baz%73?x=a");
              is $res->content, '/foo/bar%20baz%73?x=a';
          },
          sub {
              my $env = shift;
              return [ 200, [ 'Content-Type' => 'text/plain' ], [ $env->{REQUEST_URI} ] ];
          },
      ],
      [
          'filehandle with path()',
          sub {
              my $cb  = shift;
              my $res = $cb->(GET "http://127.0.0.1/foo.jpg");
              is $res->code, 200;
              is $res->header('content_type'), 'image/jpeg';
              is length $res->content, 4745;
          },
          sub {
              my $env = shift;
              open my $fh, '<', "$share_dir/face.jpg";
              Plack::Util::set_io_path($fh, "$share_dir/face.jpg");
              return [
                  200,
                  [ 'Content-Type' => 'image/jpeg', 'Content-Length' => -s $fh ],
                  $fh
              ];
          },
      ],
      [
          'a big header value > 128 bytes',
          sub {
              my $cb  = shift;
              my $req = GET "http://127.0.0.1/";
              my $v = ("abcdefgh" x 16);
              $req->header('X-Foo' => $v);
              my $res = $cb->($req);
              is $res->code, 200;
              is $res->content, $v;
          },
          sub {
              my $env = shift;
              return [
                  200,
                  [ 'Content-Type' => 'text/plain' ],
                  [ $env->{HTTP_X_FOO} ],
              ];
          },
      ],
      [
          'coderef res',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/?name=miyagawa");
              return if $res->code == 501;
  
              is $res->code, 200;
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'Hello, name=miyagawa';
          },
          sub {
              my $env = shift;
              $env->{'psgi.streaming'} or return [ 501, ['Content-Type','text/plain'], [] ];
              return sub {
                  my $respond = shift;
                  $respond->([
                      200,
                      [ 'Content-Type' => 'text/plain', ],
                      [ 'Hello, ' . $env->{QUERY_STRING} ],
                  ]);
              }
          },
      ],
      [
          'coderef streaming',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/?name=miyagawa");
              return if $res->code == 501;
  
              is $res->code, 200;
              is $res->header('content_type'), 'text/plain';
              is $res->content, 'Hello, name=miyagawa';
          },
          sub {
              my $env = shift;
              $env->{'psgi.streaming'} or return [ 501, ['Content-Type','text/plain'], [] ];
  
              return sub {
                  my $respond = shift;
  
                  my $writer = $respond->([
                      200,
                      [ 'Content-Type' => 'text/plain', ],
                  ]);
  
                  $writer->write("Hello, ");
                  $writer->write($env->{QUERY_STRING});
                  $writer->close();
              }
          },
      ],
      [
          'CRLF output and FCGI parse bug',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
  
              is $res->header("Foo"), undef;
              is $res->content, "Foo: Bar\r\n\r\nHello World";
          },
          sub {
              return [ 200, [ "Content-Type", "text/plain" ], [ "Foo: Bar\r\n\r\nHello World" ] ];
          },
      ],
      [
          'test 404',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              is $res->code, 404;
              is $res->content, 'Not Found';
          },
          sub {
              return [ 404, [ "Content-Type", "text/plain" ], [ "Not Found" ] ];
          },
      ],
      [
          'request->input seekable',
          sub {
              my $cb = shift;
              my $req = HTTP::Request->new(POST => "http://127.0.0.1/");
              $req->content("body");
              $req->content_type('text/plain');
              $req->content_length(4);
              my $res = $cb->($req);
              is $res->content, 'body';
          },
          sub {
              my $req = Plack::Request->new(shift);
              return [ 200, [ "Content-Type", "text/plain" ], [ $req->content ] ];
          },
      ],
      [
          'request->content on GET',
          sub {
              my $cb = shift;
              my $res = $cb->(GET "http://127.0.0.1/");
              ok $res->is_success;
          },
          sub {
              my $req = Plack::Request->new(shift);
              $req->content;
              return [ 200, [ "Content-Type", "text/plain" ], [ "OK" ] ];
          },
      ],
  );
  
  sub runtests {
      my($class, $runner) = @_;
      for my $test (@TEST) {
          $runner->(@$test);
      }
  }
  
  sub run_server_tests {
      my($class, $server, $server_port, $http_port, %args) = @_;
  
      if (ref $server ne 'CODE') {
          my $server_class = $server;
          $server = sub {
              my($port, $app) = @_;
              my $server = Plack::Loader->load($server_class, port => $port, host => "127.0.0.1", %args);
              $app = Plack::Middleware::Lint->wrap($app);
              $server->run($app);
          }
      }
  
      test_tcp(
          client => sub {
              my $port = shift;
  
              my $ua = LWP::UserAgent->new;
              for my $i (0..$#TEST) {
                  my $test = $TEST[$i];
                  note $test->[0];
                  my $cb = sub {
                      my $req = shift;
                      $req->uri->port($http_port || $port);
                      $req->header('X-Plack-Test' => $i);
                      return $ua->request($req);
                  };
  
                  $test->[1]->($cb);
              }
          },
          server => sub {
              my $port = shift;
              my $app  = $class->test_app_handler;
              $server->($port, $app);
          },
          port => $server_port,
      );
  }
  
  sub test_app_handler {
      return sub {
          my $env = shift;
          $TEST[$env->{HTTP_X_PLACK_TEST}][2]->($env);
      };
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Plack::Test::Suite - Test suite for Plack handlers
  
  =head1 SYNOPSIS
  
    use Test::More;
    use Plack::Test::Suite;
    Plack::Test::Suite->run_server_tests('Your::Handler');
    done_testing;
  
  =head1 DESCRIPTION
  
  Plack::Test::Suite is a test suite to test a new PSGI server
  implementation. It automatically loads a new handler environment and
  uses LWP to send HTTP requests to the local server to make sure your
  handler implements the PSGI specification correctly.
  
  Note that the handler name doesn't include the C<Plack::Handler::>
  prefix, i.e. if you have a new Plack handler Plack::Handler::Foo, your
  test script would look like:
  
    Plack::Test::Suite->run_server_tests('Foo');
  
  =head1 AUTHOR
  
  Tokuhiro Matsuno
  
  Tatsuhiko Miyagawa
  
  Kazuho Oku
  
  =cut
  
  END_MARK_FOR_TESTING
PLACK_TEST_SUITE

$fatpacked{"Plack/Util.pm"} = <<'PLACK_UTIL';
  package Plack::Util;
  use strict;
  use Carp ();
  use Scalar::Util;
  use IO::Handle;
  use overload ();
  
  sub TRUE()  { 1==1 }
  sub FALSE() { !TRUE }
  
  sub load_class {
      my($class, $prefix) = @_;
  
      if ($prefix) {
          unless ($class =~ s/^\+// || $class =~ /^$prefix/) {
              $class = "$prefix\::$class";
          }
      }
  
      my $file = $class;
      $file =~ s!::!/!g;
      require "$file.pm"; ## no critic
  
      return $class;
  }
  
  sub is_real_fh ($) {
      my $fh = shift;
  
      my $reftype = Scalar::Util::reftype($fh) or return;
      if (   $reftype eq 'IO'
          or $reftype eq 'GLOB' && *{$fh}{IO}
      ) {
          # if it's a blessed glob make sure to not break encapsulation with
          # fileno($fh) (e.g. if you are filtering output then file descriptor
          # based operations might no longer be valid).
          # then ensure that the fileno *opcode* agrees too, that there is a
          # valid IO object inside $fh either directly or indirectly and that it
          # corresponds to a real file descriptor.
          my $m_fileno = $fh->fileno;
          return FALSE unless defined $m_fileno;
          return FALSE unless $m_fileno >= 0;
  
          my $f_fileno = fileno($fh);
          return FALSE unless defined $f_fileno;
          return FALSE unless $f_fileno >= 0;
          return TRUE;
      } else {
          # anything else, including GLOBS without IO (even if they are blessed)
          # and non GLOB objects that look like filehandle objects cannot have a
          # valid file descriptor in fileno($fh) context so may break.
          return FALSE;
      }
  }
  
  sub set_io_path {
      my($fh, $path) = @_;
      bless $fh, 'Plack::Util::IOWithPath';
      $fh->path($path);
  }
  
  sub content_length {
      my $body = shift;
  
      return unless defined $body;
  
      if (ref $body eq 'ARRAY') {
          my $cl = 0;
          for my $chunk (@$body) {
              $cl += length $chunk;
          }
          return $cl;
      } elsif ( is_real_fh($body) ) {
          return (-s $body) - tell($body);
      }
  
      return;
  }
  
  sub foreach {
      my($body, $cb) = @_;
  
      if (ref $body eq 'ARRAY') {
          for my $line (@$body) {
              $cb->($line) if length $line;
          }
      } else {
          local $/ = \65536 unless ref $/;
          while (defined(my $line = $body->getline)) {
              $cb->($line) if length $line;
          }
          $body->close;
      }
  }
  
  sub class_to_file {
      my $class = shift;
      $class =~ s!::!/!g;
      $class . ".pm";
  }
  
  sub _load_sandbox {
      my $_file = shift;
  
      my $_package = $_file;
      $_package =~ s/([^A-Za-z0-9_])/sprintf("_%2x", unpack("C", $1))/eg;
  
      return eval sprintf <<'END_EVAL', $_package;
  package Plack::Sandbox::%s;
  {
      my $app = do $_file;
      if ( !$app && ( my $error = $@ || $! )) { die $error; }
      $app;
  }
  END_EVAL
  }
  
  sub load_psgi {
      my $stuff = shift;
  
      local $ENV{PLACK_ENV} = $ENV{PLACK_ENV} || 'development';
  
      my $file = $stuff =~ /^[a-zA-Z0-9\_\:]+$/ ? class_to_file($stuff) : $stuff;
      my $app = _load_sandbox($file);
      die "Error while loading $file: $@" if $@;
  
      return $app->to_app if $app and Scalar::Util::blessed($app) and $app->can('to_app');
      return $app;
  }
  
  sub run_app($$) {
      my($app, $env) = @_;
  
      return eval { $app->($env) } || do {
          my $body = "Internal Server Error";
          $env->{'psgi.errors'}->print($@);
          [ 500, [ 'Content-Type' => 'text/plain', 'Content-Length' => length($body) ], [ $body ] ];
      };
  }
  
  sub headers {
      my $headers = shift;
      inline_object(
          iter   => sub { header_iter($headers, @_) },
          get    => sub { header_get($headers, @_) },
          set    => sub { header_set($headers, @_) },
          push   => sub { header_push($headers, @_) },
          exists => sub { header_exists($headers, @_) },
          remove => sub { header_remove($headers, @_) },
          headers => sub { $headers },
      );
  }
  
  sub header_iter {
      my($headers, $code) = @_;
  
      my @headers = @$headers; # copy
      while (my($key, $val) = splice @headers, 0, 2) {
          $code->($key, $val);
      }
  }
  
  sub header_get {
      my($headers, $key) = (shift, lc shift);
  
      my @val;
      header_iter $headers, sub {
          push @val, $_[1] if lc $_[0] eq $key;
      };
  
      return wantarray ? @val : $val[0];
  }
  
  sub header_set {
      my($headers, $key, $val) = @_;
  
      my($set, @new_headers);
      header_iter $headers, sub {
          if (lc $key eq lc $_[0]) {
              return if $set;
              $_[1] = $val;
              $set++;
          }
          push @new_headers, $_[0], $_[1];
      };
  
      push @new_headers, $key, $val unless $set;
      @$headers = @new_headers;
  }
  
  sub header_push {
      my($headers, $key, $val) = @_;
      push @$headers, $key, $val;
  }
  
  sub header_exists {
      my($headers, $key) = (shift, lc shift);
  
      my $exists;
      header_iter $headers, sub {
          $exists = 1 if lc $_[0] eq $key;
      };
  
      return $exists;
  }
  
  sub header_remove {
      my($headers, $key) = (shift, lc shift);
  
      my @new_headers;
      header_iter $headers, sub {
          push @new_headers, $_[0], $_[1]
              unless lc $_[0] eq $key;
      };
  
      @$headers = @new_headers;
  }
  
  sub status_with_no_entity_body {
      my $status = shift;
      return $status < 200 || $status == 204 || $status == 304;
  }
  
  sub encode_html {
      my $str = shift;
      $str =~ s/&/&amp;/g;
      $str =~ s/>/&gt;/g;
      $str =~ s/</&lt;/g;
      $str =~ s/"/&quot;/g;
      $str =~ s/'/&#39;/g;
      return $str;
  }
  
  sub inline_object {
      my %args = @_;
      bless {%args}, 'Plack::Util::Prototype';
  }
  
  package Plack::Util::Prototype;
  
  our $AUTOLOAD;
  sub can {
      exists $_[0]->{$_[1]};
  }
  
  sub AUTOLOAD {
      my $self = shift;
      my $attr = $AUTOLOAD;
      $attr =~ s/.*://;
      if (ref($self->{$attr}) eq 'CODE') {
          $self->{$attr}->(@_);
      } else {
          Carp::croak(qq/Can't locate object method "$attr" via package "Plack::Util::Prototype"/);
      }
  }
  
  sub DESTROY { }
  
  package Plack::Util::IOWithPath;
  use parent qw(IO::Handle);
  
  sub path {
      my $self = shift;
      if (@_) {
          ${*$self}{+__PACKAGE__} = shift;
      }
      ${*$self}{+__PACKAGE__};
  }
  
  package Plack::Util;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Util - Utility subroutines for Plack server and framework developers
  
  =head1 FUNCTIONS
  
  =over 4
  
  =item TRUE, FALSE
  
    my $true  = Plack::Util::TRUE;
    my $false = Plack::Util::FALSE;
  
  Utility constants to include when you specify boolean variables in C<$env> hash (e.g. C<psgi.multithread>).
  
  =item load_class
  
    my $class = Plack::Util::load_class($class [, $prefix ]);
  
  Constructs a class name and C<require> the class. Throws an exception
  if the .pm file for the class is not found, just with the built-in
  C<require>.
  
  If C<$prefix> is set, the class name is prepended to the C<$class>
  unless C<$class> begins with C<+> sign, which means the class name is
  already fully qualified.
  
    my $class = Plack::Util::load_class("Foo");                   # Foo
    my $class = Plack::Util::load_class("Baz", "Foo::Bar");       # Foo::Bar::Baz
    my $class = Plack::Util::load_class("+XYZ::ZZZ", "Foo::Bar"); # XYZ::ZZZ
  
  =item is_real_fh
  
    if ( Plack::Util::is_real_fh($fh) ) { }
  
  returns true if a given C<$fh> is a real file handle that has a file
  descriptor. It returns false if C<$fh> is PerlIO handle that is not
  really related to the underlying file etc.
  
  =item content_length
  
    my $cl = Plack::Util::content_length($body);
  
  Returns the length of content from body if it can be calculated. If
  C<$body> is an array ref it's a sum of length of each chunk, if
  C<$body> is a real filehandle it's a remaining size of the filehandle,
  otherwise returns undef.
  
  =item set_io_path
  
    Plack::Util::set_io_path($fh, "/path/to/foobar.txt");
  
  Sets the (absolute) file path to C<$fh> filehandle object, so you can
  call C<< $fh->path >> on it. As a side effect C<$fh> is blessed to an
  internal package but it can still be treated as a normal file
  handle.
  
  This module doesn't normalize or absolutize the given path, and is
  intended to be used from Server or Middleware implementations. See
  also L<IO::File::WithPath>.
  
  =item foreach
  
    Plack::Util::foreach($body, $cb);
  
  Iterate through I<$body> which is an array reference or
  IO::Handle-like object and pass each line (which is NOT really
  guaranteed to be a I<line>) to the callback function.
  
  It internally sets the buffer length C<$/> to 4096 in case it reads
  the binary file, unless otherwise set in the caller's code.
  
  =item load_psgi
  
    my $app = Plack::Util::load_psgi $psgi_file_or_class;
  
  Load C<app.psgi> file or a class name (like C<MyApp::PSGI>) and
  require the file to get PSGI application handler. If the file can't be
  loaded (e.g. file doesn't exist or has a perl syntax error), it will
  throw an exception.
  
  B<Security>: If you give this function a class name or module name
  that is loadable from your system, it will load the module. This could
  lead to a security hole:
  
    my $psgi = ...; # user-input: consider "Moose.pm"
    $app = Plack::Util::load_psgi($psgi); # this does 'require "Moose.pm"'!
  
  Generally speaking, passing an external input to this function is
  considered very insecure. But if you really want to do that, be sure
  to validate the argument passed to this function. Also, if you do not
  want to accept an arbitrary class name but only load from a file path,
  make sure that the argument C<$psgi_file_or_class> begins with C</> so
  that Perl's built-in do function won't search the include path.
  
  =item run_app
  
    my $res = Plack::Util::run_app $app, $env;
  
  Runs the I<$app> by wrapping errors with I<eval> and if an error is
  found, logs it to C<< $env->{'psgi.errors'} >> and returns the
  template 500 Error response.
  
  =item header_get, header_exists, header_set, header_push, header_remove
  
    my $hdrs = [ 'Content-Type' => 'text/plain' ];
  
    my $v = Plack::Util::header_get($hdrs, $key); # First found only
    my @v = Plack::Util::header_get($hdrs, $key);
    my $bool = Plack::Util::header_exists($hdrs, $key);
    Plack::Util::header_set($hdrs, $key, $val);   # overwrites existent header
    Plack::Util::header_push($hdrs, $key, $val);
    Plack::Util::header_remove($hdrs, $key);
  
  Utility functions to manipulate PSGI response headers array
  reference. The methods that read existent header value handles header
  name as case insensitive.
  
    my $hdrs = [ 'Content-Type' => 'text/plain' ];
    my $v = Plack::Util::header_get('content-type'); # 'text/plain'
  
  =item headers
  
    my $headers = [ 'Content-Type' => 'text/plain' ];
  
    my $h = Plack::Util::headers($headers);
    $h->get($key);
    if ($h->exists($key)) { ... }
    $h->set($key => $val);
    $h->push($key => $val);
    $h->remove($key);
    $h->headers; # same reference as $headers
  
  Given a header array reference, returns a convenient object that has
  an instance methods to access C<header_*> functions with an OO
  interface. The object holds a reference to the original given
  C<$headers> argument and updates the reference accordingly when called
  write methods like C<set>, C<push> or C<remove>. It also has C<headers>
  method that would return the same reference.
  
  =item status_with_no_entity_body
  
    if (status_with_no_entity_body($res->[0])) { }
  
  Returns true if the given status code doesn't have any Entity body in
  HTTP response, i.e. it's 100, 101, 204 or 304.
  
  =item inline_object
  
    my $o = Plack::Util::inline_object(
        write => sub { $h->push_write(@_) },
        close => sub { $h->push_shutdown },
    );
    $o->write(@stuff);
    $o->close;
  
  Creates an instant object that can react to methods passed in the
  constructor. Handy to create when you need to create an IO stream
  object for input or errors.
  
  =back
  
  =cut
  
  
  
PLACK_UTIL

$fatpacked{"Plack/Util/Accessor.pm"} = <<'PLACK_UTIL_ACCESSOR';
  package Plack::Util::Accessor;
  use strict;
  use warnings;
  
  sub import {
      shift;
      return unless @_;
      my $package = caller();
      mk_accessors( $package, @_ );
  }
  
  sub mk_accessors {
      my $package = shift;
      no strict 'refs';
      foreach my $field ( @_ ) {
          *{ $package . '::' . $field } = sub {
              return $_[0]->{ $field } if scalar( @_ ) == 1;
              return $_[0]->{ $field }  = scalar( @_ ) == 2 ? $_[1] : [ @_[1..$#_] ];
          };
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Plack::Util::Accessor - Accessor generation utility for Plack
  
  =head1 DESCRIPTION
  
  This module is just a simple accessor generator for Plack to replace
  the Class::Accessor::Fast usage and so our classes don't have to inherit
  from their accessor generator.
  
  =head1 SEE ALSO
  
  L<PSGI> L<http://plackperl.org/>
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
PLACK_UTIL_ACCESSOR

$fatpacked{"Router/Simple.pm"} = <<'ROUTER_SIMPLE';
  package Router::Simple;
  use strict;
  use warnings;
  use 5.00800;
  our $VERSION = '0.06';
  use Router::Simple::SubMapper;
  use Router::Simple::Route;
  use List::Util qw/max/;
  use Carp ();
  
  sub new {
      bless {routes => []}, shift;
  }
  
  sub connect {
      my $self = shift;
      my $route = Router::Simple::Route->new(@_);
      push @{ $self->{routes} }, $route;
      return $self;
  }
  
  sub submapper {
      my ($self, $pattern, $dest, $opt) = @_;
      return Router::Simple::SubMapper->new(
          parent  => $self,
          pattern => $pattern,
          dest    => $dest || +{},
          opt     => $opt || +{},
      );
  }
  
  sub _match {
      my ($self, $env) = @_;
  
      $env = +{ PATH_INFO => $env } unless ref $env;
  
      for my $route (@{$self->{routes}}) {
          my $match = $route->match($env);
          return ($match, $route) if $match;
      }
      return undef; # not matched.
  }
  
  sub match {
      my ($self, $req) = @_;
      my ($match) = $self->_match($req);
      return $match;
  }
  
  sub routematch {
      my ($self, $req) = @_;
      return $self->_match($req);
  }
  
  sub as_string {
      my $self = shift;
  
      my $mn = max(map { $_->{name} ? length($_->{name}) : 0 } @{$self->{routes}});
      my $nn = max(map { $_->{method} ? length(join(",",@{$_->{method}})) : 0 } @{$self->{routes}});
  
      return join('', map {
          sprintf "%-${mn}s %-${nn}s %s\n", $_->{name}||'', join(',', @{$_->{method} || []}) || '', $_->{pattern}
      } @{$self->{routes}}) . "\n";
  }
  
  1;
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Router::Simple - simple HTTP router
  
  =head1 SYNOPSIS
  
      use Router::Simple;
  
      my $router = Router::Simple->new();
      $router->connect('/', {controller => 'Root', action => 'show'});
      $router->connect('/blog/{year}/{month}', {controller => 'Blog', action => 'monthly'});
  
      my $app = sub {
          my $env = shift;
          if (my $p = $router->match($env)) {
              # $p = { controller => 'Blog', action => 'monthly', ... }
          } else {
              [404, [], ['not found']];
          }
      };
  
  =head1 DESCRIPTION
  
  Router::Simple is a simple router class.
  
  Its main purpose is to serve as a dispatcher for web applications.
  
  Router::Simple can match against PSGI C<$env> directly, which means
  it's easy to use with PSGI supporting web frameworks.
  
  =head1 HOW TO WRITE A ROUTING RULE
  
  =head2 plain string 
  
      $router->connect( '/foo', { controller => 'Root', action => 'foo' } );
  
  =head2 :name notation
  
      $router->connect( '/wiki/:page', { controller => 'WikiPage', action => 'show' } );
      ...
      $router->match('/wiki/john');
      # => {controller => 'WikiPage', action => 'show', page => 'john' }
  
  ':name' notation matches qr{([^/]+)}.
  
  =head2 '*' notation
  
      $router->connect( '/download/*.*', { controller => 'Download', action => 'file' } );
      ...
      $router->match('/download/path/to/file.xml');
      # => {controller => 'Download', action => 'file', splat => ['path/to/file', 'xml'] }
  
  '*' notation matches qr{(.+)}. You will get the captured argument as
  an array ref for the special key C<splat>.
  
  =head2 '{year}' notation
  
      $router->connect( '/blog/{year}', { controller => 'Blog', action => 'yearly' } );
      ...
      $router->match('/blog/2010');
      # => {controller => 'Blog', action => 'yearly', year => 2010 }
  
  '{year}' notation matches qr{([^/]+)}, and it will be captured.
  
  =head2 '{year:[0-9]+}' notation
  
      $router->connect( '/blog/{year:[0-9]+}/{month:[0-9]{2}}', { controller => 'Blog', action => 'monthly' } );
      ...
      $router->match('/blog/2010/04');
      # => {controller => 'Blog', action => 'monthly', year => 2010, month => '04' }
  
  You can specify regular expressions in named captures.
  
  =head2 regexp
  
      $router->connect( qr{/blog/(\d+)/([0-9]{2})', { controller => 'Blog', action => 'monthly' } );
      ...
      $router->match('/blog/2010/04');
      # => {controller => 'Blog', action => 'monthly', splat => [2010, '04'] }
  
  You can use Perl5's powerful regexp directly, and the captured values
  are stored in the special key C<splat>.
  
  =head1 METHODS
  
  =over 4
  
  =item my $router = Router::Simple->new();
  
  Creates a new instance of Router::Simple.
  
  =item $router->connect([$name, ] $pattern, \%destination[, \%options])
  
  Adds a new rule to $router.
  
      $router->connect( '/', { controller => 'Root', action => 'index' } );
      $router->connect( 'show_entry', '/blog/:id',
          { controller => 'Blog', action => 'show' } );
      $router->connect( '/blog/:id', { controller => 'Blog', action => 'show' } );
      $router->connect( '/comment', { controller => 'Comment', action => 'new_comment' }, {method => 'POST'} );
  
  C<\%destination> will be used by I<match> method.
  
  You can specify some optional things to C<\%options>. The current
  version supports 'method', 'host', and 'on_match'.
  
  =over 4
  
  =item method
  
  'method' is an ArrayRef[String] or String that matches B<REQUEST_METHOD> in $req.
  
  =item host
  
  'host' is a String or Regexp that matches B<HTTP_HOST> in $req.
  
  =item on_match
  
      $r->connect(
          '/{controller}/{action}/{id}',
          {},
          {
              on_match => sub {
                  my($env, $match) = @_;
                  $match->{referer} = $env->{HTTP_REFERER};
                  return 1;
              }
          }
      );
  
  A function that evaluates the request. Its signature must be C<<
  ($environ, $match) => bool >>. It should return true if the match is
  successful or false otherwise. The first arg is C<$env> which is
  either a PSGI environment or a request path, depending on what you
  pass to C<match> method; the second is the routing variables that
  would be returned if the match succeeds.
  
  The function can modify C<$env> (in case it's a reference) and
  C<$match> in place to affect which variables are returned. This allows
  a wide range of transformations.
  
  =back
  
  =item $router->submapper($path, [\%dest, [\%opt]])
  
      $router->submapper('/entry/', {controller => 'Entry'})
  
  This method is shorthand for creating new instance of L<Router::Simple::Submapper>.
  
  The arguments will be passed to C<< Router::Simple::SubMapper->new(%args) >>.
  
  =item $match = $router->match($env|$path)
  
  Matches a URL against one of the contained routes.
  
  The parameter is either a L<PSGI> $env or a plain string that
  represents a path.
  
  This method returns a plain hashref that would look like:
  
      {
          controller => 'Blog',
          action     => 'daily',
          year => 2010, month => '03', day => '04',
      }
  
  It returns undef if no valid match is found.
  
  =item my ($match, $route) = $router->routematch($env|$path);
  
  Match a URL against against one of the routes contained.
  
  Will return undef if no valid match is found, otherwise a
  result hashref and a L<Router::Simple::Route> object is returned.
  
  =item $router->as_string()
  
  Dumps $router as string.
  
  Example output:
  
      home         GET  /
      blog_monthly GET  /blog/{year}/{month}
                   GET  /blog/{year:\d{1,4}}/{month:\d{2}}/{day:\d\d}
                   POST /comment
                   GET  /
  
  =back
  
  =head1 AUTHOR
  
  Tokuhiro Matsuno E<lt>tokuhirom AAJKLFJEF GMAIL COME<gt>
  
  =head1 THANKS TO
  
  Tatsuhiko Miyagawa
  
  Shawn M Moore
  
  L<routes.py|http://routes.groovie.org/>.
  
  =head1 SEE ALSO
  
  Router::Simple is inspired by L<routes.py|http://routes.groovie.org/>.
  
  L<Path::Dispatcher> is similar, but so complex.
  
  L<Path::Router> is heavy. It depends on L<Moose>.
  
  L<HTTP::Router> has many deps. It is not well documented.
  
  L<HTTPx::Dispatcher> is my old one. It does not provide an OOish interface.
  
  =head1 THANKS TO
  
  DeNA
  
  =head1 LICENSE
  
  Copyright (C) Tokuhiro Matsuno
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
ROUTER_SIMPLE

$fatpacked{"Router/Simple/Declare.pm"} = <<'ROUTER_SIMPLE_DECLARE';
  package Router::Simple::Declare;
  use strict;
  use warnings;
  use parent 'Exporter';
  use Router::Simple;
  use Carp ();
  
  our @EXPORT = qw/router connect submapper/;
  
  our $_ROUTER;
  
  sub router (&) {
      local $_ROUTER = Router::Simple->new();
      $_[0]->();
      $_ROUTER;
  }
  
  BEGIN {
      no strict 'refs';
      for my $meth (qw/connect submapper/) {
          *{$meth} = sub {
              local $Carp::CarpLevel = $Carp::CarpLevel + 1;
              $_ROUTER->$meth(@_);
          };
      }
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Router::Simple::Declare - declarative interface for Router::Simple
  
  =head1 SYNOPSIS
  
      use Router::Simple::Declare;
  
      my $router = router {
          connect '/{controller}/{action}/{id}';
  
          submapper('/account', {controller => 'Account'})
              ->connect('/login', {action => 'login'})
              ->connect('/logout', {action => 'logout'});
      };
      $router->match('/entry/show/3');
  
  =head1 DESCRIPTION
  
  Easy way to declare router object.
  
  =head1 USAGE
  
  look the SYNOPSIS.see L<Router::Simple> for more details.
  
  =head1 FUNCTIONS
  
  =over 4
  
  =item router
  
  =item connect
  
  =item submapper
  
  =back
  
  =head1 SEE ALSO
  
  L<Router::Simple>
  
  =cut
ROUTER_SIMPLE_DECLARE

$fatpacked{"Router/Simple/Route.pm"} = <<'ROUTER_SIMPLE_ROUTE';
  package Router::Simple::Route;
  use strict;
  use warnings;
  use parent 'Class::Accessor::Fast';
  
  __PACKAGE__->mk_accessors(qw/name dest on_match method host pattern/);
  
  sub new {
      my $class = shift;
  
      # connect([$name, ]$pattern[, \%dest[, \%opt]])
      if (@_ == 1 || ref $_[1]) {
          unshift(@_, undef);
      }
  
      my ($name, $pattern, $dest, $opt) = @_;
      Carp::croak("missing pattern") unless $pattern;
      my $row = +{
          name     => $name,
          dest     => $dest,
          on_match => $opt->{on_match},
      };
      if (my $method = $opt->{method}) {
          $method = [$method] unless ref $method;
          $row->{method} = $method;
  
          my $method_re = join '|', @{$method};
          $row->{method_re} = qr{^(?:$method_re)$};
      }
      if (my $host = $opt->{host}) {
          $row->{host} = $host;
          $row->{host_re} = ref $host ? $host : qr(^\Q$host\E$);
      }
  
      $row->{pattern} = $pattern;
  
      # compile pattern
      my @capture;
      $row->{pattern_re} = do {
          if (ref $pattern) {
              $row->{_regexp_capture} = 1;
              $pattern;
          } else {
              $pattern =~ s!
                  \{((?:\{[0-9,]+\}|[^{}]+)+)\} | # /blog/{year:\d{4}}
                  :([A-Za-z0-9_]+)              | # /blog/:year
                  (\*)                          | # /blog/*/*
                  ([^{:*]+)                       # normal string
              !
                  if ($1) {
                      my ($name, $pattern) = split /:/, $1;
                      push @capture, $name;
                      $pattern ? "($pattern)" : "([^/]+)";
                  } elsif ($2) {
                      push @capture, $2;
                      "([^/]+)";
                  } elsif ($3) {
                      push @capture, '__splat__';
                      "(.+)";
                  } else {
                      quotemeta($4);
                  }
              !gex;
              qr{^$pattern$};
          }
      };
      $row->{capture} = \@capture;
  
      return bless $row, $class;
  }
  
  sub match {
      my ($self, $env) = @_;
  
      if ($self->{host_re}) {
          unless ($env->{HTTP_HOST} =~ $self->{host_re}) {
              return undef;
          }
      }
      if ($self->{method_re}) {
          unless (($env->{REQUEST_METHOD} || '') =~ $self->{method_re}) {
              return undef;
          }
      }
      if (my @captured = ($env->{PATH_INFO} =~ $self->{pattern_re})) {
          my %args;
          my @splat;
          if ($self->{_regexp_capture}) {
              push @splat, @captured;
          } else {
              for my $i (0..@{$self->{capture}}-1) {
                  if ($self->{capture}->[$i] eq '__splat__') {
                      push @splat, $captured[$i];
                  } else {
                      $args{$self->{capture}->[$i]} = $captured[$i];
                  }
              }
          }
          my $match = +{
              %{$self->{dest}},
              %args,
              ( @splat ? ( splat => \@splat ) : () ),
          };
          if ($self->{on_match}) {
              my $ret = $self->{on_match}->($env, $match);
              return undef unless $ret;
          }
          return $match;
      }
      return undef;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Router::Simple::Route - route object
  
  =head1 DESCRIPTION
  
  This class represents route.
  
  =head1 ATTRIBUTES
  
  This class provides following attributes.
  
  =over 4
  
  =item name
  
  =item dest
  
  =item on_match
  
  =item method
  
  =item host
  
  =item pattern
  
  =back
  
  =head1 SEE ALSO
  
  L<Router::Simple>
  
ROUTER_SIMPLE_ROUTE

$fatpacked{"Router/Simple/SubMapper.pm"} = <<'ROUTER_SIMPLE_SUBMAPPER';
  package Router::Simple::SubMapper;
  use strict;
  use warnings;
  use Scalar::Util qw/weaken/;
  
  sub new {
      my ($class, %args) = @_;
      my $self = bless { %args }, $class;
      weaken($self->{parent});
      $self;
  }
  
  sub connect {
      my ($self, $pattern, $dest, $opt) = @_;
      $pattern = $self->{pattern}.$pattern if $self->{pattern};
      $dest ||= +{};
      $opt ||= +{};
  
      $self->{parent}->connect(
          $pattern,
          { %{ $self->{dest} }, %$dest },
          { %{ $self->{opt} },  %$opt }
      );
  
      $self; # chained method
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Router::Simple::SubMapper - submapper
  
  =head1 SYNOPSIS
  
      use Router::Simple;
  
      my $router = Router::Simple->new();
      my $s = $router->submapper('/entry/{id}', {controller => 'Entry'});
      $s->connect('/edit' => {action => 'edit'})
        ->connect('/show' => {action => 'show'});
  
  =head1 DESCRIPTION
  
  Router::Simple::SubMapper is sub-mapper for L<Router::Simple>.
  This class provides shorthand to create routes, that have common parts.
  
  =head1 METHODS
  
  =over 4
  
  =item my $submapper = $router->submapper(%args);
  
  Do not call this method directly.You should create new instance from $router->submapper(%args).
  
  =item $submapper->connect(@args)
  
  This method creates new route to parent $router with @args and arguments of ->submapper().
  
  This method returns $submapper itself for method-chain.
  
  =back
  
  =head1 SEE ALSO
  
  L<Router::Simple>
  
ROUTER_SIMPLE_SUBMAPPER

$fatpacked{"Text/MicroTemplate.pm"} = <<'TEXT_MICROTEMPLATE';
  # modified for NanoA by kazuho, some modified by tokuhirom
  # based on Mojo::Template. Copyright (C) 2008, Sebastian Riedel.
  
  package Text::MicroTemplate;
  
  require Exporter;
  
  use strict;
  use warnings;
  use constant DEBUG => $ENV{MICRO_TEMPLATE_DEBUG} || 0;
  use 5.00800;
  
  use Carp 'croak';
  use Scalar::Util;
  
  our $VERSION = '0.13';
  our @ISA = qw(Exporter);
  our @EXPORT_OK = qw(encoded_string build_mt render_mt);
  our %EXPORT_TAGS = (
      all => [ @EXPORT_OK ],
  );
  our $_mt_setter = '';
  
  sub new {
      my $class = shift;
      my $self = bless {
          code                => undef,
          comment_mark        => '#',
          expression_mark     => '=',
          line_start          => '?',
          template            => undef,
          tree                => [],
          tag_start           => '<?',
          tag_end             => '?>',
          escape_func         => \&_inline_escape_html,
          package_name        => undef, # defaults to caller
          @_ == 1 ? ref($_[0]) ? %{$_[0]} : (template => $_[0]) : @_,
      }, $class;
      if (defined $self->{template}) {
          $self->parse($self->{template});
      }
      unless (defined $self->{package_name}) {
          $self->{package_name} = 'main';
          my $i = 0;
          while (my $c = caller(++$i)) {
              if ($c !~ /^Text::MicroTemplate\b/) {
                  $self->{package_name} = $c;
                  last;
              }
          }
      }
      $self;
  }
  
  sub escape_func {
      my $self = shift;
      if (@_) {
          $self->{escape_func} = shift;
      }
      $self->{escape_func};
  }
  
  sub package_name {
      my $self = shift;
      if (@_) {
          $self->{package_name} = shift;
      }
      $self->{package_name};
  }
  
  sub template { shift->{template} }
  
  sub code {
      my $self = shift;
      unless (defined $self->{code}) {
          $self->_build();
      }
      $self->{code};
  }
  
  sub _build {
      my $self = shift;
      
      my $escape_func = $self->{escape_func} || '';
  
      my $embed_escape_func = ref($escape_func) eq 'CODE'
          ? $escape_func
          : sub{ $escape_func . "(@_)" };
  
      # Compile
      my @lines;
      my $last_was_code;
      for my $line (@{$self->{tree}}) {
  
          # New line
          push @lines, '';
          for (my $j = 0; $j < @{$line}; $j += 2) {
              my $type  = $line->[$j];
              my $value = $line->[$j + 1];
  
              # Need to fix line ending?
              my $newline = chomp $value;
  
              # add semicolon to last line of code
              if ($last_was_code && $type ne 'code') {
                  $lines[-1] .= ';';
                  undef $last_was_code;
              }
  
              # Text
              if ($type eq 'text') {
  
                  # Quote and fix line ending
                  $value = quotemeta($value);
                  $value .= '\n' if $newline;
  
                  $lines[-1] .= "\$_MT .= \"" . $value . "\";";
              }
  
              # Code
              if ($type eq 'code') {
                  $lines[-1] .= $value;
                  $last_was_code = 1;
              }
  
              # Expression
              if ($type eq 'expr') {
                  my $escaped = $embed_escape_func->('$_MT_T');
                  $lines[-1] .= "\$_MT_T = $value;\$_MT .= ref \$_MT_T eq 'Text::MicroTemplate::EncodedString' ? \$\$_MT_T : $escaped;";
              }
          }
      }
  
      # add semicolon to last line of code
      if ($last_was_code) {
          $lines[-1] .= "\n;";
      }
      
      # Wrap
      $lines[0]   = q/sub { my $_MT = ''; local $/ . $self->{package_name} . q/::_MTREF = \$_MT; my $_MT_T = '';/ . (@lines ? $lines[0] : '');
      $lines[-1] .= q/return $_MT; }/;
  
      $self->{code} = join "\n", @lines;
      return $self;
  }
  
  # I am so smart! I am so smart! S-M-R-T! I mean S-M-A-R-T...
  sub parse {
      my ($self, $tmpl) = @_;
      $self->{template} = $tmpl;
  
      # Clean start
      delete $self->{tree};
      delete $self->{code};
  
      # Tags
      my $line_start    = quotemeta $self->{line_start};
      my $tag_start     = quotemeta $self->{tag_start};
      my $tag_end       = quotemeta $self->{tag_end};
      my $cmnt_mark     = quotemeta $self->{comment_mark};
      my $expr_mark     = quotemeta $self->{expression_mark};
  
      # Tokenize
      my $state = 'text';
      my $multiline_expression = 0;
      my @lines = split /(\n)/, $tmpl;
      while (@lines) {
          my $line = shift @lines;
          my $newline = undef;
          if (@lines) {
              shift @lines;
              $newline = 1;
          }
          
          # Perl line without return value
          if ($line =~ /^$line_start\s+(.*)$/) {
              push @{$self->{tree}}, ['code', $1];
              $multiline_expression = 0;
              next;
          }
  
          # Perl line with return value
          if ($line =~ /^$line_start$expr_mark\s+(.+)$/) {
              push @{$self->{tree}}, [
                  'expr', $1,
                  $newline ? ('text', "\n") : (),
              ];
              $multiline_expression = 0;
              next;
          }
  
          # Comment line, dummy token needed for line count
          if ($line =~ /^$line_start$cmnt_mark\s+$/) {
              push @{$self->{tree}}, [];
              $multiline_expression = 0;
              next;
          }
  
          # Escaped line ending?
          if ($line =~ /(\\+)$/) {
              my $length = length $1;
  
              # Newline escaped
              if ($length == 1) {
                  $line =~ s/\\$//;
              }
  
              # Backslash escaped
              if ($length >= 2) {
                  $line =~ s/\\\\$/\\/;
                  $line .= "\n";
              }
          }
  
          # Normal line ending
          else { $line .= "\n" if $newline }
  
          # Mixed line
          my @token;
          for my $token (split /
              (
                  $tag_start$expr_mark     # Expression
              |
                  $tag_start$cmnt_mark     # Comment
              |
                  $tag_start               # Code
              |
                  $tag_end                 # End
              )
          /x, $line) {
  
              # Garbage
              next if $token eq '';
  
              # End
              if ($token =~ /^$tag_end$/) {
                  $state = 'text';
                  $multiline_expression = 0;
              }
  
              # Code
              elsif ($token =~ /^$tag_start$/) { $state = 'code' }
  
              # Comment
              elsif ($token =~ /^$tag_start$cmnt_mark$/) { $state = 'cmnt' }
  
              # Expression
              elsif ($token =~ /^$tag_start$expr_mark$/) {
                  $state = 'expr';
              }
  
              # Value
              else {
  
                  # Comments are ignored
                  next if $state eq 'cmnt';
  
                  # Multiline expressions are a bit complicated,
                  # only the first line can be compiled as 'expr'
                  $state = 'code' if $multiline_expression;
                  $multiline_expression = 1
                      if $state eq 'expr';
  
                  # Store value
                  push @token, $state, $token;
              }
          }
          push @{$self->{tree}}, \@token;
      }
      
      return $self;
  }
  
  sub _context {
      my ($self, $text, $line) = @_;
      my @lines  = split /\n/, $text;
      
      join '', map {
          0 < $_ && $_ <= @lines ? sprintf("%4d: %s\n", $_, $lines[$_ - 1]) : ''
      } ($line - 2) .. ($line + 2);
  }
  
  # Debug goodness
  sub _error {
      my ($self, $error, $line_offset, $from) = @_;
      
      # Line
      if ($error =~ /^(.*)\s+at\s+\(eval\s+\d+\)\s+line\s+(\d+)/) {
          my $reason = $1;
          my $line   = $2 - $line_offset;
          my $delim  = '-' x 76;
          
          my $report = "$reason at line $line in template passed from $from.\n";
          my $template = $self->_context($self->{template}, $line);
          $report .= "$delim\n$template$delim\n";
  
          # Advanced debugging
          if (DEBUG) {
              my $code = $self->_context($self->code, $line);
              $report .= "$code$delim\n";
              $report .= $error;
          }
  
          return $report;
      }
  
      # No line found
      return "Template error: $error";
  }
  
  # create raw string (that does not need to be escaped)
  sub encoded_string {
      Text::MicroTemplate::EncodedString->new($_[0]);
  }
  
  
  sub _inline_escape_html{
      my($variable) = @_;
  
      my $source = qq{
          do{
              $variable =~ s/([&><"'])/\$Text::MicroTemplate::_escape_table{\$1}/ge;
              $variable;
          }
      }; #" for poor editors
      $source =~ s/\n//g; # to keep line numbers
      return $source;
  }
  
  our %_escape_table = ( '&' => '&amp;', '>' => '&gt;', '<' => '&lt;', q{"} => '&quot;', q{'} => '&#39;' );
  sub escape_html {
      my $str = shift;
      return ''
          unless defined $str;
      return $str->as_string
          if ref $str eq 'Text::MicroTemplate::EncodedString';
      $str =~ s/([&><"'])/$_escape_table{$1}/ge; #' for poor editors
      return $str;
  }
  
  sub build_mt {
      my $mt = Text::MicroTemplate->new(@_);
      $mt->build();
  }
  
  sub build {
      my $_mt = shift;
      Scalar::Util::weaken($_mt) if $_mt_setter;
      my $_code = $_mt->code;
      my $_from = sub {
          my $i = 0;
          while (my @c = caller(++$i)) {
              return "$c[1] at line $c[2]"
                  if $c[0] ne __PACKAGE__;
          }
          '';
      }->();
      my $expr = << "...";
  package $_mt->{package_name};
  sub {
      ${_mt_setter}local \$SIG{__WARN__} = sub { print STDERR \$_mt->_error(shift, 4, \$_from) };
      Text::MicroTemplate::encoded_string((
          $_code
      )->(\@_));
  }
  ...
  
      if(DEBUG >= 2){
          DEBUG >= 3 ? die $expr : warn $expr;
      }
  
      my $die_msg;
      {
          local $@;
          if (my $_builder = eval($expr)) {
              return $_builder;
          }
          $die_msg = $_mt->_error($@, 4, $_from);
      }
      die $die_msg;
  }
  
  sub render_mt {
      my $builder = build_mt(shift);
      $builder->(@_);
  }
  
  # ? $_mt->filter(sub { s/\s+//smg; s/[\r\n]//g; })->(sub { ... ? });
  sub filter {
      my ($self, $callback) = @_;
      my $mtref = do {
          no strict 'refs';
          ${"$self->{package_name}::_MTREF"};
      };
      my $before = $$mtref;
      $$mtref = '';
      return sub {
          my $inner_func = shift;
          $inner_func->(@_);
  
          ## sub { s/foo/bar/g } is a valid filter
          ## sub { DateTime::Format::Foo->parse_string(shift) } is valid too
          local $_ = $$mtref;
          my $retval = $callback->($$mtref);
          no warnings 'uninitialized';
          if (($retval =~ /^\d+$/ and $_ ne $$mtref) or (defined $retval and !$retval)) {
              $$mtref = $before . $_;
          } else {
              $$mtref = $before . $retval;
          }
      }
  }
  
  package Text::MicroTemplate::EncodedString;
  
  use strict;
  use warnings;
  
  use overload q{""} => sub { shift->as_string }, fallback => 1;
  
  sub new {
      my ($klass, $str) = @_;
      bless \$str, $klass;
  }
  
  sub as_string {
      my $self = shift;
      $$self;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Text::MicroTemplate
  
  =head1 SYNOPSIS
  
      use Text::MicroTemplate qw(:all);
  
      # compile template, and render
      $renderer = build_mt('hello, <?= $_[0] ?>');
      $html = $renderer->('John')->as_string;
  
      # or in one line
      $html = render_mt('hello, <?= $_[0] ?>', 'John')->as_string;
  
      # complex form
      $mt = Text::MicroTemplate->new(
          template => 'hello, <?= $query->param('user') ?>',
      );
      $code = $mt->code;
      $renderer = eval << "..." or die $@;
      sub {
          my \$query = shift;
          $code->();
      }
      ...
      $html = $renderer->(CGI->new)->as_string;
  
  =head1 DESCRIPTION
  
  Text::MicroTemplate is a standalone, fast, intelligent, extensible template engine with following features.
  
  =head2 standalone
  
  Text::MicroTemplate does not rely on other CPAN modules.
  
  =head2 fast
  
  Based on L<Mojo::Template>, expressions in the template is perl code.
  
  =head2 intelligent
  
  Text::MicroTemplate automatically escapes variables when and only when necessary.
  
  =head2 extensible
  
  Text::MicroTemplate does not provide features like template cache or including other files by itself.  However, it is easy to add you own (that suites the most to your application), by wrapping the result of the module (which is a perl expression).
  
  The module only provides basic building blocks for a template engine.  Refer to L<Text::MicroTemplate::File> for higher-level interface.
  
  =head1 TEMPLATE SYNTAX
  
      # output the result of expression with automatic escape
      <?= $expr ?>             (tag style)
      ?= $expr                 (per-line)
  
      # execute perl code (tag style)
      <? foo() ?>
      ? foo()
  
      # comment (tag style)
      <?# comment ?>
      ?# comment
  
      # loops
      <ul>
      ? for my $item (@list) {
      <li><?= $item ?></li>
      ? }
      </ul>
  
  =head1 EXPORTABLE FUNCTIONS
  
  =head2 build_mt($template)
  
  Returns a subref that renders given template.  Parameters are equivalent to Text::MicroTemplate->new.
  
      # build template renderer at startup time and use it multiple times
      my $renderer = build_mt('hello, <?= $_[0] ?>!');
  
      sub run {
          ...
          my $hello = $renderer->($query->param('user'));
          ...
      }
  
  =head2 render_mt($template, @args)
  
  Utility function that combines build_mt and call to the generated template builder.
  
      # render
      $hello = render_mt('hello, <?= $_[0] ?>!', 'John');
  
      # print as HTML
      print $hello->as_string;
  
      # use the result in another template (no double-escapes)
      $enc = render_mt('<h1><?= $_[0] ?></h1>', $hello);
  
  Intertally, the function is equivalent to:
  
      build_mt($template)->(@_);
  
  =head2 encoded_string($str)
  
  wraps given string to an object that will not be escaped by the template engine
  
  =head1 OO-STYLE INTERFACE
  
  Text::MicroTemplate provides OO-style interface to handle more complex cases.
  
  =head2 new($template)
  
  =head2 new(%args)
  
  =head2 new(\%args)
  
  Constructs template renderer.  In the second or third form, parameters below are recognized.
  
  =head3 template
  
  template string (mandatory)
  
  =head3 escape_func
  
  escape function (defaults to L<Text::MicroTemplate::escape_html>), no escape when set to undef
  
  =head3 package_name
  
  package under where the renderer is compiled (defaults to caller package)
  
  =head2 code()
  
  returns perl code that renders the template when evaluated
  
  =head2 filter(sub filter_func { ... })->(sub { template lines })
  
  filters given template lines
  
      ? $_mt->filter(sub { s/Hello/Good bye/g })->(sub {
      Hello, John!
      ? })
  
  =head1 SEE ALSO
  
  L<Text::MicroTemplate::File>
  
  =head1 AUTHOR
  
  Kazuho Oku E<lt>kazuhooku gmail.comE<gt>
  
  Tokuhiro Matsuno E<lt>tokuhirom AAJKLFJEF GMAIL COME<gt>
  
  The module is based on L<Mojo::Template> by Sebastian Riedel.
  
  =head1 LICENSE
  
  This program is free software, you can redistribute it and/or modify it under the same terms as Perl 5.10.
  
  =cut
TEXT_MICROTEMPLATE

$fatpacked{"Text/MicroTemplate/EncodedString.pm"} = <<'TEXT_MICROTEMPLATE_ENCODEDSTRING';
  # the package in implemented intentionally in Text::MicroTemplate
  use Text::MicroTemplate;
  1;
TEXT_MICROTEMPLATE_ENCODEDSTRING

$fatpacked{"Text/MicroTemplate/File.pm"} = <<'TEXT_MICROTEMPLATE_FILE';
  package Text::MicroTemplate::File;
  
  use strict;
  use warnings;
  use Text::MicroTemplate;
  
  use Carp qw(croak);
  
  our @ISA = qw(Text::MicroTemplate);
  
  sub new {
      my $klass = shift;
      my $self = $klass->SUPER::new(@_);
      $self->{include_path} ||= [ '.' ];
      unless (defined $self->{open_layer}) {
          $self->{open_layer} = ':utf8';
      }
      unless (ref $self->{include_path}) {
          $self->{include_path} = [ $self->{include_path} ];
      }
      $self->{use_cache} ||= 0;
      $self->{cache} = {};  # file => { mtime, sub }
      $self;
  }
  
  sub open_layer {
      my $self = shift;
      $self->{open_layer} = $_[0]
          if @_;
      $self->{open_layer};
  }
  
  sub use_cache {
      my $self = shift;
      $self->{use_cache} = $_[0]
          if @_;
      $self->{use_cache};
  }
  
  sub build_file {
      my ($self, $file) = @_;
      # return cached entry
      if ($self->{use_cache} == 2) {
          if (my $e = $self->{cache}->{$file}) {
              return $e->[1];
          }
      }
      # iterate
      foreach my $path (@{$self->{include_path}}) {
          my $filepath = $path . '/' . $file;
          if (my @st = stat $filepath) {
              if (my $e = $self->{cache}->{$file}) {
                  return $e->[1]
                      if $st[9] == $e->[0]; # compare mtime
              }
              local $/;
  
              open my $fh, "<$self->{open_layer}", $filepath
                  or croak "failed to open:$filepath:$!";
              my $src = <$fh>;
              close $fh;
  
              $self->parse($src);
              local $Text::MicroTemplate::_mt_setter = 'my $_mt = shift;';
              my $f = $self->build();
              $self->{cache}->{$file} = [
                  $st[9], # mtime
                  $f,
              ] if $self->{use_cache};
              return $f;
          }
      }
      croak "could not find template file: $file (include_path: @{$self->{include_path}})";
  }
  
  sub render_file {
      my $self = shift;
      my $file = shift;
      $self->build_file($file)->($self, @_);
  }
  
  sub wrapper_file {
      my $self = shift;
      my $file = shift;
      my @args = @_;
      my $mtref = do {
          no strict 'refs';
          ${"$self->{package_name}::_MTREF"};
      };
      my $before = $$mtref;
      $$mtref = '';
      return sub {
          my $inner_func = shift;
          $inner_func->(@_);
          $$mtref =
              $before . $self->render_file($file, Text::MicroTemplate::encoded_string($$mtref), @args)->as_string;
      }
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Text::MicroTemplate::File - a file-based template manager
  
  =head1 SYNOPSIS
  
      use Text::MicroTemplate::File;
  
      our $mtf = Text::MicroTemplate::File->new(
          include_path => [ $path1, $path2, ... ],
          use_cache    => 1,
      );
  
      # render
      $mtf->render_file('template.file', $arg1, $arg2, ...);
  
  =head1 DESCRIPTION
  
  Text::MicroTemplate::File is a file-based template manager for L<Text::MicroTemplate>.
  
  =head1 PROPERTIES
  
  Text::MicroTemplate provides OO-style interface with following properties.
  
  =head2 cache
  
  cache mode (0: no cache (default), 1: cache with update check, 2: cache but do not check updates)
  
  =head2 open_layer
  
  layer passed to L<open> (default: ":utf8")
  
  =head2 package_name
  
  package under where template files are compiled (default: "main")
  
  =head1 METHODS
  
  =head2 build_file($file)
  
  Returns a subref that renders given template file.
  
  =head2 render_file($file, @args)
  
  Renders the template file with given arguments.
  
  =head2 wrapper_file($file, @args)->(sub { template lines })
  
  Wraps given template with wrapper file.  Internally the processed template is passed as $_[0] to the wrapper template.
  
  =head1 SEE ALSO
  
  L<Text::MicroTemplate>
  
  =head1 AUTHOR
  
  Kazuho Oku E<lt>kazuhooku gmail.comE<gt>
  
  =head1 LICENSE
  
  This program is free software, you can redistribute it and/or modify it under the same terms as Perl 5.10.
  
  =cut
TEXT_MICROTEMPLATE_FILE

$fatpacked{"Try/Tiny.pm"} = <<'TRY_TINY';
  package Try::Tiny;
  
  use strict;
  #use warnings;
  
  use vars qw(@EXPORT @EXPORT_OK $VERSION @ISA);
  
  BEGIN {
  	require Exporter;
  	@ISA = qw(Exporter);
  }
  
  $VERSION = "0.06";
  
  $VERSION = eval $VERSION;
  
  @EXPORT = @EXPORT_OK = qw(try catch finally);
  
  $Carp::Internal{+__PACKAGE__}++;
  
  # Need to prototype as @ not $$ because of the way Perl evaluates the prototype.
  # Keeping it at $$ means you only ever get 1 sub because we need to eval in a list
  # context & not a scalar one
  
  sub try (&;@) {
  	my ( $try, @code_refs ) = @_;
  
  	# we need to save this here, the eval block will be in scalar context due
  	# to $failed
  	my $wantarray = wantarray;
  
  	my ( $catch, $finally );
  
  	# find labeled blocks in the argument list.
  	# catch and finally tag the blocks by blessing a scalar reference to them.
  	foreach my $code_ref (@code_refs) {
  		next unless $code_ref;
  
  		my $ref = ref($code_ref);
  
  		if ( $ref eq 'Try::Tiny::Catch' ) {
  			$catch = ${$code_ref};
  		} elsif ( $ref eq 'Try::Tiny::Finally' ) {
  			$finally = ${$code_ref};
  		} else {
  			use Carp;
  			confess("Unknown code ref type given '${ref}'. Check your usage & try again");
  		}
  	}
  
  	# save the value of $@ so we can set $@ back to it in the beginning of the eval
  	my $prev_error = $@;
  
  	my ( @ret, $error, $failed );
  
  	# FIXME consider using local $SIG{__DIE__} to accumulate all errors. It's
  	# not perfect, but we could provide a list of additional errors for
  	# $catch->();
  
  	{
  		# localize $@ to prevent clobbering of previous value by a successful
  		# eval.
  		local $@;
  
  		# failed will be true if the eval dies, because 1 will not be returned
  		# from the eval body
  		$failed = not eval {
  			$@ = $prev_error;
  
  			# evaluate the try block in the correct context
  			if ( $wantarray ) {
  				@ret = $try->();
  			} elsif ( defined $wantarray ) {
  				$ret[0] = $try->();
  			} else {
  				$try->();
  			};
  
  			return 1; # properly set $fail to false
  		};
  
  		# copy $@ to $error; when we leave this scope, local $@ will revert $@
  		# back to its previous value
  		$error = $@;
  	}
  
  	# set up a scope guard to invoke the finally block at the end
  	my $guard = $finally && bless \$finally, "Try::Tiny::ScopeGuard";
  
  	# at this point $failed contains a true value if the eval died, even if some
  	# destructor overwrote $@ as the eval was unwinding.
  	if ( $failed ) {
  		# if we got an error, invoke the catch block.
  		if ( $catch ) {
  			# This works like given($error), but is backwards compatible and
  			# sets $_ in the dynamic scope for the body of C<$catch>
  			for ($error) {
  				return $catch->($error);
  			}
  
  			# in case when() was used without an explicit return, the C<for>
  			# loop will be aborted and there's no useful return value
  		}
  
  		return;
  	} else {
  		# no failure, $@ is back to what it was, everything is fine
  		return $wantarray ? @ret : $ret[0];
  	}
  }
  
  sub catch (&;@) {
  	my ( $block, @rest ) = @_;
  
  	return (
  		bless(\$block, 'Try::Tiny::Catch'),
  		@rest,
  	);
  }
  
  sub finally (&;@) {
  	my ( $block, @rest ) = @_;
  
  	return (
  		bless(\$block, 'Try::Tiny::Finally'),
  		@rest,
  	);
  }
  
  sub Try::Tiny::ScopeGuard::DESTROY {
  	my $self = shift;
  	$$self->();
  }
  
  __PACKAGE__
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Try::Tiny - minimal try/catch with proper localization of $@
  
  =head1 SYNOPSIS
  
  	# handle errors with a catch handler
  	try {
  		die "foo";
  	} catch {
  		warn "caught error: $_"; # not $@
  	};
  
  	# just silence errors
  	try {
  		die "foo";
  	};
  
  =head1 DESCRIPTION
  
  This module provides bare bones C<try>/C<catch>/C<finally> statements that are designed to
  minimize common mistakes with eval blocks, and NOTHING else.
  
  This is unlike L<TryCatch> which provides a nice syntax and avoids adding
  another call stack layer, and supports calling C<return> from the try block to
  return from the parent subroutine. These extra features come at a cost of a few
  dependencies, namely L<Devel::Declare> and L<Scope::Upper> which are
  occasionally problematic, and the additional catch filtering uses L<Moose>
  type constraints which may not be desirable either.
  
  The main focus of this module is to provide simple and reliable error handling
  for those having a hard time installing L<TryCatch>, but who still want to
  write correct C<eval> blocks without 5 lines of boilerplate each time.
  
  It's designed to work as correctly as possible in light of the various
  pathological edge cases (see L<BACKGROUND>) and to be compatible with any style
  of error values (simple strings, references, objects, overloaded objects, etc).
  
  If the try block dies, it returns the value of the last statement executed in
  the catch block, if there is one. Otherwise, it returns C<undef> in scalar
  context or the empty list in list context. The following two examples both
  assign C<"bar"> to C<$x>.
  
  	my $x = try { die "foo" } catch { "bar" };
  
  	my $x = eval { die "foo" } || "bar";
  
  You can add finally blocks making the following true.
  
  	my $x;
  	try { die 'foo' } finally { $x = 'bar' };
  	try { die 'foo' } catch { warn "Got a die: $_" } finally { $x = 'bar' };
  
  Finally blocks are always executed making them suitable for cleanup code
  which cannot be handled using local.
  
  =head1 EXPORTS
  
  All functions are exported by default using L<Exporter>.
  
  If you need to rename the C<try>, C<catch> or C<finally> keyword consider using
  L<Sub::Import> to get L<Sub::Exporter>'s flexibility.
  
  =over 4
  
  =item try (&;@)
  
  Takes one mandatory try subroutine, an optional catch subroutine & finally
  subroutine.
  
  The mandatory subroutine is evaluated in the context of an C<eval> block.
  
  If no error occurred the value from the first block is returned, preserving
  list/scalar context.
  
  If there was an error and the second subroutine was given it will be invoked
  with the error in C<$_> (localized) and as that block's first and only
  argument.
  
  C<$@> does B<not> contain the error. Inside the C<catch> block it has the same
  value it had before the C<try> block was executed.
  
  Note that the error may be false, but if that happens the C<catch> block will
  still be invoked.
  
  Once all execution is finished then the finally block if given will execute.
  
  =item catch (&;$)
  
  Intended to be used in the second argument position of C<try>.
  
  Returns a reference to the subroutine it was given but blessed as
  C<Try::Tiny::Catch> which allows try to decode correctly what to do
  with this code reference.
  
  	catch { ... }
  
  Inside the catch block the caught error is stored in C<$_>, while previous
  value of C<$@> is still available for use.  This value may or may not be
  meaningful depending on what happened before the C<try>, but it might be a good
  idea to preserve it in an error stack.
  
  For code that captures C<$@> when throwing new errors (i.e.
  L<Class::Throwable>), you'll need to do:
  
  	local $@ = $_;
  
  =item finally (&;$)
  
    try     { ... }
    catch   { ... }
    finally { ... };
  
  Or
  
    try     { ... }
    finally { ... };
  
  Or even
  
    try     { ... }
    finally { ... }
    catch   { ... };
  
  Intended to be the second or third element of C<try>. Finally blocks are always
  executed in the event of a successful C<try> or if C<catch> is run. This allows
  you to locate cleanup code which cannot be done via C<local()> e.g. closing a file
  handle.
  
  B<You must always do your own error handling in the finally block>. C<Try::Tiny> will
  not do anything about handling possible errors coming from code located in these
  blocks.
  
  In the same way C<catch()> blesses the code reference this subroutine does the same
  except it bless them as C<Try::Tiny::Finally>.
  
  =back
  
  =head1 BACKGROUND
  
  There are a number of issues with C<eval>.
  
  =head2 Clobbering $@
  
  When you run an eval block and it succeeds, C<$@> will be cleared, potentially
  clobbering an error that is currently being caught.
  
  This causes action at a distance, clearing previous errors your caller may have
  not yet handled.
  
  C<$@> must be properly localized before invoking C<eval> in order to avoid this
  issue.
  
  More specifically, C<$@> is clobbered at the beginning of the C<eval>, which
  also makes it impossible to capture the previous error before you die (for
  instance when making exception objects with error stacks).
  
  For this reason C<try> will actually set C<$@> to its previous value (before
  the localization) in the beginning of the C<eval> block.
  
  =head2 Localizing $@ silently masks errors
  
  Inside an eval block C<die> behaves sort of like:
  
  	sub die {
  		$@ = $_[0];
  		return_undef_from_eval();
  	}
  
  This means that if you were polite and localized C<$@> you can't die in that
  scope, or your error will be discarded (printing "Something's wrong" instead).
  
  The workaround is very ugly:
  
  	my $error = do {
  		local $@;
  		eval { ... };
  		$@;
  	};
  
  	...
  	die $error;
  
  =head2 $@ might not be a true value
  
  This code is wrong:
  
  	if ( $@ ) {
  		...
  	}
  
  because due to the previous caveats it may have been unset.
  
  C<$@> could also be an overloaded error object that evaluates to false, but
  that's asking for trouble anyway.
  
  The classic failure mode is:
  
  	sub Object::DESTROY {
  		eval { ... }
  	}
  
  	eval {
  		my $obj = Object->new;
  
  		die "foo";
  	};
  
  	if ( $@ ) {
  
  	}
  
  In this case since C<Object::DESTROY> is not localizing C<$@> but still uses
  C<eval>, it will set C<$@> to C<"">.
  
  The destructor is called when the stack is unwound, after C<die> sets C<$@> to
  C<"foo at Foo.pm line 42\n">, so by the time C<if ( $@ )> is evaluated it has
  been cleared by C<eval> in the destructor.
  
  The workaround for this is even uglier than the previous ones. Even though we
  can't save the value of C<$@> from code that doesn't localize, we can at least
  be sure the eval was aborted due to an error:
  
  	my $failed = not eval {
  		...
  
  		return 1;
  	};
  
  This is because an C<eval> that caught a C<die> will always return a false
  value.
  
  =head1 SHINY SYNTAX
  
  Using Perl 5.10 you can use L<perlsyn/"Switch statements">.
  
  The C<catch> block is invoked in a topicalizer context (like a C<given> block),
  but note that you can't return a useful value from C<catch> using the C<when>
  blocks without an explicit C<return>.
  
  This is somewhat similar to Perl 6's C<CATCH> blocks. You can use it to
  concisely match errors:
  
  	try {
  		require Foo;
  	} catch {
  		when (/^Can't locate .*?\.pm in \@INC/) { } # ignore
  		default { die $_ }
  	};
  
  =head1 CAVEATS
  
  =over 4
  
  =item *
  
  C<@_> is not available, you need to name your args:
  
  	sub foo {
  		my ( $self, @args ) = @_;
  		try { $self->bar(@args) }
  	}
  
  =item *
  
  C<return> returns from the C<try> block, not from the parent sub (note that
  this is also how C<eval> works, but not how L<TryCatch> works):
  
  	sub bar {
  		try { return "foo" };
  		return "baz";
  	}
  
  	say bar(); # "baz"
  
  =item *
  
  C<try> introduces another caller stack frame. L<Sub::Uplevel> is not used. L<Carp>
  will not report this when using full stack traces, though, because
  C<%Carp::Internal> is used. This lack of magic is considered a feature.
  
  =item *
  
  The value of C<$_> in the C<catch> block is not guaranteed to be the value of
  the exception thrown (C<$@>) in the C<try> block.  There is no safe way to
  ensure this, since C<eval> may be used unhygenically in destructors.  The only
  guarantee is that the C<catch> will be called if an exception is thrown.
  
  =item *
  
  The return value of the C<catch> block is not ignored, so if testing the result
  of the expression for truth on success, be sure to return a false value from
  the C<catch> block:
  
  	my $obj = try {
  		MightFail->new;
  	} catch {
  		...
  
  		return; # avoid returning a true value;
  	};
  
  	return unless $obj;
  
  =item *
  
  C<$SIG{__DIE__}> is still in effect.
  
  Though it can be argued that C<$SIG{__DIE__}> should be disabled inside of
  C<eval> blocks, since it isn't people have grown to rely on it. Therefore in
  the interests of compatibility, C<try> does not disable C<$SIG{__DIE__}> for
  the scope of the error throwing code.
  
  =item *
  
  Lexical C<$_> may override the one set by C<catch>.
  
  For example Perl 5.10's C<given> form uses a lexical C<$_>, creating some
  confusing behavior:
  
  	given ($foo) {
  		when (...) {
  			try {
  				...
  			} catch {
  				warn $_; # will print $foo, not the error
  				warn $_[0]; # instead, get the error like this
  			}
  		}
  	}
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<TryCatch>
  
  Much more feature complete, more convenient semantics, but at the cost of
  implementation complexity.
  
  =item L<autodie>
  
  Automatic error throwing for builtin functions and more. Also designed to
  work well with C<given>/C<when>.
  
  =item L<Throwable>
  
  A lightweight role for rolling your own exception classes.
  
  =item L<Error>
  
  Exception object implementation with a C<try> statement. Does not localize
  C<$@>.
  
  =item L<Exception::Class::TryCatch>
  
  Provides a C<catch> statement, but properly calling C<eval> is your
  responsibility.
  
  The C<try> keyword pushes C<$@> onto an error stack, avoiding some of the
  issues with C<$@>, but you still need to localize to prevent clobbering.
  
  =back
  
  =head1 LIGHTNING TALK
  
  I gave a lightning talk about this module, you can see the slides (Firefox
  only):
  
  L<http://nothingmuch.woobling.org/talks/takahashi.xul?data=yapc_asia_2009/try_tiny.txt>
  
  Or read the source:
  
  L<http://nothingmuch.woobling.org/talks/yapc_asia_2009/try_tiny.yml>
  
  =head1 VERSION CONTROL
  
  L<http://github.com/nothingmuch/try-tiny/>
  
  =head1 AUTHOR
  
  Yuval Kogman E<lt>nothingmuch@woobling.orgE<gt>
  
  =head1 COPYRIGHT
  
  	Copyright (c) 2009 Yuval Kogman. All rights reserved.
  	This program is free software; you can redistribute
  	it and/or modify it under the terms of the MIT license.
  
  =cut
  
TRY_TINY

$fatpacked{"URI.pm"} = <<'URI';
  package URI;
  
  use strict;
  use vars qw($VERSION);
  $VERSION = "1.54";
  
  use vars qw($ABS_REMOTE_LEADING_DOTS $ABS_ALLOW_RELATIVE_SCHEME $DEFAULT_QUERY_FORM_DELIMITER);
  
  my %implements;  # mapping from scheme to implementor class
  
  # Some "official" character classes
  
  use vars qw($reserved $mark $unreserved $uric $scheme_re);
  $reserved   = q(;/?:@&=+$,[]);
  $mark       = q(-_.!~*'());                                    #'; emacs
  $unreserved = "A-Za-z0-9\Q$mark\E";
  $uric       = quotemeta($reserved) . $unreserved . "%";
  
  $scheme_re  = '[a-zA-Z][a-zA-Z0-9.+\-]*';
  
  use Carp ();
  use URI::Escape ();
  
  use overload ('""'     => sub { ${$_[0]} },
                '=='     => sub { _obj_eq(@_) },
                '!='     => sub { !_obj_eq(@_) },
                fallback => 1,
               );
  
  # Check if two objects are the same object
  sub _obj_eq {
      return overload::StrVal($_[0]) eq overload::StrVal($_[1]);
  }
  
  sub new
  {
      my($class, $uri, $scheme) = @_;
  
      $uri = defined ($uri) ? "$uri" : "";   # stringify
      # Get rid of potential wrapping
      $uri =~ s/^<(?:URL:)?(.*)>$/$1/;  # 
      $uri =~ s/^"(.*)"$/$1/;
      $uri =~ s/^\s+//;
      $uri =~ s/\s+$//;
  
      my $impclass;
      if ($uri =~ m/^($scheme_re):/so) {
  	$scheme = $1;
      }
      else {
  	if (($impclass = ref($scheme))) {
  	    $scheme = $scheme->scheme;
  	}
  	elsif ($scheme && $scheme =~ m/^($scheme_re)(?::|$)/o) {
  	    $scheme = $1;
          }
      }
      $impclass ||= implementor($scheme) ||
  	do {
  	    require URI::_foreign;
  	    $impclass = 'URI::_foreign';
  	};
  
      return $impclass->_init($uri, $scheme);
  }
  
  
  sub new_abs
  {
      my($class, $uri, $base) = @_;
      $uri = $class->new($uri, $base);
      $uri->abs($base);
  }
  
  
  sub _init
  {
      my $class = shift;
      my($str, $scheme) = @_;
      # find all funny characters and encode the bytes.
      $str = $class->_uric_escape($str);
      $str = "$scheme:$str" unless $str =~ /^$scheme_re:/o ||
                                   $class->_no_scheme_ok;
      my $self = bless \$str, $class;
      $self;
  }
  
  
  sub _uric_escape
  {
      my($class, $str) = @_;
      $str =~ s*([^$uric\#])* URI::Escape::escape_char($1) *ego;
      return $str;
  }
  
  
  sub implementor
  {
      my($scheme, $impclass) = @_;
      if (!$scheme || $scheme !~ /\A$scheme_re\z/o) {
  	require URI::_generic;
  	return "URI::_generic";
      }
  
      $scheme = lc($scheme);
  
      if ($impclass) {
  	# Set the implementor class for a given scheme
          my $old = $implements{$scheme};
          $impclass->_init_implementor($scheme);
          $implements{$scheme} = $impclass;
          return $old;
      }
  
      my $ic = $implements{$scheme};
      return $ic if $ic;
  
      # scheme not yet known, look for internal or
      # preloaded (with 'use') implementation
      $ic = "URI::$scheme";  # default location
  
      # turn scheme into a valid perl identifier by a simple transformation...
      $ic =~ s/\+/_P/g;
      $ic =~ s/\./_O/g;
      $ic =~ s/\-/_/g;
  
      no strict 'refs';
      # check we actually have one for the scheme:
      unless (@{"${ic}::ISA"}) {
          # Try to load it
          eval "require $ic";
          die $@ if $@ && $@ !~ /Can\'t locate.*in \@INC/;
          return unless @{"${ic}::ISA"};
      }
  
      $ic->_init_implementor($scheme);
      $implements{$scheme} = $ic;
      $ic;
  }
  
  
  sub _init_implementor
  {
      my($class, $scheme) = @_;
      # Remember that one implementor class may actually
      # serve to implement several URI schemes.
  }
  
  
  sub clone
  {
      my $self = shift;
      my $other = $$self;
      bless \$other, ref $self;
  }
  
  
  sub _no_scheme_ok { 0 }
  
  sub _scheme
  {
      my $self = shift;
  
      unless (@_) {
  	return unless $$self =~ /^($scheme_re):/o;
  	return $1;
      }
  
      my $old;
      my $new = shift;
      if (defined($new) && length($new)) {
  	Carp::croak("Bad scheme '$new'") unless $new =~ /^$scheme_re$/o;
  	$old = $1 if $$self =~ s/^($scheme_re)://o;
  	my $newself = URI->new("$new:$$self");
  	$$self = $$newself; 
  	bless $self, ref($newself);
      }
      else {
  	if ($self->_no_scheme_ok) {
  	    $old = $1 if $$self =~ s/^($scheme_re)://o;
  	    Carp::carp("Oops, opaque part now look like scheme")
  		if $^W && $$self =~ m/^$scheme_re:/o
  	}
  	else {
  	    $old = $1 if $$self =~ m/^($scheme_re):/o;
  	}
      }
  
      return $old;
  }
  
  sub scheme
  {
      my $scheme = shift->_scheme(@_);
      return unless defined $scheme;
      lc($scheme);
  }
  
  
  sub opaque
  {
      my $self = shift;
  
      unless (@_) {
  	$$self =~ /^(?:$scheme_re:)?([^\#]*)/o or die;
  	return $1;
      }
  
      $$self =~ /^($scheme_re:)?    # optional scheme
  	        ([^\#]*)          # opaque
                  (\#.*)?           # optional fragment
                $/sx or die;
  
      my $old_scheme = $1;
      my $old_opaque = $2;
      my $old_frag   = $3;
  
      my $new_opaque = shift;
      $new_opaque = "" unless defined $new_opaque;
      $new_opaque =~ s/([^$uric])/ URI::Escape::escape_char($1)/ego;
  
      $$self = defined($old_scheme) ? $old_scheme : "";
      $$self .= $new_opaque;
      $$self .= $old_frag if defined $old_frag;
  
      $old_opaque;
  }
  
  *path = \&opaque;  # alias
  
  
  sub fragment
  {
      my $self = shift;
      unless (@_) {
  	return unless $$self =~ /\#(.*)/s;
  	return $1;
      }
  
      my $old;
      $old = $1 if $$self =~ s/\#(.*)//s;
  
      my $new_frag = shift;
      if (defined $new_frag) {
  	$new_frag =~ s/([^$uric])/ URI::Escape::escape_char($1) /ego;
  	$$self .= "#$new_frag";
      }
      $old;
  }
  
  
  sub as_string
  {
      my $self = shift;
      $$self;
  }
  
  
  sub as_iri
  {
      my $self = shift;
      my $str = $$self;
      if ($str =~ s/%([89a-fA-F][0-9a-fA-F])/chr(hex($1))/eg) {
  	# All this crap because the more obvious:
  	#
  	#   Encode::decode("UTF-8", $str, sub { sprintf "%%%02X", shift })
  	#
  	# doesn't work before Encode 2.39.  Wait for a standard release
  	# to bundle that version.
  
  	require Encode;
  	my $enc = Encode::find_encoding("UTF-8");
  	my $u = "";
  	while (length $str) {
  	    $u .= $enc->decode($str, Encode::FB_QUIET());
  	    if (length $str) {
  		# escape next char
  		$u .= URI::Escape::escape_char(substr($str, 0, 1, ""));
  	    }
  	}
  	$str = $u;
      }
      return $str;
  }
  
  
  sub canonical
  {
      # Make sure scheme is lowercased, that we don't escape unreserved chars,
      # and that we use upcase escape sequences.
  
      my $self = shift;
      my $scheme = $self->_scheme || "";
      my $uc_scheme = $scheme =~ /[A-Z]/;
      my $esc = $$self =~ /%[a-fA-F0-9]{2}/;
      return $self unless $uc_scheme || $esc;
  
      my $other = $self->clone;
      if ($uc_scheme) {
  	$other->_scheme(lc $scheme);
      }
      if ($esc) {
  	$$other =~ s{%([0-9a-fA-F]{2})}
  	            { my $a = chr(hex($1));
                        $a =~ /^[$unreserved]\z/o ? $a : "%\U$1"
                      }ge;
      }
      return $other;
  }
  
  # Compare two URIs, subclasses will provide a more correct implementation
  sub eq {
      my($self, $other) = @_;
      $self  = URI->new($self, $other) unless ref $self;
      $other = URI->new($other, $self) unless ref $other;
      ref($self) eq ref($other) &&                # same class
  	$self->canonical->as_string eq $other->canonical->as_string;
  }
  
  # generic-URI transformation methods
  sub abs { $_[0]; }
  sub rel { $_[0]; }
  
  sub secure { 0 }
  
  # help out Storable
  sub STORABLE_freeze {
         my($self, $cloning) = @_;
         return $$self;
  }
  
  sub STORABLE_thaw {
         my($self, $cloning, $str) = @_;
         $$self = $str;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI - Uniform Resource Identifiers (absolute and relative)
  
  =head1 SYNOPSIS
  
   $u1 = URI->new("http://www.perl.com");
   $u2 = URI->new("foo", "http");
   $u3 = $u2->abs($u1);
   $u4 = $u3->clone;
   $u5 = URI->new("HTTP://WWW.perl.com:80")->canonical;
  
   $str = $u->as_string;
   $str = "$u";
  
   $scheme = $u->scheme;
   $opaque = $u->opaque;
   $path   = $u->path;
   $frag   = $u->fragment;
  
   $u->scheme("ftp");
   $u->host("ftp.perl.com");
   $u->path("cpan/");
  
  =head1 DESCRIPTION
  
  This module implements the C<URI> class.  Objects of this class
  represent "Uniform Resource Identifier references" as specified in RFC
  2396 (and updated by RFC 2732).
  
  A Uniform Resource Identifier is a compact string of characters that
  identifies an abstract or physical resource.  A Uniform Resource
  Identifier can be further classified as either a Uniform Resource Locator
  (URL) or a Uniform Resource Name (URN).  The distinction between URL
  and URN does not matter to the C<URI> class interface. A
  "URI-reference" is a URI that may have additional information attached
  in the form of a fragment identifier.
  
  An absolute URI reference consists of three parts:  a I<scheme>, a
  I<scheme-specific part> and a I<fragment> identifier.  A subset of URI
  references share a common syntax for hierarchical namespaces.  For
  these, the scheme-specific part is further broken down into
  I<authority>, I<path> and I<query> components.  These URIs can also
  take the form of relative URI references, where the scheme (and
  usually also the authority) component is missing, but implied by the
  context of the URI reference.  The three forms of URI reference
  syntax are summarized as follows:
  
    <scheme>:<scheme-specific-part>#<fragment>
    <scheme>://<authority><path>?<query>#<fragment>
    <path>?<query>#<fragment>
  
  The components into which a URI reference can be divided depend on the
  I<scheme>.  The C<URI> class provides methods to get and set the
  individual components.  The methods available for a specific
  C<URI> object depend on the scheme.
  
  =head1 CONSTRUCTORS
  
  The following methods construct new C<URI> objects:
  
  =over 4
  
  =item $uri = URI->new( $str )
  
  =item $uri = URI->new( $str, $scheme )
  
  Constructs a new URI object.  The string
  representation of a URI is given as argument, together with an optional
  scheme specification.  Common URI wrappers like "" and <>, as well as
  leading and trailing white space, are automatically removed from
  the $str argument before it is processed further.
  
  The constructor determines the scheme, maps this to an appropriate
  URI subclass, constructs a new object of that class and returns it.
  
  The $scheme argument is only used when $str is a
  relative URI.  It can be either a simple string that
  denotes the scheme, a string containing an absolute URI reference, or
  an absolute C<URI> object.  If no $scheme is specified for a relative
  URI $str, then $str is simply treated as a generic URI (no scheme-specific
  methods available).
  
  The set of characters available for building URI references is
  restricted (see L<URI::Escape>).  Characters outside this set are
  automatically escaped by the URI constructor.
  
  =item $uri = URI->new_abs( $str, $base_uri )
  
  Constructs a new absolute URI object.  The $str argument can
  denote a relative or absolute URI.  If relative, then it is
  absolutized using $base_uri as base. The $base_uri must be an absolute
  URI.
  
  =item $uri = URI::file->new( $filename )
  
  =item $uri = URI::file->new( $filename, $os )
  
  Constructs a new I<file> URI from a file name.  See L<URI::file>.
  
  =item $uri = URI::file->new_abs( $filename )
  
  =item $uri = URI::file->new_abs( $filename, $os )
  
  Constructs a new absolute I<file> URI from a file name.  See
  L<URI::file>.
  
  =item $uri = URI::file->cwd
  
  Returns the current working directory as a I<file> URI.  See
  L<URI::file>.
  
  =item $uri->clone
  
  Returns a copy of the $uri.
  
  =back
  
  =head1 COMMON METHODS
  
  The methods described in this section are available for all C<URI>
  objects.
  
  Methods that give access to components of a URI always return the
  old value of the component.  The value returned is C<undef> if the
  component was not present.  There is generally a difference between a
  component that is empty (represented as C<"">) and a component that is
  missing (represented as C<undef>).  If an accessor method is given an
  argument, it updates the corresponding component in addition to
  returning the old value of the component.  Passing an undefined
  argument removes the component (if possible).  The description of
  each accessor method indicates whether the component is passed as
  an escaped or an unescaped string.  A component that can be further
  divided into sub-parts are usually passed escaped, as unescaping might
  change its semantics.
  
  The common methods available for all URI are:
  
  =over 4
  
  =item $uri->scheme
  
  =item $uri->scheme( $new_scheme )
  
  Sets and returns the scheme part of the $uri.  If the $uri is
  relative, then $uri->scheme returns C<undef>.  If called with an
  argument, it updates the scheme of $uri, possibly changing the
  class of $uri, and returns the old scheme value.  The method croaks
  if the new scheme name is illegal; a scheme name must begin with a
  letter and must consist of only US-ASCII letters, numbers, and a few
  special marks: ".", "+", "-".  This restriction effectively means
  that the scheme must be passed unescaped.  Passing an undefined
  argument to the scheme method makes the URI relative (if possible).
  
  Letter case does not matter for scheme names.  The string
  returned by $uri->scheme is always lowercase.  If you want the scheme
  just as it was written in the URI in its original case,
  you can use the $uri->_scheme method instead.
  
  =item $uri->opaque
  
  =item $uri->opaque( $new_opaque )
  
  Sets and returns the scheme-specific part of the $uri
  (everything between the scheme and the fragment)
  as an escaped string.
  
  =item $uri->path
  
  =item $uri->path( $new_path )
  
  Sets and returns the same value as $uri->opaque unless the URI
  supports the generic syntax for hierarchical namespaces.
  In that case the generic method is overridden to set and return
  the part of the URI between the I<host name> and the I<fragment>.
  
  =item $uri->fragment
  
  =item $uri->fragment( $new_frag )
  
  Returns the fragment identifier of a URI reference
  as an escaped string.
  
  =item $uri->as_string
  
  Returns a URI object to a plain ASCII string.  URI objects are
  also converted to plain strings automatically by overloading.  This
  means that $uri objects can be used as plain strings in most Perl
  constructs.
  
  =item $uri->as_iri
  
  Returns a Unicode string representing the URI.  Escaped UTF-8 sequences
  representing non-ASCII characters are turned into their corresponding Unicode
  code point.
  
  =item $uri->canonical
  
  Returns a normalized version of the URI.  The rules
  for normalization are scheme-dependent.  They usually involve
  lowercasing the scheme and Internet host name components,
  removing the explicit port specification if it matches the default port,
  uppercasing all escape sequences, and unescaping octets that can be
  better represented as plain characters.
  
  For efficiency reasons, if the $uri is already in normalized form,
  then a reference to it is returned instead of a copy.
  
  =item $uri->eq( $other_uri )
  
  =item URI::eq( $first_uri, $other_uri )
  
  Tests whether two URI references are equal.  URI references
  that normalize to the same string are considered equal.  The method
  can also be used as a plain function which can also test two string
  arguments.
  
  If you need to test whether two C<URI> object references denote the
  same object, use the '==' operator.
  
  =item $uri->abs( $base_uri )
  
  Returns an absolute URI reference.  If $uri is already
  absolute, then a reference to it is simply returned.  If the $uri
  is relative, then a new absolute URI is constructed by combining the
  $uri and the $base_uri, and returned.
  
  =item $uri->rel( $base_uri )
  
  Returns a relative URI reference if it is possible to
  make one that denotes the same resource relative to $base_uri.
  If not, then $uri is simply returned.
  
  =item $uri->secure
  
  Returns a TRUE value if the URI is considered to point to a resource on
  a secure channel, such as an SSL or TLS encrypted one.
  
  =back
  
  =head1 GENERIC METHODS
  
  The following methods are available to schemes that use the
  common/generic syntax for hierarchical namespaces.  The descriptions of
  schemes below indicate which these are.  Unknown schemes are
  assumed to support the generic syntax, and therefore the following
  methods:
  
  =over 4
  
  =item $uri->authority
  
  =item $uri->authority( $new_authority )
  
  Sets and returns the escaped authority component
  of the $uri.
  
  =item $uri->path
  
  =item $uri->path( $new_path )
  
  Sets and returns the escaped path component of
  the $uri (the part between the host name and the query or fragment).
  The path can never be undefined, but it can be the empty string.
  
  =item $uri->path_query
  
  =item $uri->path_query( $new_path_query )
  
  Sets and returns the escaped path and query
  components as a single entity.  The path and the query are
  separated by a "?" character, but the query can itself contain "?".
  
  =item $uri->path_segments
  
  =item $uri->path_segments( $segment, ... )
  
  Sets and returns the path.  In a scalar context, it returns
  the same value as $uri->path.  In a list context, it returns the
  unescaped path segments that make up the path.  Path segments that
  have parameters are returned as an anonymous array.  The first element
  is the unescaped path segment proper;  subsequent elements are escaped
  parameter strings.  Such an anonymous array uses overloading so it can
  be treated as a string too, but this string does not include the
  parameters.
  
  Note that absolute paths have the empty string as their first
  I<path_segment>, i.e. the I<path> C</foo/bar> have 3
  I<path_segments>; "", "foo" and "bar".
  
  =item $uri->query
  
  =item $uri->query( $new_query )
  
  Sets and returns the escaped query component of
  the $uri.
  
  =item $uri->query_form
  
  =item $uri->query_form( $key1 => $val1, $key2 => $val2, ... )
  
  =item $uri->query_form( $key1 => $val1, $key2 => $val2, ..., $delim )
  
  =item $uri->query_form( \@key_value_pairs )
  
  =item $uri->query_form( \@key_value_pairs, $delim )
  
  =item $uri->query_form( \%hash )
  
  =item $uri->query_form( \%hash, $delim )
  
  Sets and returns query components that use the
  I<application/x-www-form-urlencoded> format.  Key/value pairs are
  separated by "&", and the key is separated from the value by a "="
  character.
  
  The form can be set either by passing separate key/value pairs, or via
  an array or hash reference.  Passing an empty array or an empty hash
  removes the query component, whereas passing no arguments at all leaves
  the component unchanged.  The order of keys is undefined if a hash
  reference is passed.  The old value is always returned as a list of
  separate key/value pairs.  Assigning this list to a hash is unwise as
  the keys returned might repeat.
  
  The values passed when setting the form can be plain strings or
  references to arrays of strings.  Passing an array of values has the
  same effect as passing the key repeatedly with one value at a time.
  All the following statements have the same effect:
  
      $uri->query_form(foo => 1, foo => 2);
      $uri->query_form(foo => [1, 2]);
      $uri->query_form([ foo => 1, foo => 2 ]);
      $uri->query_form([ foo => [1, 2] ]);
      $uri->query_form({ foo => [1, 2] });
  
  The $delim parameter can be passed as ";" to force the key/value pairs
  to be delimited by ";" instead of "&" in the query string.  This
  practice is often recommended for URLs embedded in HTML or XML
  documents as this avoids the trouble of escaping the "&" character.
  You might also set the $URI::DEFAULT_QUERY_FORM_DELIMITER variable to
  ";" for the same global effect.
  
  The C<URI::QueryParam> module can be loaded to add further methods to
  manipulate the form of a URI.  See L<URI::QueryParam> for details.
  
  =item $uri->query_keywords
  
  =item $uri->query_keywords( $keywords, ... )
  
  =item $uri->query_keywords( \@keywords )
  
  Sets and returns query components that use the
  keywords separated by "+" format.
  
  The keywords can be set either by passing separate keywords directly
  or by passing a reference to an array of keywords.  Passing an empty
  array removes the query component, whereas passing no arguments at
  all leaves the component unchanged.  The old value is always returned
  as a list of separate words.
  
  =back
  
  =head1 SERVER METHODS
  
  For schemes where the I<authority> component denotes an Internet host,
  the following methods are available in addition to the generic
  methods.
  
  =over 4
  
  =item $uri->userinfo
  
  =item $uri->userinfo( $new_userinfo )
  
  Sets and returns the escaped userinfo part of the
  authority component.
  
  For some schemes this is a user name and a password separated by
  a colon.  This practice is not recommended. Embedding passwords in
  clear text (such as URI) has proven to be a security risk in almost
  every case where it has been used.
  
  =item $uri->host
  
  =item $uri->host( $new_host )
  
  Sets and returns the unescaped hostname.
  
  If the $new_host string ends with a colon and a number, then this
  number also sets the port.
  
  For IPv6 addresses the brackets around the raw address is removed in the return
  value from $uri->host.  When setting the host attribute to an IPv6 address you
  can use a raw address or one enclosed in brackets.  The address needs to be
  enclosed in brackets if you want to pass in a new port value as well.
  
  =item $uri->ihost
  
  Returns the host in Unicode form.  Any IDNA A-labels are turned into U-labels.
  
  =item $uri->port
  
  =item $uri->port( $new_port )
  
  Sets and returns the port.  The port is a simple integer
  that should be greater than 0.
  
  If a port is not specified explicitly in the URI, then the URI scheme's default port
  is returned. If you don't want the default port
  substituted, then you can use the $uri->_port method instead.
  
  =item $uri->host_port
  
  =item $uri->host_port( $new_host_port )
  
  Sets and returns the host and port as a single
  unit.  The returned value includes a port, even if it matches the
  default port.  The host part and the port part are separated by a
  colon: ":".
  
  For IPv6 addresses the bracketing is preserved; thus
  URI->new("http://[::1]/")->host_port returns "[::1]:80".  Contrast this with
  $uri->host which will remove the brackets.
  
  =item $uri->default_port
  
  Returns the default port of the URI scheme to which $uri
  belongs.  For I<http> this is the number 80, for I<ftp> this
  is the number 21, etc.  The default port for a scheme can not be
  changed.
  
  =back
  
  =head1 SCHEME-SPECIFIC SUPPORT
  
  Scheme-specific support is provided for the following URI schemes.  For C<URI>
  objects that do not belong to one of these, you can only use the common and
  generic methods.
  
  =over 4
  
  =item B<data>:
  
  The I<data> URI scheme is specified in RFC 2397.  It allows inclusion
  of small data items as "immediate" data, as if it had been included
  externally.
  
  C<URI> objects belonging to the data scheme support the common methods
  and two new methods to access their scheme-specific components:
  $uri->media_type and $uri->data.  See L<URI::data> for details.
  
  =item B<file>:
  
  An old specification of the I<file> URI scheme is found in RFC 1738.
  A new RFC 2396 based specification in not available yet, but file URI
  references are in common use.
  
  C<URI> objects belonging to the file scheme support the common and
  generic methods.  In addition, they provide two methods for mapping file URIs
  back to local file names; $uri->file and $uri->dir.  See L<URI::file>
  for details.
  
  =item B<ftp>:
  
  An old specification of the I<ftp> URI scheme is found in RFC 1738.  A
  new RFC 2396 based specification in not available yet, but ftp URI
  references are in common use.
  
  C<URI> objects belonging to the ftp scheme support the common,
  generic and server methods.  In addition, they provide two methods for
  accessing the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<gopher>:
  
  The I<gopher> URI scheme is specified in
  <draft-murali-url-gopher-1996-12-04> and will hopefully be available
  as a RFC 2396 based specification.
  
  C<URI> objects belonging to the gopher scheme support the common,
  generic and server methods. In addition, they support some methods for
  accessing gopher-specific path components: $uri->gopher_type,
  $uri->selector, $uri->search, $uri->string.
  
  =item B<http>:
  
  The I<http> URI scheme is specified in RFC 2616.
  The scheme is used to reference resources hosted by HTTP servers.
  
  C<URI> objects belonging to the http scheme support the common,
  generic and server methods.
  
  =item B<https>:
  
  The I<https> URI scheme is a Netscape invention which is commonly
  implemented.  The scheme is used to reference HTTP servers through SSL
  connections.  Its syntax is the same as http, but the default
  port is different.
  
  =item B<ldap>:
  
  The I<ldap> URI scheme is specified in RFC 2255.  LDAP is the
  Lightweight Directory Access Protocol.  An ldap URI describes an LDAP
  search operation to perform to retrieve information from an LDAP
  directory.
  
  C<URI> objects belonging to the ldap scheme support the common,
  generic and server methods as well as ldap-specific methods: $uri->dn,
  $uri->attributes, $uri->scope, $uri->filter, $uri->extensions.  See
  L<URI::ldap> for details.
  
  =item B<ldapi>:
  
  Like the I<ldap> URI scheme, but uses a UNIX domain socket.  The
  server methods are not supported, and the local socket path is
  available as $uri->un_path.  The I<ldapi> scheme is used by the
  OpenLDAP package.  There is no real specification for it, but it is
  mentioned in various OpenLDAP manual pages.
  
  =item B<ldaps>:
  
  Like the I<ldap> URI scheme, but uses an SSL connection.  This
  scheme is deprecated, as the preferred way is to use the I<start_tls>
  mechanism.
  
  =item B<mailto>:
  
  The I<mailto> URI scheme is specified in RFC 2368.  The scheme was
  originally used to designate the Internet mailing address of an
  individual or service.  It has (in RFC 2368) been extended to allow
  setting of other mail header fields and the message body.
  
  C<URI> objects belonging to the mailto scheme support the common
  methods and the generic query methods.  In addition, they support the
  following mailto-specific methods: $uri->to, $uri->headers.
  
  Note that the "foo@example.com" part of a mailto is I<not> the
  C<userinfo> and C<host> but instead the C<path>.  This allows a
  mailto URI to contain multiple comma separated email addresses.
  
  =item B<mms>:
  
  The I<mms> URL specification can be found at L<http://sdp.ppona.com/>.
  C<URI> objects belonging to the mms scheme support the common,
  generic, and server methods, with the exception of userinfo and
  query-related sub-components.
  
  =item B<news>:
  
  The I<news>, I<nntp> and I<snews> URI schemes are specified in
  <draft-gilman-news-url-01> and will hopefully be available as an RFC
  2396 based specification soon.
  
  C<URI> objects belonging to the news scheme support the common,
  generic and server methods.  In addition, they provide some methods to
  access the path: $uri->group and $uri->message.
  
  =item B<nntp>:
  
  See I<news> scheme.
  
  =item B<pop>:
  
  The I<pop> URI scheme is specified in RFC 2384. The scheme is used to
  reference a POP3 mailbox.
  
  C<URI> objects belonging to the pop scheme support the common, generic
  and server methods.  In addition, they provide two methods to access the
  userinfo components: $uri->user and $uri->auth
  
  =item B<rlogin>:
  
  An old specification of the I<rlogin> URI scheme is found in RFC
  1738. C<URI> objects belonging to the rlogin scheme support the
  common, generic and server methods.
  
  =item B<rtsp>:
  
  The I<rtsp> URL specification can be found in section 3.2 of RFC 2326.
  C<URI> objects belonging to the rtsp scheme support the common,
  generic, and server methods, with the exception of userinfo and
  query-related sub-components.
  
  =item B<rtspu>:
  
  The I<rtspu> URI scheme is used to talk to RTSP servers over UDP
  instead of TCP.  The syntax is the same as rtsp.
  
  =item B<rsync>:
  
  Information about rsync is available from L<http://rsync.samba.org/>.
  C<URI> objects belonging to the rsync scheme support the common,
  generic and server methods.  In addition, they provide methods to
  access the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<sip>:
  
  The I<sip> URI specification is described in sections 19.1 and 25
  of RFC 3261.  C<URI> objects belonging to the sip scheme support the
  common, generic, and server methods with the exception of path related
  sub-components.  In addition, they provide two methods to get and set
  I<sip> parameters: $uri->params_form and $uri->params.
  
  =item B<sips>:
  
  See I<sip> scheme.  Its syntax is the same as sip, but the default
  port is different.
  
  =item B<snews>:
  
  See I<news> scheme.  Its syntax is the same as news, but the default
  port is different.
  
  =item B<telnet>:
  
  An old specification of the I<telnet> URI scheme is found in RFC
  1738. C<URI> objects belonging to the telnet scheme support the
  common, generic and server methods.
  
  =item B<tn3270>:
  
  These URIs are used like I<telnet> URIs but for connections to IBM
  mainframes.  C<URI> objects belonging to the tn3270 scheme support the
  common, generic and server methods.
  
  =item B<ssh>:
  
  Information about ssh is available at L<http://www.openssh.com/>.
  C<URI> objects belonging to the ssh scheme support the common,
  generic and server methods. In addition, they provide methods to
  access the userinfo sub-components: $uri->user and $uri->password.
  
  =item B<urn>:
  
  The syntax of Uniform Resource Names is specified in RFC 2141.  C<URI>
  objects belonging to the urn scheme provide the common methods, and also the
  methods $uri->nid and $uri->nss, which return the Namespace Identifier
  and the Namespace-Specific String respectively.
  
  The Namespace Identifier basically works like the Scheme identifier of
  URIs, and further divides the URN namespace.  Namespace Identifier
  assignments are maintained at
  L<http://www.iana.org/assignments/urn-namespaces>.
  
  Letter case is not significant for the Namespace Identifier.  It is
  always returned in lower case by the $uri->nid method.  The $uri->_nid
  method can be used if you want it in its original case.
  
  =item B<urn>:B<isbn>:
  
  The C<urn:isbn:> namespace contains International Standard Book
  Numbers (ISBNs) and is described in RFC 3187.  A C<URI> object belonging
  to this namespace has the following extra methods (if the
  Business::ISBN module is available): $uri->isbn,
  $uri->isbn_publisher_code, $uri->isbn_group_code (formerly isbn_country_code,
  which is still supported by issues a deprecation warning), $uri->isbn_as_ean.
  
  =item B<urn>:B<oid>:
  
  The C<urn:oid:> namespace contains Object Identifiers (OIDs) and is
  described in RFC 3061.  An object identifier consists of sequences of digits
  separated by dots.  A C<URI> object belonging to this namespace has an
  additional method called $uri->oid that can be used to get/set the oid
  value.  In a list context, oid numbers are returned as separate elements.
  
  =back
  
  =head1 CONFIGURATION VARIABLES
  
  The following configuration variables influence how the class and its
  methods behave:
  
  =over 4
  
  =item $URI::ABS_ALLOW_RELATIVE_SCHEME
  
  Some older parsers used to allow the scheme name to be present in the
  relative URL if it was the same as the base URL scheme.  RFC 2396 says
  that this should be avoided, but you can enable this old behaviour by
  setting the $URI::ABS_ALLOW_RELATIVE_SCHEME variable to a TRUE value.
  The difference is demonstrated by the following examples:
  
    URI->new("http:foo")->abs("http://host/a/b")
        ==>  "http:foo"
  
    local $URI::ABS_ALLOW_RELATIVE_SCHEME = 1;
    URI->new("http:foo")->abs("http://host/a/b")
        ==>  "http:/host/a/foo"
  
  
  =item $URI::ABS_REMOTE_LEADING_DOTS
  
  You can also have the abs() method ignore excess ".."
  segments in the relative URI by setting $URI::ABS_REMOTE_LEADING_DOTS
  to a TRUE value.  The difference is demonstrated by the following
  examples:
  
    URI->new("../../../foo")->abs("http://host/a/b")
        ==> "http://host/../../foo"
  
    local $URI::ABS_REMOTE_LEADING_DOTS = 1;
    URI->new("../../../foo")->abs("http://host/a/b")
        ==> "http://host/foo"
  
  =item $URI::DEFAULT_QUERY_FORM_DELIMITER
  
  This value can be set to ";" to have the query form C<key=value> pairs
  delimited by ";" instead of "&" which is the default.
  
  =back
  
  =head1 BUGS
  
  Using regexp variables like $1 directly as arguments to the URI methods
  does not work too well with current perl implementations.  I would argue
  that this is actually a bug in perl.  The workaround is to quote
  them. Example:
  
     /(...)/ || die;
     $u->query("$1");
  
  =head1 PARSING URIs WITH REGEXP
  
  As an alternative to this module, the following (official) regular
  expression can be used to decode a URI:
  
    my($scheme, $authority, $path, $query, $fragment) =
    $uri =~ m|(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?|;
  
  The C<URI::Split> module provides the function uri_split() as a
  readable alternative.
  
  =head1 SEE ALSO
  
  L<URI::file>, L<URI::WithBase>, L<URI::QueryParam>, L<URI::Escape>,
  L<URI::Split>, L<URI::Heuristic>
  
  RFC 2396: "Uniform Resource Identifiers (URI): Generic Syntax",
  Berners-Lee, Fielding, Masinter, August 1998.
  
  L<http://www.iana.org/assignments/uri-schemes>
  
  L<http://www.iana.org/assignments/urn-namespaces>
  
  L<http://www.w3.org/Addressing/>
  
  =head1 COPYRIGHT
  
  Copyright 1995-2009 Gisle Aas.
  
  Copyright 1995 Martijn Koster.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 AUTHORS / ACKNOWLEDGMENTS
  
  This module is based on the C<URI::URL> module, which in turn was
  (distantly) based on the C<wwwurl.pl> code in the libwww-perl for
  perl4 developed by Roy Fielding, as part of the Arcadia project at the
  University of California, Irvine, with contributions from Brooks
  Cutter.
  
  C<URI::URL> was developed by Gisle Aas, Tim Bunce, Roy Fielding and
  Martijn Koster with input from other people on the libwww-perl mailing
  list.
  
  C<URI> and related subclasses was developed by Gisle Aas.
  
  =cut
URI

$fatpacked{"URI/Escape.pm"} = <<'URI_ESCAPE';
  package URI::Escape;
  use strict;
  
  =head1 NAME
  
  URI::Escape - Escape and unescape unsafe characters
  
  =head1 SYNOPSIS
  
   use URI::Escape;
   $safe = uri_escape("10% is enough\n");
   $verysafe = uri_escape("foo", "\0-\377");
   $str  = uri_unescape($safe);
  
  =head1 DESCRIPTION
  
  This module provides functions to escape and unescape URI strings as
  defined by RFC 3986.
  
  A URI consists of a restricted set of characters.  The restricted set
  of characters consists of digits, letters, and a few graphic symbols
  chosen from those common to most of the character encodings and input
  facilities available to Internet users.  They are made up of the
  "unreserved" and "reserved" character sets as defined in RFC 3986.
  
     unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
     reserved      = ":" / "/" / "?" / "#" / "[" / "]" / "@"
                     "!" / "$" / "&" / "'" / "(" / ")"
                   / "*" / "+" / "," / ";" / "="
  
  In addition, any byte (octet) can be represented in a URI by an escape
  sequence: a triplet consisting of the character "%" followed by two
  hexadecimal digits.  A byte can also be represented directly by a
  character, using the US-ASCII character for that octet.
  
  Some of the characters are I<reserved> for use as delimiters or as
  part of certain URI components.  These must be escaped if they are to
  be treated as ordinary data.  Read RFC 3986 for further details.
  
  The functions provided (and exported by default) from this module are:
  
  =over 4
  
  =item uri_escape( $string )
  
  =item uri_escape( $string, $unsafe )
  
  Replaces each unsafe character in the $string with the corresponding
  escape sequence and returns the result.  The $string argument should
  be a string of bytes.  The uri_escape() function will croak if given a
  characters with code above 255.  Use uri_escape_utf8() if you know you
  have such chars or/and want chars in the 128 .. 255 range treated as
  UTF-8.
  
  The uri_escape() function takes an optional second argument that
  overrides the set of characters that are to be escaped.  The set is
  specified as a string that can be used in a regular expression
  character class (between [ ]).  E.g.:
  
    "\x00-\x1f\x7f-\xff"          # all control and hi-bit characters
    "a-z"                         # all lower case characters
    "^A-Za-z"                     # everything not a letter
  
  The default set of characters to be escaped is all those which are
  I<not> part of the C<unreserved> character class shown above as well
  as the reserved characters.  I.e. the default is:
  
      "^A-Za-z0-9\-\._~"
  
  =item uri_escape_utf8( $string )
  
  =item uri_escape_utf8( $string, $unsafe )
  
  Works like uri_escape(), but will encode chars as UTF-8 before
  escaping them.  This makes this function able do deal with characters
  with code above 255 in $string.  Note that chars in the 128 .. 255
  range will be escaped differently by this function compared to what
  uri_escape() would.  For chars in the 0 .. 127 range there is no
  difference.
  
  The call:
  
      $uri = uri_escape_utf8($string);
  
  will be the same as:
  
      use Encode qw(encode);
      $uri = uri_escape(encode("UTF-8", $string));
  
  but will even work for perl-5.6 for chars in the 128 .. 255 range.
  
  Note: JavaScript has a function called escape() that produces the
  sequence "%uXXXX" for chars in the 256 .. 65535 range.  This function
  has really nothing to do with URI escaping but some folks got confused
  since it "does the right thing" in the 0 .. 255 range.  Because of
  this you sometimes see "URIs" with these kind of escapes.  The
  JavaScript encodeURIComponent() function is similar to uri_escape_utf8().
  
  =item uri_unescape($string,...)
  
  Returns a string with each %XX sequence replaced with the actual byte
  (octet).
  
  This does the same as:
  
     $string =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
  
  but does not modify the string in-place as this RE would.  Using the
  uri_unescape() function instead of the RE might make the code look
  cleaner and is a few characters less to type.
  
  In a simple benchmark test I did,
  calling the function (instead of the inline RE above) if a few chars
  were unescaped was something like 40% slower, and something like 700% slower if none were.  If
  you are going to unescape a lot of times it might be a good idea to
  inline the RE.
  
  If the uri_unescape() function is passed multiple strings, then each
  one is returned unescaped.
  
  =back
  
  The module can also export the C<%escapes> hash, which contains the
  mapping from all 256 bytes to the corresponding escape codes.  Lookup
  in this hash is faster than evaluating C<sprintf("%%%02X", ord($byte))>
  each time.
  
  =head1 SEE ALSO
  
  L<URI>
  
  
  =head1 COPYRIGHT
  
  Copyright 1995-2004 Gisle Aas.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  use vars qw(@ISA @EXPORT @EXPORT_OK $VERSION);
  use vars qw(%escapes);
  
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT = qw(uri_escape uri_unescape uri_escape_utf8);
  @EXPORT_OK = qw(%escapes);
  $VERSION = "3.30";
  
  use Carp ();
  
  # Build a char->hex map
  for (0..255) {
      $escapes{chr($_)} = sprintf("%%%02X", $_);
  }
  
  my %subst;  # compiled patterns
  
  my %Unsafe = (
      RFC2732 => qr/[^A-Za-z0-9\-_.!~*'()]/,
      RFC3986 => qr/[^A-Za-z0-9\-\._~"]/,
  );
  
  sub uri_escape
  {
      my($text, $patn) = @_;
      return undef unless defined $text;
      if (defined $patn){
  	unless (exists  $subst{$patn}) {
  	    # Because we can't compile the regex we fake it with a cached sub
  	    (my $tmp = $patn) =~ s,/,\\/,g;
  	    eval "\$subst{\$patn} = sub {\$_[0] =~ s/([$tmp])/\$escapes{\$1} || _fail_hi(\$1)/ge; }";
  	    Carp::croak("uri_escape: $@") if $@;
  	}
  	&{$subst{$patn}}($text);
      } else {
  	$text =~ s/($Unsafe{RFC3986})/$escapes{$1} || _fail_hi($1)/ge;
      }
      $text;
  }
  
  sub _fail_hi {
      my $chr = shift;
      Carp::croak(sprintf "Can't escape \\x{%04X}, try uri_escape_utf8() instead", ord($chr));
  }
  
  sub uri_escape_utf8
  {
      my $text = shift;
      if ($] < 5.008) {
  	$text =~ s/([^\0-\x7F])/do {my $o = ord($1); sprintf("%c%c", 0xc0 | ($o >> 6), 0x80 | ($o & 0x3f)) }/ge;
      }
      else {
  	utf8::encode($text);
      }
  
      return uri_escape($text, @_);
  }
  
  sub uri_unescape
  {
      # Note from RFC1630:  "Sequences which start with a percent sign
      # but are not followed by two hexadecimal characters are reserved
      # for future extension"
      my $str = shift;
      if (@_ && wantarray) {
  	# not executed for the common case of a single argument
  	my @str = ($str, @_);  # need to copy
  	foreach (@str) {
  	    s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
  	}
  	return @str;
      }
      $str =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg if defined $str;
      $str;
  }
  
  sub escape_char {
      return join '', @URI::Escape::escapes{$_[0] =~ /(\C)/g};
  }
  
  1;
URI_ESCAPE

$fatpacked{"URI/Heuristic.pm"} = <<'URI_HEURISTIC';
  package URI::Heuristic;
  
  =head1 NAME
  
  URI::Heuristic - Expand URI using heuristics
  
  =head1 SYNOPSIS
  
   use URI::Heuristic qw(uf_uristr);
   $u = uf_uristr("perl");             # http://www.perl.com
   $u = uf_uristr("www.sol.no/sol");   # http://www.sol.no/sol
   $u = uf_uristr("aas");              # http://www.aas.no
   $u = uf_uristr("ftp.funet.fi");     # ftp://ftp.funet.fi
   $u = uf_uristr("/etc/passwd");      # file:/etc/passwd
  
  =head1 DESCRIPTION
  
  This module provides functions that expand strings into real absolute
  URIs using some built-in heuristics.  Strings that already represent
  absolute URIs (i.e. that start with a C<scheme:> part) are never modified
  and are returned unchanged.  The main use of these functions is to
  allow abbreviated URIs similar to what many web browsers allow for URIs
  typed in by the user.
  
  The following functions are provided:
  
  =over 4
  
  =item uf_uristr($str)
  
  Tries to make the argument string
  into a proper absolute URI string.  The "uf_" prefix stands for "User 
  Friendly".  Under MacOS, it assumes that any string with a common URL 
  scheme (http, ftp, etc.) is a URL rather than a local path.  So don't name 
  your volumes after common URL schemes and expect uf_uristr() to construct 
  valid file: URL's on those volumes for you, because it won't.
  
  =item uf_uri($str)
  
  Works the same way as uf_uristr() but
  returns a C<URI> object.
  
  =back
  
  =head1 ENVIRONMENT
  
  If the hostname portion of a URI does not contain any dots, then
  certain qualified guesses are made.  These guesses are governed by
  the following environment variables:
  
  =over 10
  
  =item COUNTRY
  
  The two-letter country code (ISO 3166) for your location.  If
  the domain name of your host ends with two letters, then it is taken
  to be the default country. See also L<Locale::Country>.
  
  =item HTTP_ACCEPT_LANGUAGE, LC_ALL, LANG
  
  If COUNTRY is not set, these standard environment variables are
  examined and country (not language) information possibly found in them
  is used as the default country.
  
  =item URL_GUESS_PATTERN
  
  Contains a space-separated list of URL patterns to try.  The string
  "ACME" is for some reason used as a placeholder for the host name in
  the URL provided.  Example:
  
   URL_GUESS_PATTERN="www.ACME.no www.ACME.se www.ACME.com"
   export URL_GUESS_PATTERN
  
  Specifying URL_GUESS_PATTERN disables any guessing rules based on
  country.  An empty URL_GUESS_PATTERN disables any guessing that
  involves host name lookups.
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 1997-1998, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
  use strict;
  
  use vars qw(@EXPORT_OK $VERSION $MY_COUNTRY %LOCAL_GUESSING $DEBUG);
  
  require Exporter;
  *import = \&Exporter::import;
  @EXPORT_OK = qw(uf_uri uf_uristr uf_url uf_urlstr);
  $VERSION = "4.19";
  
  sub MY_COUNTRY() {
      for ($MY_COUNTRY) {
  	return $_ if defined;
  
  	# First try the environment.
  	$_ = $ENV{COUNTRY};
  	return $_ if defined;
  
  	# Try the country part of LC_ALL and LANG from environment
  	my @srcs = ($ENV{LC_ALL}, $ENV{LANG});
  	# ...and HTTP_ACCEPT_LANGUAGE before those if present
  	if (my $httplang = $ENV{HTTP_ACCEPT_LANGUAGE}) {
  	    # TODO: q-value processing/ordering
  	    for $httplang (split(/\s*,\s*/, $httplang)) {
  		if ($httplang =~ /^\s*([a-zA-Z]+)[_-]([a-zA-Z]{2})\s*$/) {
  		    unshift(@srcs, "${1}_${2}");
  		    last;
  		}
  	    }
  	}
  	for (@srcs) {
  	    next unless defined;
  	    return lc($1) if /^[a-zA-Z]+_([a-zA-Z]{2})(?:[.@]|$)/;
  	}
  
  	# Last bit of domain name.  This may access the network.
  	require Net::Domain;
  	my $fqdn = Net::Domain::hostfqdn();
  	$_ = lc($1) if $fqdn =~ /\.([a-zA-Z]{2})$/;
  	return $_ if defined;
  
  	# Give up.  Defined but false.
  	return ($_ = 0);
      }
  }
  
  %LOCAL_GUESSING =
  (
   'us' => [qw(www.ACME.gov www.ACME.mil)],
   'gb' => [qw(www.ACME.co.uk www.ACME.org.uk www.ACME.ac.uk)],
   'au' => [qw(www.ACME.com.au www.ACME.org.au www.ACME.edu.au)],
   'il' => [qw(www.ACME.co.il www.ACME.org.il www.ACME.net.il)],
   # send corrections and new entries to <gisle@aas.no>
  );
  # Backwards compatibility; uk != United Kingdom in ISO 3166
  $LOCAL_GUESSING{uk} = $LOCAL_GUESSING{gb};
  
  
  sub uf_uristr ($)
  {
      local($_) = @_;
      print STDERR "uf_uristr: resolving $_\n" if $DEBUG;
      return unless defined;
  
      s/^\s+//;
      s/\s+$//;
  
      if (/^(www|web|home)\./) {
  	$_ = "http://$_";
  
      } elsif (/^(ftp|gopher|news|wais|http|https)\./) {
  	$_ = "$1://$_";
  
      } elsif ($^O ne "MacOS" && 
  	    (m,^/,      ||          # absolute file name
  	     m,^\.\.?/, ||          # relative file name
  	     m,^[a-zA-Z]:[/\\],)    # dosish file name
  	    )
      {
  	$_ = "file:$_";
  
      } elsif ($^O eq "MacOS" && m/:/) {
          # potential MacOS file name
  	unless (m/^(ftp|gopher|news|wais|http|https|mailto):/) {
  	    require URI::file;
  	    my $a = URI::file->new($_)->as_string;
  	    $_ = ($a =~ m/^file:/) ? $a : "file:$a";
  	}
      } elsif (/^\w+([\.\-]\w+)*\@(\w+\.)+\w{2,3}$/) {
  	$_ = "mailto:$_";
  
      } elsif (!/^[a-zA-Z][a-zA-Z0-9.+\-]*:/) {      # no scheme specified
  	if (s/^([-\w]+(?:\.[-\w]+)*)([\/:\?\#]|$)/$2/) {
  	    my $host = $1;
  
  	    if ($host !~ /\./ && $host ne "localhost") {
  		my @guess;
  		if (exists $ENV{URL_GUESS_PATTERN}) {
  		    @guess = map { s/\bACME\b/$host/; $_ }
  		             split(' ', $ENV{URL_GUESS_PATTERN});
  		} else {
  		    if (MY_COUNTRY()) {
  			my $special = $LOCAL_GUESSING{MY_COUNTRY()};
  			if ($special) {
  			    my @special = @$special;
  			    push(@guess, map { s/\bACME\b/$host/; $_ }
                                                 @special);
  			} else {
  			    push(@guess, "www.$host." . MY_COUNTRY());
  			}
  		    }
  		    push(@guess, map "www.$host.$_",
  			             "com", "org", "net", "edu", "int");
  		}
  
  
  		my $guess;
  		for $guess (@guess) {
  		    print STDERR "uf_uristr: gethostbyname('$guess.')..."
  		      if $DEBUG;
  		    if (gethostbyname("$guess.")) {
  			print STDERR "yes\n" if $DEBUG;
  			$host = $guess;
  			last;
  		    }
  		    print STDERR "no\n" if $DEBUG;
  		}
  	    }
  	    $_ = "http://$host$_";
  
  	} else {
  	    # pure junk, just return it unchanged...
  
  	}
      }
      print STDERR "uf_uristr: ==> $_\n" if $DEBUG;
  
      $_;
  }
  
  sub uf_uri ($)
  {
      require URI;
      URI->new(uf_uristr($_[0]));
  }
  
  # legacy
  *uf_urlstr = \*uf_uristr;
  
  sub uf_url ($)
  {
      require URI::URL;
      URI::URL->new(uf_uristr($_[0]));
  }
  
  1;
URI_HEURISTIC

$fatpacked{"URI/IRI.pm"} = <<'URI_IRI';
  package URI::IRI;
  
  # Experimental
  
  use strict;
  use URI ();
  
  use overload '""' => sub { shift->as_string };
  
  sub new {
      my($class, $uri, $scheme) = @_;
      utf8::upgrade($uri);
      return bless {
  	uri => URI->new($uri, $scheme),
      }, $class;
  }
  
  sub clone {
      my $self = shift;
      return bless {
  	uri => $self->{uri}->clone,
      }, ref($self);
  }
  
  sub as_string {
      my $self = shift;
      return $self->{uri}->as_iri;
  }
  
  sub AUTOLOAD
  {
      use vars qw($AUTOLOAD);
      my $method = substr($AUTOLOAD, rindex($AUTOLOAD, '::')+2);
  
      # We create the function here so that it will not need to be
      # autoloaded the next time.
      no strict 'refs';
      *$method = sub { shift->{uri}->$method(@_) };
      goto &$method;
  }
  
  sub DESTROY {}   # avoid AUTOLOADing it
  
  1;
URI_IRI

$fatpacked{"URI/QueryParam.pm"} = <<'URI_QUERYPARAM';
  package URI::QueryParam;
  
  use strict;
  
  sub URI::_query::query_param {
      my $self = shift;
      my @old = $self->query_form;
  
      if (@_ == 0) {
  	# get keys
  	my %seen;
  	my @keys;
  	for (my $i = 0; $i < @old; $i += 2) {
  	    push(@keys, $old[$i]) unless $seen{$old[$i]}++;
  	}
  	return @keys;
      }
  
      my $key = shift;
      my @i;
  
      for (my $i = 0; $i < @old; $i += 2) {
  	push(@i, $i) if $old[$i] eq $key;
      }
  
      if (@_) {
  	my @new = @old;
  	my @new_i = @i;
  	my @vals = map { ref($_) eq 'ARRAY' ? @$_ : $_ } @_;
  	#print "VALS:@vals [@i]\n";
  	while (@new_i > @vals) {
  	    #print "REMOVE $new_i[-1]\n";
  	    splice(@new, pop(@new_i), 2);
  	}
  	while (@vals > @new_i) {
  	    my $i = @new_i ? $new_i[-1] + 2 : @new;
  	    #print "SPLICE $i\n";
  	    splice(@new, $i, 0, $key => pop(@vals));
  	}
  	for (@vals) {
  	    #print "SET $new_i[0]\n";
  	    $new[shift(@new_i)+1] = $_;
  	}
  
  	$self->query_form(\@new);
      }
  
      return wantarray ? @old[map $_+1, @i] : @i ? $old[$i[0]+1] : undef;
  }
  
  sub URI::_query::query_param_append {
      my $self = shift;
      my $key = shift;
      $self->query_form($self->query_form, $key => \@_);  # XXX
      return;
  }
  
  sub URI::_query::query_param_delete {
      my $self = shift;
      my $key = shift;
      my @old = $self->query_form;
      my @vals;
  
      for (my $i = @old - 2; $i >= 0; $i -= 2) {
  	next if $old[$i] ne $key;
  	push(@vals, (splice(@old, $i, 2))[1]);
      }
      $self->query_form(\@old) if @vals;
      return wantarray ? reverse @vals : $vals[-1];
  }
  
  sub URI::_query::query_form_hash {
      my $self = shift;
      my @old = $self->query_form;
      if (@_) {
  	$self->query_form(@_ == 1 ? %{shift(@_)} : @_);
      }
      my %hash;
      while (my($k, $v) = splice(@old, 0, 2)) {
  	if (exists $hash{$k}) {
  	    for ($hash{$k}) {
  		$_ = [$_] unless ref($_) eq "ARRAY";
  		push(@$_, $v);
  	    }
  	}
  	else {
  	    $hash{$k} = $v;
  	}
      }
      return \%hash;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::QueryParam - Additional query methods for URIs
  
  =head1 SYNOPSIS
  
    use URI;
    use URI::QueryParam;
  
    $u = URI->new("", "http");
    $u->query_param(foo => 1, 2, 3);
    print $u->query;    # prints foo=1&foo=2&foo=3
  
    for my $key ($u->query_param) {
        print "$key: ", join(", ", $u->query_param($key)), "\n";
    }
  
  =head1 DESCRIPTION
  
  Loading the C<URI::QueryParam> module adds some extra methods to
  URIs that support query methods.  These methods provide an alternative
  interface to the $u->query_form data.
  
  The query_param_* methods have deliberately been made identical to the
  interface of the corresponding C<CGI.pm> methods.
  
  The following additional methods are made available:
  
  =over
  
  =item @keys = $u->query_param
  
  =item @values = $u->query_param( $key )
  
  =item $first_value = $u->query_param( $key )
  
  =item $u->query_param( $key, $value,... )
  
  If $u->query_param is called with no arguments, it returns all the
  distinct parameter keys of the URI.  In a scalar context it returns the
  number of distinct keys.
  
  When a $key argument is given, the method returns the parameter values with the
  given key.  In a scalar context, only the first parameter value is
  returned.
  
  If additional arguments are given, they are used to update successive
  parameters with the given key.  If any of the values provided are
  array references, then the array is dereferenced to get the actual
  values.
  
  =item $u->query_param_append($key, $value,...)
  
  Adds new parameters with the given
  key without touching any old parameters with the same key.  It
  can be explained as a more efficient version of:
  
     $u->query_param($key,
                     $u->query_param($key),
                     $value,...);
  
  One difference is that this expression would return the old values
  of $key, whereas the query_param_append() method does not.
  
  =item @values = $u->query_param_delete($key)
  
  =item $first_value = $u->query_param_delete($key)
  
  Deletes all key/value pairs with the given key.
  The old values are returned.  In a scalar context, only the first value
  is returned.
  
  Using the query_param_delete() method is slightly more efficient than
  the equivalent:
  
     $u->query_param($key, []);
  
  =item $hashref = $u->query_form_hash
  
  =item $u->query_form_hash( \%new_form )
  
  Returns a reference to a hash that represents the
  query form's key/value pairs.  If a key occurs multiple times, then the hash
  value becomes an array reference.
  
  Note that sequence information is lost.  This means that:
  
     $u->query_form_hash($u->query_form_hash);
  
  is not necessarily a no-op, as it may reorder the key/value pairs.
  The values returned by the query_param() method should stay the same
  though.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>, L<CGI>
  
  =head1 COPYRIGHT
  
  Copyright 2002 Gisle Aas.
  
  =cut
URI_QUERYPARAM

$fatpacked{"URI/Split.pm"} = <<'URI_SPLIT';
  package URI::Split;
  
  use strict;
  
  use vars qw(@ISA @EXPORT_OK);
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT_OK = qw(uri_split uri_join);
  
  use URI::Escape ();
  
  sub uri_split {
       return $_[0] =~ m,(?:([^:/?#]+):)?(?://([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?,;
  }
  
  sub uri_join {
      my($scheme, $auth, $path, $query, $frag) = @_;
      my $uri = defined($scheme) ? "$scheme:" : "";
      $path = "" unless defined $path;
      if (defined $auth) {
  	$auth =~ s,([/?\#]), URI::Escape::escape_char($1),eg;
  	$uri .= "//$auth";
  	$path = "/$path" if length($path) && $path !~ m,^/,;
      }
      elsif ($path =~ m,^//,) {
  	$uri .= "//";  # XXX force empty auth
      }
      unless (length $uri) {
  	$path =~ s,(:), URI::Escape::escape_char($1),e while $path =~ m,^[^:/?\#]+:,;
      }
      $path =~ s,([?\#]), URI::Escape::escape_char($1),eg;
      $uri .= $path;
      if (defined $query) {
  	$query =~ s,(\#), URI::Escape::escape_char($1),eg;
  	$uri .= "?$query";
      }
      $uri .= "#$frag" if defined $frag;
      $uri;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::Split - Parse and compose URI strings
  
  =head1 SYNOPSIS
  
   use URI::Split qw(uri_split uri_join);
   ($scheme, $auth, $path, $query, $frag) = uri_split($uri);
   $uri = uri_join($scheme, $auth, $path, $query, $frag);
  
  =head1 DESCRIPTION
  
  Provides functions to parse and compose URI
  strings.  The following functions are provided:
  
  =over
  
  =item ($scheme, $auth, $path, $query, $frag) = uri_split($uri)
  
  Breaks up a URI string into its component
  parts.  An C<undef> value is returned for those parts that are not
  present.  The $path part is always present (but can be the empty
  string) and is thus never returned as C<undef>.
  
  No sensible value is returned if this function is called in a scalar
  context.
  
  =item $uri = uri_join($scheme, $auth, $path, $query, $frag)
  
  Puts together a URI string from its parts.
  Missing parts are signaled by passing C<undef> for the corresponding
  argument.
  
  Minimal escaping is applied to parts that contain reserved chars
  that would confuse a parser.  For instance, any occurrence of '?' or '#'
  in $path is always escaped, as it would otherwise be parsed back
  as a query or fragment.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>, L<URI::Escape>
  
  =head1 COPYRIGHT
  
  Copyright 2003, Gisle Aas
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
URI_SPLIT

$fatpacked{"URI/URL.pm"} = <<'URI_URL';
  package URI::URL;
  
  require URI::WithBase;
  @ISA=qw(URI::WithBase);
  
  use strict;
  use vars qw(@EXPORT $VERSION);
  
  $VERSION = "5.03";
  
  # Provide as much as possible of the old URI::URL interface for backwards
  # compatibility...
  
  require Exporter;
  *import = \&Exporter::import;
  @EXPORT = qw(url);
  
  # Easy to use constructor
  sub url ($;$) { URI::URL->new(@_); }
  
  use URI::Escape qw(uri_unescape);
  
  sub new
  {
      my $class = shift;
      my $self = $class->SUPER::new(@_);
      $self->[0] = $self->[0]->canonical;
      $self;
  }
  
  sub newlocal
  {
      my $class = shift;
      require URI::file;
      bless [URI::file->new_abs(shift)], $class;
  }
  
  {package URI::_foreign;
      sub _init  # hope it is not defined
      {
  	my $class = shift;
  	die "Unknown URI::URL scheme $_[1]:" if $URI::URL::STRICT;
  	$class->SUPER::_init(@_);
      }
  }
  
  sub strict
  {
      my $old = $URI::URL::STRICT;
      $URI::URL::STRICT = shift if @_;
      $old;
  }
  
  sub print_on
  {
      my $self = shift;
      require Data::Dumper;
      print STDERR Data::Dumper::Dumper($self);
  }
  
  sub _try
  {
      my $self = shift;
      my $method = shift;
      scalar(eval { $self->$method(@_) });
  }
  
  sub crack
  {
      # should be overridden by subclasses
      my $self = shift;
      (scalar($self->scheme),
       $self->_try("user"),
       $self->_try("password"),
       $self->_try("host"),
       $self->_try("port"),
       $self->_try("path"),
       $self->_try("params"),
       $self->_try("query"),
       scalar($self->fragment),
      )
  }
  
  sub full_path
  {
      my $self = shift;
      my $path = $self->path_query;
      $path = "/" unless length $path;
      $path;
  }
  
  sub netloc
  {
      shift->authority(@_);
  }
  
  sub epath
  {
      my $path = shift->SUPER::path(@_);
      $path =~ s/;.*//;
      $path;
  }
  
  sub eparams
  {
      my $self = shift;
      my @p = $self->path_segments;
      return unless ref($p[-1]);
      @p = @{$p[-1]};
      shift @p;
      join(";", @p);
  }
  
  sub params { shift->eparams(@_); }
  
  sub path {
      my $self = shift;
      my $old = $self->epath(@_);
      return unless defined wantarray;
      return '/' if !defined($old) || !length($old);
      Carp::croak("Path components contain '/' (you must call epath)")
  	if $old =~ /%2[fF]/ and !@_;
      $old = "/$old" if $old !~ m|^/| && defined $self->netloc;
      return uri_unescape($old);
  }
  
  sub path_components {
      shift->path_segments(@_);
  }
  
  sub query {
      my $self = shift;
      my $old = $self->equery(@_);
      if (defined(wantarray) && defined($old)) {
  	if ($old =~ /%(?:26|2[bB]|3[dD])/) {  # contains escaped '=' '&' or '+'
  	    my $mess;
  	    for ($old) {
  		$mess = "Query contains both '+' and '%2B'"
  		  if /\+/ && /%2[bB]/;
  		$mess = "Form query contains escaped '=' or '&'"
  		  if /=/  && /%(?:3[dD]|26)/;
  	    }
  	    if ($mess) {
  		Carp::croak("$mess (you must call equery)");
  	    }
  	}
  	# Now it should be safe to unescape the string without loosing
  	# information
  	return uri_unescape($old);
      }
      undef;
  
  }
  
  sub abs
  {
      my $self = shift;
      my $base = shift;
      my $allow_scheme = shift;
      $allow_scheme = $URI::URL::ABS_ALLOW_RELATIVE_SCHEME
  	unless defined $allow_scheme;
      local $URI::ABS_ALLOW_RELATIVE_SCHEME = $allow_scheme;
      local $URI::ABS_REMOTE_LEADING_DOTS = $URI::URL::ABS_REMOTE_LEADING_DOTS;
      $self->SUPER::abs($base);
  }
  
  sub frag { shift->fragment(@_); }
  sub keywords { shift->query_keywords(@_); }
  
  # file:
  sub local_path { shift->file; }
  sub unix_path  { shift->file("unix"); }
  sub dos_path   { shift->file("dos");  }
  sub mac_path   { shift->file("mac");  }
  sub vms_path   { shift->file("vms");  }
  
  # mailto:
  sub address { shift->to(@_); }
  sub encoded822addr { shift->to(@_); }
  sub URI::mailto::authority { shift->to(@_); }  # make 'netloc' method work
  
  # news:
  sub groupart { shift->_group(@_); }
  sub article  { shift->message(@_); }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::URL - Uniform Resource Locators
  
  =head1 SYNOPSIS
  
   $u1 = URI::URL->new($str, $base);
   $u2 = $u1->abs;
  
  =head1 DESCRIPTION
  
  This module is provided for backwards compatibility with modules that
  depend on the interface provided by the C<URI::URL> class that used to
  be distributed with the libwww-perl library.
  
  The following differences exist compared to the C<URI> class interface:
  
  =over 3
  
  =item *
  
  The URI::URL module exports the url() function as an alternate
  constructor interface.
  
  =item *
  
  The constructor takes an optional $base argument.  The C<URI::URL>
  class is a subclass of C<URI::WithBase>.
  
  =item *
  
  The URI::URL->newlocal class method is the same as URI::file->new_abs.
  
  =item *
  
  URI::URL::strict(1)
  
  =item *
  
  $url->print_on method
  
  =item *
  
  $url->crack method
  
  =item *
  
  $url->full_path: same as ($uri->abs_path || "/")
  
  =item *
  
  $url->netloc: same as $uri->authority
  
  =item *
  
  $url->epath, $url->equery: same as $uri->path, $uri->query
  
  =item *
  
  $url->path and $url->query pass unescaped strings.
  
  =item *
  
  $url->path_components: same as $uri->path_segments (if you don't
  consider path segment parameters)
  
  =item *
  
  $url->params and $url->eparams methods
  
  =item *
  
  $url->base method.  See L<URI::WithBase>.
  
  =item *
  
  $url->abs and $url->rel have an optional $base argument.  See
  L<URI::WithBase>.
  
  =item *
  
  $url->frag: same as $uri->fragment
  
  =item *
  
  $url->keywords: same as $uri->query_keywords
  
  =item *
  
  $url->localpath and friends map to $uri->file.
  
  =item *
  
  $url->address and $url->encoded822addr: same as $uri->to for mailto URI
  
  =item *
  
  $url->groupart method for news URI
  
  =item *
  
  $url->article: same as $uri->message
  
  =back
  
  
  
  =head1 SEE ALSO
  
  L<URI>, L<URI::WithBase>
  
  =head1 COPYRIGHT
  
  Copyright 1998-2000 Gisle Aas.
  
  =cut
URI_URL

$fatpacked{"URI/WithBase.pm"} = <<'URI_WITHBASE';
  package URI::WithBase;
  
  use strict;
  use vars qw($AUTOLOAD $VERSION);
  use URI;
  
  $VERSION = "2.19";
  
  use overload '""' => "as_string", fallback => 1;
  
  sub as_string;  # help overload find it
  
  sub new
  {
      my($class, $uri, $base) = @_;
      my $ibase = $base;
      if ($base && ref($base) && UNIVERSAL::isa($base, __PACKAGE__)) {
  	$base = $base->abs;
  	$ibase = $base->[0];
      }
      bless [URI->new($uri, $ibase), $base], $class;
  }
  
  sub new_abs
  {
      my $class = shift;
      my $self = $class->new(@_);
      $self->abs;
  }
  
  sub _init
  {
      my $class = shift;
      my($str, $scheme) = @_;
      bless [URI->new($str, $scheme), undef], $class;
  }
  
  sub eq
  {
      my($self, $other) = @_;
      $other = $other->[0] if UNIVERSAL::isa($other, __PACKAGE__);
      $self->[0]->eq($other);
  }
  
  sub AUTOLOAD
  {
      my $self = shift;
      my $method = substr($AUTOLOAD, rindex($AUTOLOAD, '::')+2);
      return if $method eq "DESTROY";
      $self->[0]->$method(@_);
  }
  
  sub can {                                  # override UNIVERSAL::can
      my $self = shift;
      $self->SUPER::can(@_) || (
        ref($self)
        ? $self->[0]->can(@_)
        : undef
      )
  }
  
  sub base {
      my $self = shift;
      my $base  = $self->[1];
  
      if (@_) { # set
  	my $new_base = shift;
  	# ensure absoluteness
  	$new_base = $new_base->abs if ref($new_base) && $new_base->isa(__PACKAGE__);
  	$self->[1] = $new_base;
      }
      return unless defined wantarray;
  
      # The base attribute supports 'lazy' conversion from URL strings
      # to URL objects. Strings may be stored but when a string is
      # fetched it will automatically be converted to a URL object.
      # The main benefit is to make it much cheaper to say:
      #   URI::WithBase->new($random_url_string, 'http:')
      if (defined($base) && !ref($base)) {
  	$base = ref($self)->new($base);
  	$self->[1] = $base unless @_;
      }
      $base;
  }
  
  sub clone
  {
      my $self = shift;
      my $base = $self->[1];
      $base = $base->clone if ref($base);
      bless [$self->[0]->clone, $base], ref($self);
  }
  
  sub abs
  {
      my $self = shift;
      my $base = shift || $self->base || return $self->clone;
      $base = $base->as_string if ref($base);
      bless [$self->[0]->abs($base, @_), $base], ref($self);
  }
  
  sub rel
  {
      my $self = shift;
      my $base = shift || $self->base || return $self->clone;
      $base = $base->as_string if ref($base);
      bless [$self->[0]->rel($base, @_), $base], ref($self);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::WithBase - URIs which remember their base
  
  =head1 SYNOPSIS
  
   $u1 = URI::WithBase->new($str, $base);
   $u2 = $u1->abs;
  
   $base = $u1->base;
   $u1->base( $new_base )
  
  =head1 DESCRIPTION
  
  This module provides the C<URI::WithBase> class.  Objects of this class
  are like C<URI> objects, but can keep their base too.  The base
  represents the context where this URI was found and can be used to
  absolutize or relativize the URI.  All the methods described in L<URI>
  are supported for C<URI::WithBase> objects.
  
  The methods provided in addition to or modified from those of C<URI> are:
  
  =over 4
  
  =item $uri = URI::WithBase->new($str, [$base])
  
  The constructor takes an optional base URI as the second argument.
  If provided, this argument initializes the base attribute.
  
  =item $uri->base( [$new_base] )
  
  Can be used to get or set the value of the base attribute.
  The return value, which is the old value, is a URI object or C<undef>.
  
  =item $uri->abs( [$base_uri] )
  
  The $base_uri argument is now made optional as the object carries its
  base with it.  A new object is returned even if $uri is already
  absolute (while plain URI objects simply return themselves in
  that case).
  
  =item $uri->rel( [$base_uri] )
  
  The $base_uri argument is now made optional as the object carries its
  base with it.  A new object is always returned.
  
  =back
  
  
  =head1 SEE ALSO
  
  L<URI>
  
  =head1 COPYRIGHT
  
  Copyright 1998-2002 Gisle Aas.
  
  =cut
URI_WITHBASE

$fatpacked{"URI/_foreign.pm"} = <<'URI__FOREIGN';
  package URI::_foreign;
  
  require URI::_generic;
  @ISA=qw(URI::_generic);
  
  1;
URI__FOREIGN

$fatpacked{"URI/_generic.pm"} = <<'URI__GENERIC';
  package URI::_generic;
  require URI;
  require URI::_query;
  @ISA=qw(URI URI::_query);
  
  use strict;
  use URI::Escape qw(uri_unescape);
  use Carp ();
  
  my $ACHAR = $URI::uric;  $ACHAR =~ s,\\[/?],,g;
  my $PCHAR = $URI::uric;  $PCHAR =~ s,\\[?],,g;
  
  sub _no_scheme_ok { 1 }
  
  sub authority
  {
      my $self = shift;
      $$self =~ m,^((?:$URI::scheme_re:)?)(?://([^/?\#]*))?(.*)$,os or die;
  
      if (@_) {
  	my $auth = shift;
  	$$self = $1;
  	my $rest = $3;
  	if (defined $auth) {
  	    $auth =~ s/([^$ACHAR])/ URI::Escape::escape_char($1)/ego;
  	    $$self .= "//$auth";
  	}
  	_check_path($rest, $$self);
  	$$self .= $rest;
      }
      $2;
  }
  
  sub path
  {
      my $self = shift;
      $$self =~ m,^((?:[^:/?\#]+:)?(?://[^/?\#]*)?)([^?\#]*)(.*)$,s or die;
  
      if (@_) {
  	$$self = $1;
  	my $rest = $3;
  	my $new_path = shift;
  	$new_path = "" unless defined $new_path;
  	$new_path =~ s/([^$PCHAR])/ URI::Escape::escape_char($1)/ego;
  	_check_path($new_path, $$self);
  	$$self .= $new_path . $rest;
      }
      $2;
  }
  
  sub path_query
  {
      my $self = shift;
      $$self =~ m,^((?:[^:/?\#]+:)?(?://[^/?\#]*)?)([^\#]*)(.*)$,s or die;
  
      if (@_) {
  	$$self = $1;
  	my $rest = $3;
  	my $new_path = shift;
  	$new_path = "" unless defined $new_path;
  	$new_path =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;
  	_check_path($new_path, $$self);
  	$$self .= $new_path . $rest;
      }
      $2;
  }
  
  sub _check_path
  {
      my($path, $pre) = @_;
      my $prefix;
      if ($pre =~ m,/,) {  # authority present
  	$prefix = "/" if length($path) && $path !~ m,^[/?\#],;
      }
      else {
  	if ($path =~ m,^//,) {
  	    Carp::carp("Path starting with double slash is confusing")
  		if $^W;
  	}
  	elsif (!length($pre) && $path =~ m,^[^:/?\#]+:,) {
  	    Carp::carp("Path might look like scheme, './' prepended")
  		if $^W;
  	    $prefix = "./";
  	}
      }
      substr($_[0], 0, 0) = $prefix if defined $prefix;
  }
  
  sub path_segments
  {
      my $self = shift;
      my $path = $self->path;
      if (@_) {
  	my @arg = @_;  # make a copy
  	for (@arg) {
  	    if (ref($_)) {
  		my @seg = @$_;
  		$seg[0] =~ s/%/%25/g;
  		for (@seg) { s/;/%3B/g; }
  		$_ = join(";", @seg);
  	    }
  	    else {
  		 s/%/%25/g; s/;/%3B/g;
  	    }
  	    s,/,%2F,g;
  	}
  	$self->path(join("/", @arg));
      }
      return $path unless wantarray;
      map {/;/ ? $self->_split_segment($_)
               : uri_unescape($_) }
          split('/', $path, -1);
  }
  
  
  sub _split_segment
  {
      my $self = shift;
      require URI::_segment;
      URI::_segment->new(@_);
  }
  
  
  sub abs
  {
      my $self = shift;
      my $base = shift || Carp::croak("Missing base argument");
  
      if (my $scheme = $self->scheme) {
  	return $self unless $URI::ABS_ALLOW_RELATIVE_SCHEME;
  	$base = URI->new($base) unless ref $base;
  	return $self unless $scheme eq $base->scheme;
      }
  
      $base = URI->new($base) unless ref $base;
      my $abs = $self->clone;
      $abs->scheme($base->scheme);
      return $abs if $$self =~ m,^(?:$URI::scheme_re:)?//,o;
      $abs->authority($base->authority);
  
      my $path = $self->path;
      return $abs if $path =~ m,^/,;
  
      if (!length($path)) {
  	my $abs = $base->clone;
  	my $query = $self->query;
  	$abs->query($query) if defined $query;
  	$abs->fragment($self->fragment);
  	return $abs;
      }
  
      my $p = $base->path;
      $p =~ s,[^/]+$,,;
      $p .= $path;
      my @p = split('/', $p, -1);
      shift(@p) if @p && !length($p[0]);
      my $i = 1;
      while ($i < @p) {
  	#print "$i ", join("/", @p), " ($p[$i])\n";
  	if ($p[$i-1] eq ".") {
  	    splice(@p, $i-1, 1);
  	    $i-- if $i > 1;
  	}
  	elsif ($p[$i] eq ".." && $p[$i-1] ne "..") {
  	    splice(@p, $i-1, 2);
  	    if ($i > 1) {
  		$i--;
  		push(@p, "") if $i == @p;
  	    }
  	}
  	else {
  	    $i++;
  	}
      }
      $p[-1] = "" if @p && $p[-1] eq ".";  # trailing "/."
      if ($URI::ABS_REMOTE_LEADING_DOTS) {
          shift @p while @p && $p[0] =~ /^\.\.?$/;
      }
      $abs->path("/" . join("/", @p));
      $abs;
  }
  
  # The opposite of $url->abs.  Return a URI which is as relative as possible
  sub rel {
      my $self = shift;
      my $base = shift || Carp::croak("Missing base argument");
      my $rel = $self->clone;
      $base = URI->new($base) unless ref $base;
  
      #my($scheme, $auth, $path) = @{$rel}{qw(scheme authority path)};
      my $scheme = $rel->scheme;
      my $auth   = $rel->canonical->authority;
      my $path   = $rel->path;
  
      if (!defined($scheme) && !defined($auth)) {
  	# it is already relative
  	return $rel;
      }
  
      #my($bscheme, $bauth, $bpath) = @{$base}{qw(scheme authority path)};
      my $bscheme = $base->scheme;
      my $bauth   = $base->canonical->authority;
      my $bpath   = $base->path;
  
      for ($bscheme, $bauth, $auth) {
  	$_ = '' unless defined
      }
  
      unless ($scheme eq $bscheme && $auth eq $bauth) {
  	# different location, can't make it relative
  	return $rel;
      }
  
      for ($path, $bpath) {  $_ = "/$_" unless m,^/,; }
  
      # Make it relative by eliminating scheme and authority
      $rel->scheme(undef);
      $rel->authority(undef);
  
      # This loop is based on code from Nicolai Langfeldt <janl@ifi.uio.no>.
      # First we calculate common initial path components length ($li).
      my $li = 1;
      while (1) {
  	my $i = index($path, '/', $li);
  	last if $i < 0 ||
                  $i != index($bpath, '/', $li) ||
  	        substr($path,$li,$i-$li) ne substr($bpath,$li,$i-$li);
  	$li=$i+1;
      }
      # then we nuke it from both paths
      substr($path, 0,$li) = '';
      substr($bpath,0,$li) = '';
  
      if ($path eq $bpath &&
          defined($rel->fragment) &&
          !defined($rel->query)) {
          $rel->path("");
      }
      else {
          # Add one "../" for each path component left in the base path
          $path = ('../' x $bpath =~ tr|/|/|) . $path;
  	$path = "./" if $path eq "";
          $rel->path($path);
      }
  
      $rel;
  }
  
  1;
URI__GENERIC

$fatpacked{"URI/_idna.pm"} = <<'URI__IDNA';
  package URI::_idna;
  
  # This module implements the RFCs 3490 (IDNA) and 3491 (Nameprep)
  # based on Python-2.6.4/Lib/encodings/idna.py
  
  use strict;
  use URI::_punycode qw(encode_punycode decode_punycode);
  use Carp qw(croak);
  
  my $ASCII = qr/^[\x00-\x7F]*\z/;
  
  sub encode {
      my $idomain = shift;
      my @labels = split(/\./, $idomain, -1);
      my @last_empty;
      push(@last_empty, pop @labels) if @labels > 1 && $labels[-1] eq "";
      for (@labels) {
  	$_ = ToASCII($_);
      }
      return join(".", @labels, @last_empty);
  }
  
  sub decode {
      my $domain = shift;
      return join(".", map ToUnicode($_), split(/\./, $domain, -1))
  }
  
  sub nameprep { # XXX real implementation missing
      my $label = shift;
      $label = lc($label);
      return $label;
  }
  
  sub check_size {
      my $label = shift;
      croak "Label empty" if $label eq "";
      croak "Label too long" if length($label) > 63;
      return $label;
  }
  
  sub ToASCII {
      my $label = shift;
      return check_size($label) if $label =~ $ASCII;
  
      # Step 2: nameprep
      $label = nameprep($label);
      # Step 3: UseSTD3ASCIIRules is false
      # Step 4: try ASCII again
      return check_size($label) if $label =~ $ASCII;
  
      # Step 5: Check ACE prefix
      if ($label =~ /^xn--/) {
          croak "Label starts with ACE prefix";
      }
  
      # Step 6: Encode with PUNYCODE
      $label = encode_punycode($label);
  
      # Step 7: Prepend ACE prefix
      $label = "xn--$label";
  
      # Step 8: Check size
      return check_size($label);
  }
  
  sub ToUnicode {
      my $label = shift;
      $label = nameprep($label) unless $label =~ $ASCII;
      return $label unless $label =~ /^xn--/;
      my $result = decode_punycode(substr($label, 4));
      my $label2 = ToASCII($result);
      if (lc($label) ne $label2) {
  	croak "IDNA does not round-trip: '\L$label\E' vs '$label2'";
      }
      return $result;
  }
  
  1;
URI__IDNA

$fatpacked{"URI/_ldap.pm"} = <<'URI__LDAP';
  # Copyright (c) 1998 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package URI::_ldap;
  
  use strict;
  
  use vars qw($VERSION);
  $VERSION = "1.11";
  
  use URI::Escape qw(uri_unescape);
  
  sub _ldap_elem {
    my $self  = shift;
    my $elem  = shift;
    my $query = $self->query;
    my @bits  = (split(/\?/,defined($query) ? $query : ""),("")x4);
    my $old   = $bits[$elem];
  
    if (@_) {
      my $new = shift;
      $new =~ s/\?/%3F/g;
      $bits[$elem] = $new;
      $query = join("?",@bits);
      $query =~ s/\?+$//;
      $query = undef unless length($query);
      $self->query($query);
    }
  
    $old;
  }
  
  sub dn {
    my $old = shift->path(@_);
    $old =~ s:^/::;
    uri_unescape($old);
  }
  
  sub attributes {
    my $self = shift;
    my $old = _ldap_elem($self,0, @_ ? join(",", map { my $tmp = $_; $tmp =~ s/,/%2C/g; $tmp } @_) : ());
    return $old unless wantarray;
    map { uri_unescape($_) } split(/,/,$old);
  }
  
  sub _scope {
    my $self = shift;
    my $old = _ldap_elem($self,1, @_);
    return unless defined wantarray && defined $old;
    uri_unescape($old);
  }
  
  sub scope {
    my $old = &_scope;
    $old = "base" unless length $old;
    $old;
  }
  
  sub _filter {
    my $self = shift;
    my $old = _ldap_elem($self,2, @_);
    return unless defined wantarray && defined $old;
    uri_unescape($old); # || "(objectClass=*)";
  }
  
  sub filter {
    my $old = &_filter;
    $old = "(objectClass=*)" unless length $old;
    $old;
  }
  
  sub extensions {
    my $self = shift;
    my @ext;
    while (@_) {
      my $key = shift;
      my $value = shift;
      push(@ext, join("=", map { $_="" unless defined; s/,/%2C/g; $_ } $key, $value));
    }
    @ext = join(",", @ext) if @ext;
    my $old = _ldap_elem($self,3, @ext);
    return $old unless wantarray;
    map { uri_unescape($_) } map { /^([^=]+)=(.*)$/ } split(/,/,$old);
  }
  
  sub canonical
  {
      my $self = shift;
      my $other = $self->_nonldap_canonical;
  
      # The stuff below is not as efficient as one might hope...
  
      $other = $other->clone if $other == $self;
  
      $other->dn(_normalize_dn($other->dn));
  
      # Should really know about mixed case "postalAddress", etc...
      $other->attributes(map lc, $other->attributes);
  
      # Lowercase scope, remove default
      my $old_scope = $other->scope;
      my $new_scope = lc($old_scope);
      $new_scope = "" if $new_scope eq "base";
      $other->scope($new_scope) if $new_scope ne $old_scope;
  
      # Remove filter if default
      my $old_filter = $other->filter;
      $other->filter("") if lc($old_filter) eq "(objectclass=*)" ||
  	                  lc($old_filter) eq "objectclass=*";
  
      # Lowercase extensions types and deal with known extension values
      my @ext = $other->extensions;
      for (my $i = 0; $i < @ext; $i += 2) {
  	my $etype = $ext[$i] = lc($ext[$i]);
  	if ($etype =~ /^!?bindname$/) {
  	    $ext[$i+1] = _normalize_dn($ext[$i+1]);
  	}
      }
      $other->extensions(@ext) if @ext;
      
      $other;
  }
  
  sub _normalize_dn  # RFC 2253
  {
      my $dn = shift;
  
      return $dn;
      # The code below will fail if the "+" or "," is embedding in a quoted
      # string or simply escaped...
  
      my @dn = split(/([+,])/, $dn);
      for (@dn) {
  	s/^([a-zA-Z]+=)/lc($1)/e;
      }
      join("", @dn);
  }
  
  1;
URI__LDAP

$fatpacked{"URI/_login.pm"} = <<'URI__LOGIN';
  package URI::_login;
  
  require URI::_server;
  require URI::_userpass;
  @ISA = qw(URI::_server URI::_userpass);
  
  # Generic terminal logins.  This is used as a base class for 'telnet',
  # 'tn3270', and 'rlogin' URL schemes.
  
  1;
URI__LOGIN

$fatpacked{"URI/_punycode.pm"} = <<'URI__PUNYCODE';
  package URI::_punycode;
  
  use strict;
  our $VERSION = "0.03";
  
  require Exporter;
  our @ISA    = qw(Exporter);
  our @EXPORT = qw(encode_punycode decode_punycode);
  
  use integer;
  
  our $DEBUG = 0;
  
  use constant BASE => 36;
  use constant TMIN => 1;
  use constant TMAX => 26;
  use constant SKEW => 38;
  use constant DAMP => 700;
  use constant INITIAL_BIAS => 72;
  use constant INITIAL_N => 128;
  
  my $Delimiter = chr 0x2D;
  my $BasicRE   = qr/[\x00-\x7f]/;
  
  sub _croak { require Carp; Carp::croak(@_); }
  
  sub digit_value {
      my $code = shift;
      return ord($code) - ord("A") if $code =~ /[A-Z]/;
      return ord($code) - ord("a") if $code =~ /[a-z]/;
      return ord($code) - ord("0") + 26 if $code =~ /[0-9]/;
      return;
  }
  
  sub code_point {
      my $digit = shift;
      return $digit + ord('a') if 0 <= $digit && $digit <= 25;
      return $digit + ord('0') - 26 if 26 <= $digit && $digit <= 36;
      die 'NOT COME HERE';
  }
  
  sub adapt {
      my($delta, $numpoints, $firsttime) = @_;
      $delta = $firsttime ? $delta / DAMP : $delta / 2;
      $delta += $delta / $numpoints;
      my $k = 0;
      while ($delta > ((BASE - TMIN) * TMAX) / 2) {
  	$delta /= BASE - TMIN;
  	$k += BASE;
      }
      return $k + (((BASE - TMIN + 1) * $delta) / ($delta + SKEW));
  }
  
  sub decode_punycode {
      my $code = shift;
  
      my $n      = INITIAL_N;
      my $i      = 0;
      my $bias   = INITIAL_BIAS;
      my @output;
  
      if ($code =~ s/(.*)$Delimiter//o) {
  	push @output, map ord, split //, $1;
  	return _croak('non-basic code point') unless $1 =~ /^$BasicRE*$/o;
      }
  
      while ($code) {
  	my $oldi = $i;
  	my $w    = 1;
      LOOP:
  	for (my $k = BASE; 1; $k += BASE) {
  	    my $cp = substr($code, 0, 1, '');
  	    my $digit = digit_value($cp);
  	    defined $digit or return _croak("invalid punycode input");
  	    $i += $digit * $w;
  	    my $t = ($k <= $bias) ? TMIN
  		: ($k >= $bias + TMAX) ? TMAX : $k - $bias;
  	    last LOOP if $digit < $t;
  	    $w *= (BASE - $t);
  	}
  	$bias = adapt($i - $oldi, @output + 1, $oldi == 0);
  	warn "bias becomes $bias" if $DEBUG;
  	$n += $i / (@output + 1);
  	$i = $i % (@output + 1);
  	splice(@output, $i, 0, $n);
  	warn join " ", map sprintf('%04x', $_), @output if $DEBUG;
  	$i++;
      }
      return join '', map chr, @output;
  }
  
  sub encode_punycode {
      my $input = shift;
      # my @input = split //, $input; # doesn't work in 5.6.x!
      my @input = map substr($input, $_, 1), 0..length($input)-1;
  
      my $n     = INITIAL_N;
      my $delta = 0;
      my $bias  = INITIAL_BIAS;
  
      my @output;
      my @basic = grep /$BasicRE/, @input;
      my $h = my $b = @basic;
      push @output, @basic;
      push @output, $Delimiter if $b && $h < @input;
      warn "basic codepoints: (@output)" if $DEBUG;
  
      while ($h < @input) {
  	my $m = min(grep { $_ >= $n } map ord, @input);
  	warn sprintf "next code point to insert is %04x", $m if $DEBUG;
  	$delta += ($m - $n) * ($h + 1);
  	$n = $m;
  	for my $i (@input) {
  	    my $c = ord($i);
  	    $delta++ if $c < $n;
  	    if ($c == $n) {
  		my $q = $delta;
  	    LOOP:
  		for (my $k = BASE; 1; $k += BASE) {
  		    my $t = ($k <= $bias) ? TMIN :
  			($k >= $bias + TMAX) ? TMAX : $k - $bias;
  		    last LOOP if $q < $t;
  		    my $cp = code_point($t + (($q - $t) % (BASE - $t)));
  		    push @output, chr($cp);
  		    $q = ($q - $t) / (BASE - $t);
  		}
  		push @output, chr(code_point($q));
  		$bias = adapt($delta, $h + 1, $h == $b);
  		warn "bias becomes $bias" if $DEBUG;
  		$delta = 0;
  		$h++;
  	    }
  	}
  	$delta++;
  	$n++;
      }
      return join '', @output;
  }
  
  sub min {
      my $min = shift;
      for (@_) { $min = $_ if $_ <= $min }
      return $min;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  URI::_punycode - encodes Unicode string in Punycode
  
  =head1 SYNOPSIS
  
    use URI::_punycode;
    $punycode = encode_punycode($unicode);
    $unicode  = decode_punycode($punycode);
  
  =head1 DESCRIPTION
  
  URI::_punycode is a module to encode / decode Unicode strings into
  Punycode, an efficient encoding of Unicode for use with IDNA.
  
  This module requires Perl 5.6.0 or over to handle UTF8 flagged Unicode
  strings.
  
  =head1 FUNCTIONS
  
  This module exports following functions by default.
  
  =over 4
  
  =item encode_punycode
  
    $punycode = encode_punycode($unicode);
  
  takes Unicode string (UTF8-flagged variable) and returns Punycode
  encoding for it.
  
  =item decode_punycode
  
    $unicode = decode_punycode($punycode)
  
  takes Punycode encoding and returns original Unicode string.
  
  =back
  
  These functions throw exceptions on failure. You can catch 'em via
  C<eval>.
  
  =head1 AUTHOR
  
  Tatsuhiko Miyagawa E<lt>miyagawa@bulknews.netE<gt> is the author of
  IDNA::Punycode v0.02 which was the basis for this module.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<IDNA::Punycode>, RFC 3492
  
  =cut
URI__PUNYCODE

$fatpacked{"URI/_query.pm"} = <<'URI__QUERY';
  package URI::_query;
  
  use strict;
  use URI ();
  use URI::Escape qw(uri_unescape);
  
  sub query
  {
      my $self = shift;
      $$self =~ m,^([^?\#]*)(?:\?([^\#]*))?(.*)$,s or die;
  
      if (@_) {
  	my $q = shift;
  	$$self = $1;
  	if (defined $q) {
  	    $q =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;
  	    $$self .= "?$q";
  	}
  	$$self .= $3;
      }
      $2;
  }
  
  # Handle ...?foo=bar&bar=foo type of query
  sub query_form {
      my $self = shift;
      my $old = $self->query;
      if (@_) {
          # Try to set query string
          my $delim;
          my $r = $_[0];
          if (ref($r) eq "ARRAY") {
              $delim = $_[1];
              @_ = @$r;
          }
          elsif (ref($r) eq "HASH") {
              $delim = $_[1];
              @_ = %$r;
          }
          $delim = pop if @_ % 2;
  
          my @query;
          while (my($key,$vals) = splice(@_, 0, 2)) {
              $key = '' unless defined $key;
  	    $key =~ s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg;
  	    $key =~ s/ /+/g;
  	    $vals = [ref($vals) eq "ARRAY" ? @$vals : $vals];
              for my $val (@$vals) {
                  $val = '' unless defined $val;
  		$val =~ s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg;
                  $val =~ s/ /+/g;
                  push(@query, "$key=$val");
              }
          }
          if (@query) {
              unless ($delim) {
                  $delim = $1 if $old && $old =~ /([&;])/;
                  $delim ||= $URI::DEFAULT_QUERY_FORM_DELIMITER || "&";
              }
              $self->query(join($delim, @query));
          }
          else {
              $self->query(undef);
          }
      }
      return if !defined($old) || !length($old) || !defined(wantarray);
      return unless $old =~ /=/; # not a form
      map { s/\+/ /g; uri_unescape($_) }
           map { /=/ ? split(/=/, $_, 2) : ($_ => '')} split(/[&;]/, $old);
  }
  
  # Handle ...?dog+bones type of query
  sub query_keywords
  {
      my $self = shift;
      my $old = $self->query;
      if (@_) {
          # Try to set query string
  	my @copy = @_;
  	@copy = @{$copy[0]} if @copy == 1 && ref($copy[0]) eq "ARRAY";
  	for (@copy) { s/([;\/?:@&=+,\$\[\]%])/ URI::Escape::escape_char($1)/eg; }
  	$self->query(@copy ? join('+', @copy) : undef);
      }
      return if !defined($old) || !defined(wantarray);
      return if $old =~ /=/;  # not keywords, but a form
      map { uri_unescape($_) } split(/\+/, $old, -1);
  }
  
  # Some URI::URL compatibility stuff
  *equery = \&query;
  
  1;
URI__QUERY

$fatpacked{"URI/_segment.pm"} = <<'URI__SEGMENT';
  package URI::_segment;
  
  # Represents a generic path_segment so that it can be treated as
  # a string too.
  
  use strict;
  use URI::Escape qw(uri_unescape);
  
  use overload '""' => sub { $_[0]->[0] },
               fallback => 1;
  
  sub new
  {
      my $class = shift;
      my @segment = split(';', shift, -1);
      $segment[0] = uri_unescape($segment[0]);
      bless \@segment, $class;
  }
  
  1;
URI__SEGMENT

$fatpacked{"URI/_server.pm"} = <<'URI__SERVER';
  package URI::_server;
  require URI::_generic;
  @ISA=qw(URI::_generic);
  
  use strict;
  use URI::Escape qw(uri_unescape);
  
  sub _uric_escape {
      my($class, $str) = @_;
      if ($str =~ m,^((?:$URI::scheme_re:)?)//([^/?\#]*)(.*)$,os) {
  	my($scheme, $host, $rest) = ($1, $2, $3);
  	my $ui = $host =~ s/(.*@)// ? $1 : "";
  	my $port = $host =~ s/(:\d+)\z// ? $1 : "";
  	if (_host_escape($host)) {
  	    $str = "$scheme//$ui$host$port$rest";
  	}
      }
      return $class->SUPER::_uric_escape($str);
  }
  
  sub _host_escape {
      return unless $_[0] =~ /[^URI::uric]/;
      eval {
  	require URI::_idna;
  	$_[0] = URI::_idna::encode($_[0]);
      };
      return 0 if $@;
      return 1;
  }
  
  sub as_iri {
      my $self = shift;
      my $str = $self->SUPER::as_iri;
      if ($str =~ /\bxn--/) {
  	if ($str =~ m,^((?:$URI::scheme_re:)?)//([^/?\#]*)(.*)$,os) {
  	    my($scheme, $host, $rest) = ($1, $2, $3);
  	    my $ui = $host =~ s/(.*@)// ? $1 : "";
  	    my $port = $host =~ s/(:\d+)\z// ? $1 : "";
  	    require URI::_idna;
  	    $host = URI::_idna::decode($host);
  	    $str = "$scheme//$ui$host$port$rest";
  	}
      }
      return $str;
  }
  
  sub userinfo
  {
      my $self = shift;
      my $old = $self->authority;
  
      if (@_) {
  	my $new = $old;
  	$new = "" unless defined $new;
  	$new =~ s/.*@//;  # remove old stuff
  	my $ui = shift;
  	if (defined $ui) {
  	    $ui =~ s/@/%40/g;   # protect @
  	    $new = "$ui\@$new";
  	}
  	$self->authority($new);
      }
      return undef if !defined($old) || $old !~ /(.*)@/;
      return $1;
  }
  
  sub host
  {
      my $self = shift;
      my $old = $self->authority;
      if (@_) {
  	my $tmp = $old;
  	$tmp = "" unless defined $tmp;
  	my $ui = ($tmp =~ /(.*@)/) ? $1 : "";
  	my $port = ($tmp =~ /(:\d+)$/) ? $1 : "";
  	my $new = shift;
  	$new = "" unless defined $new;
  	if (length $new) {
  	    $new =~ s/[@]/%40/g;   # protect @
  	    if ($new =~ /^[^:]*:\d*\z/ || $new =~ /]:\d*\z/) {
  		$new =~ s/(:\d*)\z// || die "Assert";
  		$port = $1;
  	    }
  	    $new = "[$new]" if $new =~ /:/ && $new !~ /^\[/; # IPv6 address
  	    _host_escape($new);
  	}
  	$self->authority("$ui$new$port");
      }
      return undef unless defined $old;
      $old =~ s/.*@//;
      $old =~ s/:\d+$//;          # remove the port
      $old =~ s{^\[(.*)\]$}{$1};  # remove brackets around IPv6 (RFC 3986 3.2.2)
      return uri_unescape($old);
  }
  
  sub ihost
  {
      my $self = shift;
      my $old = $self->host(@_);
      if ($old =~ /(^|\.)xn--/) {
  	require URI::_idna;
  	$old = URI::_idna::decode($old);
      }
      return $old;
  }
  
  sub _port
  {
      my $self = shift;
      my $old = $self->authority;
      if (@_) {
  	my $new = $old;
  	$new =~ s/:\d*$//;
  	my $port = shift;
  	$new .= ":$port" if defined $port;
  	$self->authority($new);
      }
      return $1 if defined($old) && $old =~ /:(\d*)$/;
      return;
  }
  
  sub port
  {
      my $self = shift;
      my $port = $self->_port(@_);
      $port = $self->default_port if !defined($port) || $port eq "";
      $port;
  }
  
  sub host_port
  {
      my $self = shift;
      my $old = $self->authority;
      $self->host(shift) if @_;
      return undef unless defined $old;
      $old =~ s/.*@//;        # zap userinfo
      $old =~ s/:$//;         # empty port should be treated the same a no port
      $old .= ":" . $self->port unless $old =~ /:\d+$/;
      $old;
  }
  
  
  sub default_port { undef }
  
  sub canonical
  {
      my $self = shift;
      my $other = $self->SUPER::canonical;
      my $host = $other->host || "";
      my $port = $other->_port;
      my $uc_host = $host =~ /[A-Z]/;
      my $def_port = defined($port) && ($port eq "" ||
                                        $port == $self->default_port);
      if ($uc_host || $def_port) {
  	$other = $other->clone if $other == $self;
  	$other->host(lc $host) if $uc_host;
  	$other->port(undef)    if $def_port;
      }
      $other;
  }
  
  1;
URI__SERVER

$fatpacked{"URI/_userpass.pm"} = <<'URI__USERPASS';
  package URI::_userpass;
  
  use strict;
  use URI::Escape qw(uri_unescape);
  
  sub user
  {
      my $self = shift;
      my $info = $self->userinfo;
      if (@_) {
  	my $new = shift;
  	my $pass = defined($info) ? $info : "";
  	$pass =~ s/^[^:]*//;
  
  	if (!defined($new) && !length($pass)) {
  	    $self->userinfo(undef);
  	} else {
  	    $new = "" unless defined($new);
  	    $new =~ s/%/%25/g;
  	    $new =~ s/:/%3A/g;
  	    $self->userinfo("$new$pass");
  	}
      }
      return unless defined $info;
      $info =~ s/:.*//;
      uri_unescape($info);
  }
  
  sub password
  {
      my $self = shift;
      my $info = $self->userinfo;
      if (@_) {
  	my $new = shift;
  	my $user = defined($info) ? $info : "";
  	$user =~ s/:.*//;
  
  	if (!defined($new) && !length($user)) {
  	    $self->userinfo(undef);
  	} else {
  	    $new = "" unless defined($new);
  	    $new =~ s/%/%25/g;
  	    $self->userinfo("$user:$new");
  	}
      }
      return unless defined $info;
      return unless $info =~ s/^[^:]*://;
      uri_unescape($info);
  }
  
  1;
URI__USERPASS

$fatpacked{"URI/data.pm"} = <<'URI_DATA';
  package URI::data;  # RFC 2397
  
  require URI;
  @ISA=qw(URI);
  
  use strict;
  
  use MIME::Base64 qw(encode_base64 decode_base64);
  use URI::Escape  qw(uri_unescape);
  
  sub media_type
  {
      my $self = shift;
      my $opaque = $self->opaque;
      $opaque =~ /^([^,]*),?/ or die;
      my $old = $1;
      my $base64;
      $base64 = $1 if $old =~ s/(;base64)$//i;
      if (@_) {
  	my $new = shift;
  	$new = "" unless defined $new;
  	$new =~ s/%/%25/g;
  	$new =~ s/,/%2C/g;
  	$base64 = "" unless defined $base64;
  	$opaque =~ s/^[^,]*,?/$new$base64,/;
  	$self->opaque($opaque);
      }
      return uri_unescape($old) if $old;  # media_type can't really be "0"
      "text/plain;charset=US-ASCII";      # default type
  }
  
  sub data
  {
      my $self = shift;
      my($enc, $data) = split(",", $self->opaque, 2);
      unless (defined $data) {
  	$data = "";
  	$enc  = "" unless defined $enc;
      }
      my $base64 = ($enc =~ /;base64$/i);
      if (@_) {
  	$enc =~ s/;base64$//i if $base64;
  	my $new = shift;
  	$new = "" unless defined $new;
  	my $uric_count = _uric_count($new);
  	my $urienc_len = $uric_count + (length($new) - $uric_count) * 3;
  	my $base64_len = int((length($new)+2) / 3) * 4;
  	$base64_len += 7;  # because of ";base64" marker
  	if ($base64_len < $urienc_len || $_[0]) {
  	    $enc .= ";base64";
  	    $new = encode_base64($new, "");
  	} else {
  	    $new =~ s/%/%25/g;
  	}
  	$self->opaque("$enc,$new");
      }
      return unless defined wantarray;
      $data = uri_unescape($data);
      return $base64 ? decode_base64($data) : $data;
  }
  
  # I could not find a better way to interpolate the tr/// chars from
  # a variable.
  my $ENC = $URI::uric;
  $ENC =~ s/%//;
  
  eval <<EOT; die $@ if $@;
  sub _uric_count
  {
      \$_[0] =~ tr/$ENC//;
  }
  EOT
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::data - URI that contains immediate data
  
  =head1 SYNOPSIS
  
   use URI;
  
   $u = URI->new("data:");
   $u->media_type("image/gif");
   $u->data(scalar(`cat camel.gif`));
   print "$u\n";
   open(XV, "|xv -") and print XV $u->data;
  
  =head1 DESCRIPTION
  
  The C<URI::data> class supports C<URI> objects belonging to the I<data>
  URI scheme.  The I<data> URI scheme is specified in RFC 2397.  It
  allows inclusion of small data items as "immediate" data, as if it had
  been included externally.  Examples:
  
    data:,Perl%20is%20good
  
    data:image/gif;base64,R0lGODdhIAAgAIAAAAAAAPj8+CwAAAAAI
      AAgAAAClYyPqcu9AJyCjtIKc5w5xP14xgeO2tlY3nWcajmZZdeJcG
      Kxrmimms1KMTa1Wg8UROx4MNUq1HrycMjHT9b6xKxaFLM6VRKzI+p
      KS9XtXpcbdun6uWVxJXA8pNPkdkkxhxc21LZHFOgD2KMoQXa2KMWI
      JtnE2KizVUkYJVZZ1nczBxXlFopZBtoJ2diXGdNUymmJdFMAADs=
  
  
  
  C<URI> objects belonging to the data scheme support the common methods
  (described in L<URI>) and the following two scheme-specific methods:
  
  =over 4
  
  =item $uri->media_type( [$new_media_type] )
  
  Can be used to get or set the media type specified in the
  URI.  If no media type is specified, then the default
  C<"text/plain;charset=US-ASCII"> is returned.
  
  =item $uri->data( [$new_data] )
  
  Can be used to get or set the data contained in the URI.
  The data is passed unescaped (in binary form).  The decision about
  whether to base64 encode the data in the URI is taken automatically,
  based on the encoding that produces the shorter URI string.
  
  =back
  
  =head1 SEE ALSO
  
  L<URI>
  
  =head1 COPYRIGHT
  
  Copyright 1995-1998 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
URI_DATA

$fatpacked{"URI/file.pm"} = <<'URI_FILE';
  package URI::file;
  
  use strict;
  use vars qw(@ISA $VERSION $DEFAULT_AUTHORITY %OS_CLASS);
  
  require URI::_generic;
  @ISA = qw(URI::_generic);
  $VERSION = "4.20";
  
  use URI::Escape qw(uri_unescape);
  
  $DEFAULT_AUTHORITY = "";
  
  # Map from $^O values to implementation classes.  The Unix
  # class is the default.
  %OS_CLASS = (
       os2     => "OS2",
       mac     => "Mac",
       MacOS   => "Mac",
       MSWin32 => "Win32",
       win32   => "Win32",
       msdos   => "FAT",
       dos     => "FAT",
       qnx     => "QNX",
  );
  
  sub os_class
  {
      my($OS) = shift || $^O;
  
      my $class = "URI::file::" . ($OS_CLASS{$OS} || "Unix");
      no strict 'refs';
      unless (%{"$class\::"}) {
  	eval "require $class";
  	die $@ if $@;
      }
      $class;
  }
  
  sub path { shift->path_query(@_) }
  sub host { uri_unescape(shift->authority(@_)) }
  
  sub new
  {
      my($class, $path, $os) = @_;
      os_class($os)->new($path);
  }
  
  sub new_abs
  {
      my $class = shift;
      my $file = $class->new(@_);
      return $file->abs($class->cwd) unless $$file =~ /^file:/;
      $file;
  }
  
  sub cwd
  {
      my $class = shift;
      require Cwd;
      my $cwd = Cwd::cwd();
      $cwd = VMS::Filespec::unixpath($cwd) if $^O eq 'VMS';
      $cwd = $class->new($cwd);
      $cwd .= "/" unless substr($cwd, -1, 1) eq "/";
      $cwd;
  }
  
  sub canonical {
      my $self = shift;
      my $other = $self->SUPER::canonical;
  
      my $scheme = $other->scheme;
      my $auth = $other->authority;
      return $other if !defined($scheme) && !defined($auth);  # relative
  
      if (!defined($auth) ||
  	$auth eq "" ||
  	lc($auth) eq "localhost" ||
  	(defined($DEFAULT_AUTHORITY) && lc($auth) eq lc($DEFAULT_AUTHORITY))
         )
      {
  	# avoid cloning if $auth already match
  	if ((defined($auth) || defined($DEFAULT_AUTHORITY)) &&
  	    (!defined($auth) || !defined($DEFAULT_AUTHORITY) || $auth ne $DEFAULT_AUTHORITY)
  	   )
  	{
  	    $other = $other->clone if $self == $other;
  	    $other->authority($DEFAULT_AUTHORITY);
          }
      }
  
      $other;
  }
  
  sub file
  {
      my($self, $os) = @_;
      os_class($os)->file($self);
  }
  
  sub dir
  {
      my($self, $os) = @_;
      os_class($os)->dir($self);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::file - URI that maps to local file names
  
  =head1 SYNOPSIS
  
   use URI::file;
   
   $u1 = URI->new("file:/foo/bar");
   $u2 = URI->new("foo/bar", "file");
   
   $u3 = URI::file->new($path);
   $u4 = URI::file->new("c:\\windows\\", "win32");
   
   $u1->file;
   $u1->file("mac");
  
  =head1 DESCRIPTION
  
  The C<URI::file> class supports C<URI> objects belonging to the I<file>
  URI scheme.  This scheme allows us to map the conventional file names
  found on various computer systems to the URI name space.  An old
  specification of the I<file> URI scheme is found in RFC 1738.  Some
  older background information is also in RFC 1630. There are no newer
  specifications as far as I know.
  
  If you simply want to construct I<file> URI objects from URI strings,
  use the normal C<URI> constructor.  If you want to construct I<file>
  URI objects from the actual file names used by various systems, then
  use one of the following C<URI::file> constructors:
  
  =over 4
  
  =item $u = URI::file->new( $filename, [$os] )
  
  Maps a file name to the I<file:> URI name space, creates a URI object
  and returns it.  The $filename is interpreted as belonging to the
  indicated operating system ($os), which defaults to the value of the
  $^O variable.  The $filename can be either absolute or relative, and
  the corresponding type of URI object for $os is returned.
  
  =item $u = URI::file->new_abs( $filename, [$os] )
  
  Same as URI::file->new, but makes sure that the URI returned
  represents an absolute file name.  If the $filename argument is
  relative, then the name is resolved relative to the current directory,
  i.e. this constructor is really the same as:
  
    URI::file->new($filename)->abs(URI::file->cwd);
  
  =item $u = URI::file->cwd
  
  Returns a I<file> URI that represents the current working directory.
  See L<Cwd>.
  
  =back
  
  The following methods are supported for I<file> URI (in addition to
  the common and generic methods described in L<URI>):
  
  =over 4
  
  =item $u->file( [$os] )
  
  Returns a file name.  It maps from the URI name space
  to the file name space of the indicated operating system.
  
  It might return C<undef> if the name can not be represented in the
  indicated file system.
  
  =item $u->dir( [$os] )
  
  Some systems use a different form for names of directories than for plain
  files.  Use this method if you know you want to use the name for
  a directory.
  
  =back
  
  The C<URI::file> module can be used to map generic file names to names
  suitable for the current system.  As such, it can work as a nice
  replacement for the C<File::Spec> module.  For instance, the following
  code translates the UNIX-style file name F<Foo/Bar.pm> to a name
  suitable for the local system:
  
    $file = URI::file->new("Foo/Bar.pm", "unix")->file;
    die "Can't map filename Foo/Bar.pm for $^O" unless defined $file;
    open(FILE, $file) || die "Can't open '$file': $!";
    # do something with FILE
  
  =head1 MAPPING NOTES
  
  Most computer systems today have hierarchically organized file systems.
  Mapping the names used in these systems to the generic URI syntax
  allows us to work with relative file URIs that behave as they should
  when resolved using the generic algorithm for URIs (specified in RFC
  2396).  Mapping a file name to the generic URI syntax involves mapping
  the path separator character to "/" and encoding any reserved
  characters that appear in the path segments of the file name.  If
  path segments consisting of the strings "." or ".." have a
  different meaning than what is specified for generic URIs, then these
  must be encoded as well.
  
  If the file system has device, volume or drive specifications as
  the root of the name space, then it makes sense to map them to the
  authority field of the generic URI syntax.  This makes sure that
  relative URIs can not be resolved "above" them, i.e. generally how
  relative file names work in those systems.
  
  Another common use of the authority field is to encode the host on which
  this file name is valid.  The host name "localhost" is special and
  generally has the same meaning as a missing or empty authority
  field.  This use is in conflict with using it as a device
  specification, but can often be resolved for device specifications
  having characters not legal in plain host names.
  
  File name to URI mapping in normally not one-to-one.  There are
  usually many URIs that map to any given file name.  For instance, an
  authority of "localhost" maps the same as a URI with a missing or empty
  authority.
  
  Example 1: The Mac uses ":" as path separator, but not in the same way
  as a generic URI. ":foo" is a relative name.  "foo:bar" is an absolute
  name.  Also, path segments can contain the "/" character as well as the
  literal "." or "..".  So the mapping looks like this:
  
    Mac                   URI
    ----------            -------------------
    :foo:bar     <==>     foo/bar
    :            <==>     ./
    ::foo:bar    <==>     ../foo/bar
    :::          <==>     ../../
    foo:bar      <==>     file:/foo/bar
    foo:bar:     <==>     file:/foo/bar/
    ..           <==>     %2E%2E
    <undef>      <==      /
    foo/         <==      file:/foo%2F
    ./foo.txt    <==      file:/.%2Ffoo.txt
  
  Note that if you want a relative URL, you *must* begin the path with a :.  Any
  path that begins with [^:] is treated as absolute.
  
  Example 2: The UNIX file system is easy to map, as it uses the same path
  separator as URIs, has a single root, and segments of "." and ".."
  have the same meaning.  URIs that have the character "\0" or "/" as
  part of any path segment can not be turned into valid UNIX file names.
  
    UNIX                  URI
    ----------            ------------------
    foo/bar      <==>     foo/bar
    /foo/bar     <==>     file:/foo/bar
    /foo/bar     <==      file://localhost/foo/bar
    file:         ==>     ./file:
    <undef>      <==      file:/fo%00/bar
    /            <==>     file:/
  
  =cut
  
  
  RFC 1630
  
     [...]
  
     There is clearly a danger of confusion that a link made to a local
     file should be followed by someone on a different system, with
     unexpected and possibly harmful results.  Therefore, the convention
     is that even a "file" URL is provided with a host part.  This allows
     a client on another system to know that it cannot access the file
     system, or perhaps to use some other local mechanism to access the
     file.
  
     The special value "localhost" is used in the host field to indicate
     that the filename should really be used on whatever host one is.
     This for example allows links to be made to files which are
     distributed on many machines, or to "your unix local password file"
     subject of course to consistency across the users of the data.
  
     A void host field is equivalent to "localhost".
  
  =head1 CONFIGURATION VARIABLES
  
  The following configuration variables influence how the class and its
  methods behave:
  
  =over
  
  =item %URI::file::OS_CLASS
  
  This hash maps OS identifiers to implementation classes.  You might
  want to add or modify this if you want to plug in your own file
  handler class.  Normally the keys should match the $^O values in use.
  
  If there is no mapping then the "Unix" implementation is used.
  
  =item $URI::file::DEFAULT_AUTHORITY
  
  This determine what "authority" string to include in absolute file
  URIs.  It defaults to "".  If you prefer verbose URIs you might set it
  to be "localhost".
  
  Setting this value to C<undef> force behaviour compatible to URI v1.31
  and earlier.  In this mode host names in UNC paths and drive letters
  are mapped to the authority component on Windows, while we produce
  authority-less URIs on Unix.
  
  =back
  
  
  =head1 SEE ALSO
  
  L<URI>, L<File::Spec>, L<perlport>
  
  =head1 COPYRIGHT
  
  Copyright 1995-1998,2004 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
URI_FILE

$fatpacked{"URI/file/Base.pm"} = <<'URI_FILE_BASE';
  package URI::file::Base;
  
  use strict;
  use URI::Escape qw();
  
  sub new
  {
      my $class = shift;
      my $path  = shift;
      $path = "" unless defined $path;
  
      my($auth, $escaped_auth, $escaped_path);
  
      ($auth, $escaped_auth) = $class->_file_extract_authority($path);
      ($path, $escaped_path) = $class->_file_extract_path($path);
  
      if (defined $auth) {
  	$auth =~ s,%,%25,g unless $escaped_auth;
  	$auth =~ s,([/?\#]), URI::Escape::escape_char($1),eg;
  	$auth = "//$auth";
  	if (defined $path) {
  	    $path = "/$path" unless substr($path, 0, 1) eq "/";
  	} else {
  	    $path = "";
  	}
      } else {
  	return undef unless defined $path;
  	$auth = "";
      }
  
      $path =~ s,([%;?]), URI::Escape::escape_char($1),eg unless $escaped_path;
      $path =~ s/\#/%23/g;
  
      my $uri = $auth . $path;
      $uri = "file:$uri" if substr($uri, 0, 1) eq "/";
  
      URI->new($uri, "file");
  }
  
  sub _file_extract_authority
  {
      my($class, $path) = @_;
      return undef unless $class->_file_is_absolute($path);
      return $URI::file::DEFAULT_AUTHORITY;
  }
  
  sub _file_extract_path
  {
      return undef;
  }
  
  sub _file_is_absolute
  {
      return 0;
  }
  
  sub _file_is_localhost
  {
      shift; # class
      my $host = lc(shift);
      return 1 if $host eq "localhost";
      eval {
  	require Net::Domain;
  	lc(Net::Domain::hostfqdn()) eq $host ||
  	lc(Net::Domain::hostname()) eq $host;
      };
  }
  
  sub file
  {
      undef;
  }
  
  sub dir
  {
      my $self = shift;
      $self->file(@_);
  }
  
  1;
URI_FILE_BASE

$fatpacked{"URI/file/FAT.pm"} = <<'URI_FILE_FAT';
  package URI::file::FAT;
  
  require URI::file::Win32;
  @ISA=qw(URI::file::Win32);
  
  sub fix_path
  {
      shift; # class
      for (@_) {
  	# turn it into 8.3 names
  	my @p = map uc, split(/\./, $_, -1);
  	return if @p > 2;     # more than 1 dot is not allowed
  	@p = ("") unless @p;  # split bug? (returns nothing when splitting "")
  	$_ = substr($p[0], 0, 8);
          if (@p > 1) {
  	    my $ext = substr($p[1], 0, 3);
  	    $_ .= ".$ext" if length $ext;
  	}
      }
      1;  # ok
  }
  
  1;
URI_FILE_FAT

$fatpacked{"URI/file/Mac.pm"} = <<'URI_FILE_MAC';
  package URI::file::Mac;
  
  require URI::file::Base;
  @ISA=qw(URI::file::Base);
  
  use strict;
  use URI::Escape qw(uri_unescape);
  
  
  
  sub _file_extract_path
  {
      my $class = shift;
      my $path = shift;
  
      my @pre;
      if ($path =~ s/^(:+)//) {
  	if (length($1) == 1) {
  	    @pre = (".") unless length($path);
  	} else {
  	    @pre = ("..") x (length($1) - 1);
  	}
      } else { #absolute
  	$pre[0] = "";
      }
  
      my $isdir = ($path =~ s/:$//);
      $path =~ s,([%/;]), URI::Escape::escape_char($1),eg;
  
      my @path = split(/:/, $path, -1);
      for (@path) {
  	if ($_ eq "." || $_ eq "..") {
  	    $_ = "%2E" x length($_);
  	}
  	$_ = ".." unless length($_);
      }
      push (@path,"") if $isdir;
      (join("/", @pre, @path), 1);
  }
  
  
  sub file
  {
      my $class = shift;
      my $uri = shift;
      my @path;
  
      my $auth = $uri->authority;
      if (defined $auth) {
  	if (lc($auth) ne "localhost" && $auth ne "") {
  	    my $u_auth = uri_unescape($auth);
  	    if (!$class->_file_is_localhost($u_auth)) {
  		# some other host (use it as volume name)
  		@path = ("", $auth);
  		# XXX or just return to make it illegal;
  	    }
  	}
      }
      my @ps = split("/", $uri->path, -1);
      shift @ps if @path;
      push(@path, @ps);
  
      my $pre = "";
      if (!@path) {
  	return;  # empty path; XXX return ":" instead?
      } elsif ($path[0] eq "") {
  	# absolute
  	shift(@path);
  	if (@path == 1) {
  	    return if $path[0] eq "";  # not root directory
  	    push(@path, "");           # volume only, effectively append ":"
  	}
  	@ps = @path;
  	@path = ();
          my $part;
  	for (@ps) {  #fix up "." and "..", including interior, in relatives
  	    next if $_ eq ".";
  	    $part = $_ eq ".." ? "" : $_;
  	    push(@path,$part);
  	}
  	if ($ps[-1] eq "..") {  #if this happens, we need another :
  	    push(@path,"");
  	}
  	
      } else {
  	$pre = ":";
  	@ps = @path;
  	@path = ();
          my $part;
  	for (@ps) {  #fix up "." and "..", including interior, in relatives
  	    next if $_ eq ".";
  	    $part = $_ eq ".." ? "" : $_;
  	    push(@path,$part);
  	}
  	if ($ps[-1] eq "..") {  #if this happens, we need another :
  	    push(@path,"");
  	}
  	
      }
      return unless $pre || @path;
      for (@path) {
  	s/;.*//;  # get rid of parameters
  	#return unless length; # XXX
  	$_ = uri_unescape($_);
  	return if /\0/;
  	return if /:/;  # Should we?
      }
      $pre . join(":", @path);
  }
  
  sub dir
  {
      my $class = shift;
      my $path = $class->file(@_);
      return unless defined $path;
      $path .= ":" unless $path =~ /:$/;
      $path;
  }
  
  1;
URI_FILE_MAC

$fatpacked{"URI/file/OS2.pm"} = <<'URI_FILE_OS2';
  package URI::file::OS2;
  
  require URI::file::Win32;
  @ISA=qw(URI::file::Win32);
  
  # The Win32 version translates k:/foo to file://k:/foo  (?!)
  # We add an empty host
  
  sub _file_extract_authority
  {
      my $class = shift;
      return $1 if $_[0] =~ s,^\\\\([^\\]+),,;  # UNC
      return $1 if $_[0] =~ s,^//([^/]+),,;     # UNC too?
  
      if ($_[0] =~ m#^[a-zA-Z]{1,2}:#) {	      # allow for ab: drives
  	return "";
      }
      return;
  }
  
  sub file {
    my $p = &URI::file::Win32::file;
    return unless defined $p;
    $p =~ s,\\,/,g;
    $p;
  }
  
  1;
URI_FILE_OS2

$fatpacked{"URI/file/QNX.pm"} = <<'URI_FILE_QNX';
  package URI::file::QNX;
  
  require URI::file::Unix;
  @ISA=qw(URI::file::Unix);
  
  use strict;
  
  sub _file_extract_path
  {
      my($class, $path) = @_;
      # tidy path
      $path =~ s,(.)//+,$1/,g; # ^// is correct
      $path =~ s,(/\.)+/,/,g;
      $path = "./$path" if $path =~ m,^[^:/]+:,,; # look like "scheme:"
      $path;
  }
  
  1;
URI_FILE_QNX

$fatpacked{"URI/file/Unix.pm"} = <<'URI_FILE_UNIX';
  package URI::file::Unix;
  
  require URI::file::Base;
  @ISA=qw(URI::file::Base);
  
  use strict;
  use URI::Escape qw(uri_unescape);
  
  sub _file_extract_path
  {
      my($class, $path) = @_;
  
      # tidy path
      $path =~ s,//+,/,g;
      $path =~ s,(/\.)+/,/,g;
      $path = "./$path" if $path =~ m,^[^:/]+:,,; # look like "scheme:"
  
      return $path;
  }
  
  sub _file_is_absolute {
      my($class, $path) = @_;
      return $path =~ m,^/,;
  }
  
  sub file
  {
      my $class = shift;
      my $uri = shift;
      my @path;
  
      my $auth = $uri->authority;
      if (defined($auth)) {
  	if (lc($auth) ne "localhost" && $auth ne "") {
  	    $auth = uri_unescape($auth);
  	    unless ($class->_file_is_localhost($auth)) {
  		push(@path, "", "", $auth);
  	    }
  	}
      }
  
      my @ps = $uri->path_segments;
      shift @ps if @path;
      push(@path, @ps);
  
      for (@path) {
  	# Unix file/directory names are not allowed to contain '\0' or '/'
  	return undef if /\0/;
  	return undef if /\//;  # should we really?
      }
  
      return join("/", @path);
  }
  
  1;
URI_FILE_UNIX

$fatpacked{"URI/file/Win32.pm"} = <<'URI_FILE_WIN32';
  package URI::file::Win32;
  
  require URI::file::Base;
  @ISA=qw(URI::file::Base);
  
  use strict;
  use URI::Escape qw(uri_unescape);
  
  sub _file_extract_authority
  {
      my $class = shift;
  
      return $class->SUPER::_file_extract_authority($_[0])
  	if defined $URI::file::DEFAULT_AUTHORITY;
  
      return $1 if $_[0] =~ s,^\\\\([^\\]+),,;  # UNC
      return $1 if $_[0] =~ s,^//([^/]+),,;     # UNC too?
  
      if ($_[0] =~ s,^([a-zA-Z]:),,) {
  	my $auth = $1;
  	$auth .= "relative" if $_[0] !~ m,^[\\/],;
  	return $auth;
      }
      return undef;
  }
  
  sub _file_extract_path
  {
      my($class, $path) = @_;
      $path =~ s,\\,/,g;
      #$path =~ s,//+,/,g;
      $path =~ s,(/\.)+/,/,g;
  
      if (defined $URI::file::DEFAULT_AUTHORITY) {
  	$path =~ s,^([a-zA-Z]:),/$1,;
      }
  
      return $path;
  }
  
  sub _file_is_absolute {
      my($class, $path) = @_;
      return $path =~ m,^[a-zA-Z]:, || $path =~ m,^[/\\],;
  }
  
  sub file
  {
      my $class = shift;
      my $uri = shift;
      my $auth = $uri->authority;
      my $rel; # is filename relative to drive specified in authority
      if (defined $auth) {
          $auth = uri_unescape($auth);
  	if ($auth =~ /^([a-zA-Z])[:|](relative)?/) {
  	    $auth = uc($1) . ":";
  	    $rel++ if $2;
  	} elsif (lc($auth) eq "localhost") {
  	    $auth = "";
  	} elsif (length $auth) {
  	    $auth = "\\\\" . $auth;  # UNC
  	}
      } else {
  	$auth = "";
      }
  
      my @path = $uri->path_segments;
      for (@path) {
  	return undef if /\0/;
  	return undef if /\//;
  	#return undef if /\\/;        # URLs with "\" is not uncommon
      }
      return undef unless $class->fix_path(@path);
  
      my $path = join("\\", @path);
      $path =~ s/^\\// if $rel;
      $path = $auth . $path;
      $path =~ s,^\\([a-zA-Z])[:|],\u$1:,;
  
      return $path;
  }
  
  sub fix_path { 1; }
  
  1;
URI_FILE_WIN32

$fatpacked{"URI/ftp.pm"} = <<'URI_FTP';
  package URI::ftp;
  
  require URI::_server;
  require URI::_userpass;
  @ISA=qw(URI::_server URI::_userpass);
  
  use strict;
  
  sub default_port { 21 }
  
  sub path { shift->path_query(@_) }  # XXX
  
  sub _user     { shift->SUPER::user(@_);     }
  sub _password { shift->SUPER::password(@_); }
  
  sub user
  {
      my $self = shift;
      my $user = $self->_user(@_);
      $user = "anonymous" unless defined $user;
      $user;
  }
  
  sub password
  {
      my $self = shift;
      my $pass = $self->_password(@_);
      unless (defined $pass) {
  	my $user = $self->user;
  	if ($user eq 'anonymous' || $user eq 'ftp') {
  	    # anonymous ftp login password
              # If there is no ftp anonymous password specified
              # then we'll just use 'anonymous@'
              # We don't try to send the read e-mail address because:
              # - We want to remain anonymous
              # - We want to stop SPAM
              # - We don't want to let ftp sites to discriminate by the user,
              #   host, country or ftp client being used.
  	    $pass = 'anonymous@';
  	}
      }
      $pass;
  }
  
  1;
URI_FTP

$fatpacked{"URI/gopher.pm"} = <<'URI_GOPHER';
  package URI::gopher;  # <draft-murali-url-gopher>, Dec 4, 1996
  
  require URI::_server;
  @ISA=qw(URI::_server);
  
  use strict;
  use URI::Escape qw(uri_unescape);
  
  #  A Gopher URL follows the common internet scheme syntax as defined in 
  #  section 4.3 of [RFC-URL-SYNTAX]:
  #
  #        gopher://<host>[:<port>]/<gopher-path>
  #
  #  where
  #
  #        <gopher-path> :=  <gopher-type><selector> | 
  #                          <gopher-type><selector>%09<search> |
  #                          <gopher-type><selector>%09<search>%09<gopher+_string>
  #
  #        <gopher-type> := '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7'
  #                         '8' | '9' | '+' | 'I' | 'g' | 'T'
  #
  #        <selector>    := *pchar     Refer to RFC 1808 [4]
  #        <search>      := *pchar
  #        <gopher+_string> := *uchar  Refer to RFC 1738 [3]
  #        
  #  If the optional port is omitted, the port defaults to 70. 
  
  sub default_port { 70 }
  
  sub _gopher_type
  {
      my $self = shift;
      my $path = $self->path_query;
      $path =~ s,^/,,;
      my $gtype = $1 if $path =~ s/^(.)//s;
      if (@_) {
  	my $new_type = shift;
  	if (defined($new_type)) {
  	    Carp::croak("Bad gopher type '$new_type'")
                 unless length($new_type) == 1;
  	    substr($path, 0, 0) = $new_type;
  	    $self->path_query($path);
  	} else {
  	    Carp::croak("Can't delete gopher type when selector is present")
  		if length($path);
  	    $self->path_query(undef);
  	}
      }
      return $gtype;
  }
  
  sub gopher_type
  {
      my $self = shift;
      my $gtype = $self->_gopher_type(@_);
      $gtype = "1" unless defined $gtype;
      $gtype;
  }
  
  *gtype = \&gopher_type;  # URI::URL compatibility
  
  sub selector { shift->_gfield(0, @_) }
  sub search   { shift->_gfield(1, @_) }
  sub string   { shift->_gfield(2, @_) }
  
  sub _gfield
  {
      my $self = shift;
      my $fno  = shift;
      my $path = $self->path_query;
  
      # not according to spec., but many popular browsers accept
      # gopher URLs with a '?' before the search string.
      $path =~ s/\?/\t/;
      $path = uri_unescape($path);
      $path =~ s,^/,,;
      my $gtype = $1 if $path =~ s,^(.),,s;
      my @path = split(/\t/, $path, 3);
      if (@_) {
  	# modify
  	my $new = shift;
  	$path[$fno] = $new;
  	pop(@path) while @path && !defined($path[-1]);
  	for (@path) { $_="" unless defined }
  	$path = $gtype;
  	$path = "1" unless defined $path;
  	$path .= join("\t", @path);
  	$self->path_query($path);
      }
      $path[$fno];
  }
  
  1;
URI_GOPHER

$fatpacked{"URI/http.pm"} = <<'URI_HTTP';
  package URI::http;
  
  require URI::_server;
  @ISA=qw(URI::_server);
  
  use strict;
  
  sub default_port { 80 }
  
  sub canonical
  {
      my $self = shift;
      my $other = $self->SUPER::canonical;
  
      my $slash_path = defined($other->authority) &&
          !length($other->path) && !defined($other->query);
  
      if ($slash_path) {
  	$other = $other->clone if $other == $self;
  	$other->path("/");
      }
      $other;
  }
  
  1;
URI_HTTP

$fatpacked{"URI/https.pm"} = <<'URI_HTTPS';
  package URI::https;
  require URI::http;
  @ISA=qw(URI::http);
  
  sub default_port { 443 }
  
  sub secure { 1 }
  
  1;
URI_HTTPS

$fatpacked{"URI/ldap.pm"} = <<'URI_LDAP';
  # Copyright (c) 1998 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package URI::ldap;
  
  use strict;
  
  use vars qw(@ISA $VERSION);
  $VERSION = "1.11";
  
  require URI::_server;
  require URI::_ldap;
  @ISA=qw(URI::_ldap URI::_server);
  
  sub default_port { 389 }
  
  sub _nonldap_canonical {
      my $self = shift;
      $self->URI::_server::canonical(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  URI::ldap - LDAP Uniform Resource Locators
  
  =head1 SYNOPSIS
  
    use URI;
  
    $uri = URI->new("ldap:$uri_string");
    $dn     = $uri->dn;
    $filter = $uri->filter;
    @attr   = $uri->attributes;
    $scope  = $uri->scope;
    %extn   = $uri->extensions;
    
    $uri = URI->new("ldap:");  # start empty
    $uri->host("ldap.itd.umich.edu");
    $uri->dn("o=University of Michigan,c=US");
    $uri->attributes(qw(postalAddress));
    $uri->scope('sub');
    $uri->filter('(cn=Babs Jensen)');
    print $uri->as_string,"\n";
  
  =head1 DESCRIPTION
  
  C<URI::ldap> provides an interface to parse an LDAP URI into its
  constituent parts and also to build a URI as described in
  RFC 2255.
  
  =head1 METHODS
  
  C<URI::ldap> supports all the generic and server methods defined by
  L<URI>, plus the following.
  
  Each of the following methods can be used to set or get the value in
  the URI. The values are passed in unescaped form.  None of these
  return undefined values, but elements without a default can be empty.
  If arguments are given, then a new value is set for the given part
  of the URI.
  
  =over 4
  
  =item $uri->dn( [$new_dn] )
  
  Sets or gets the I<Distinguished Name> part of the URI.  The DN
  identifies the base object of the LDAP search.
  
  =item $uri->attributes( [@new_attrs] )
  
  Sets or gets the list of attribute names which are
  returned by the search.
  
  =item $uri->scope( [$new_scope] )
  
  Sets or gets the scope to be used by the search. The value can be one of
  C<"base">, C<"one"> or C<"sub">. If none is given in the URI then the
  return value defaults to C<"base">.
  
  =item $uri->_scope( [$new_scope] )
  
  Same as scope(), but does not default to anything.
  
  =item $uri->filter( [$new_filter] )
  
  Sets or gets the filter to be used by the search. If none is given in
  the URI then the return value defaults to C<"(objectClass=*)">.
  
  =item $uri->_filter( [$new_filter] )
  
  Same as filter(), but does not default to anything.
  
  =item $uri->extensions( [$etype => $evalue,...] )
  
  Sets or gets the extensions used for the search. The list passed should
  be in the form etype1 => evalue1, etype2 => evalue2,... This is also
  the form of list that is returned.
  
  =back
  
  =head1 SEE ALSO
  
  L<http://tools.ietf.org/html/rfc2255>
  
  =head1 AUTHOR
  
  Graham Barr E<lt>F<gbarr@pobox.com>E<gt>
  
  Slightly modified by Gisle Aas to fit into the URI distribution.
  
  =head1 COPYRIGHT
  
  Copyright (c) 1998 Graham Barr. All rights reserved. This program is
  free software; you can redistribute it and/or modify it under the same
  terms as Perl itself.
  
  =cut
URI_LDAP

$fatpacked{"URI/ldapi.pm"} = <<'URI_LDAPI';
  package URI::ldapi;
  
  use strict;
  
  use vars qw(@ISA);
  
  require URI::_generic;
  require URI::_ldap;
  @ISA=qw(URI::_ldap URI::_generic);
  
  require URI::Escape;
  
  sub un_path {
      my $self = shift;
      my $old = URI::Escape::uri_unescape($self->authority);
      if (@_) {
  	my $p = shift;
  	$p =~ s/:/%3A/g;
  	$p =~ s/\@/%40/g;
  	$self->authority($p);
      }
      return $old;
  }
  
  sub _nonldap_canonical {
      my $self = shift;
      $self->URI::_generic::canonical(@_);
  }
  
  1;
URI_LDAPI

$fatpacked{"URI/ldaps.pm"} = <<'URI_LDAPS';
  package URI::ldaps;
  require URI::ldap;
  @ISA=qw(URI::ldap);
  
  sub default_port { 636 }
  
  sub secure { 1 }
  
  1;
URI_LDAPS

$fatpacked{"URI/mailto.pm"} = <<'URI_MAILTO';
  package URI::mailto;  # RFC 2368
  
  require URI;
  require URI::_query;
  @ISA=qw(URI URI::_query);
  
  use strict;
  
  sub to
  {
      my $self = shift;
      my @old = $self->headers;
      if (@_) {
  	my @new = @old;
  	# get rid of any other to: fields
  	for (my $i = 0; $i < @new; $i += 2) {
  	    if (lc($new[$i] || '') eq "to") {
  		splice(@new, $i, 2);
  		redo;
  	    }
  	}
  
  	my $to = shift;
  	$to = "" unless defined $to;
  	unshift(@new, "to" => $to);
  	$self->headers(@new);
      }
      return unless defined wantarray;
  
      my @to;
      while (@old) {
  	my $h = shift @old;
  	my $v = shift @old;
  	push(@to, $v) if lc($h) eq "to";
      }
      join(",", @to);
  }
  
  
  sub headers
  {
      my $self = shift;
  
      # The trick is to just treat everything as the query string...
      my $opaque = "to=" . $self->opaque;
      $opaque =~ s/\?/&/;
  
      if (@_) {
  	my @new = @_;
  
  	# strip out any "to" fields
  	my @to;
  	for (my $i=0; $i < @new; $i += 2) {
  	    if (lc($new[$i] || '') eq "to") {
  		push(@to, (splice(@new, $i, 2))[1]);  # remove header
  		redo;
  	    }
  	}
  
  	my $new = join(",",@to);
  	$new =~ s/%/%25/g;
  	$new =~ s/\?/%3F/g;
  	$self->opaque($new);
  	$self->query_form(@new) if @new;
      }
      return unless defined wantarray;
  
      # I am lazy today...
      URI->new("mailto:?$opaque")->query_form;
  }
  
  1;
URI_MAILTO

$fatpacked{"URI/mms.pm"} = <<'URI_MMS';
  package URI::mms;
  
  require URI::http;
  @ISA=qw(URI::http);
  
  sub default_port { 1755 }
  
  1;
URI_MMS

$fatpacked{"URI/news.pm"} = <<'URI_NEWS';
  package URI::news;  # draft-gilman-news-url-01
  
  require URI::_server;
  @ISA=qw(URI::_server);
  
  use strict;
  use URI::Escape qw(uri_unescape);
  use Carp ();
  
  sub default_port { 119 }
  
  #   newsURL      =  scheme ":" [ news-server ] [ refbygroup | message ]
  #   scheme       =  "news" | "snews" | "nntp"
  #   news-server  =  "//" server "/"
  #   refbygroup   = group [ "/" messageno [ "-" messageno ] ]
  #   message      = local-part "@" domain
  
  sub _group
  {
      my $self = shift;
      my $old = $self->path;
      if (@_) {
  	my($group,$from,$to) = @_;
  	if ($group =~ /\@/) {
              $group =~ s/^<(.*)>$/$1/;  # "<" and ">" should not be part of it
  	}
  	$group =~ s,%,%25,g;
  	$group =~ s,/,%2F,g;
  	my $path = $group;
  	if (defined $from) {
  	    $path .= "/$from";
  	    $path .= "-$to" if defined $to;
  	}
  	$self->path($path);
      }
  
      $old =~ s,^/,,;
      if ($old !~ /\@/ && $old =~ s,/(.*),, && wantarray) {
  	my $extra = $1;
  	return (uri_unescape($old), split(/-/, $extra));
      }
      uri_unescape($old);
  }
  
  
  sub group
  {
      my $self = shift;
      if (@_) {
  	Carp::croak("Group name can't contain '\@'") if $_[0] =~ /\@/;
      }
      my @old = $self->_group(@_);
      return if $old[0] =~ /\@/;
      wantarray ? @old : $old[0];
  }
  
  sub message
  {
      my $self = shift;
      if (@_) {
  	Carp::croak("Message must contain '\@'") unless $_[0] =~ /\@/;
      }
      my $old = $self->_group(@_);
      return unless $old =~ /\@/;
      return $old;
  }
  
  1;
URI_NEWS

$fatpacked{"URI/nntp.pm"} = <<'URI_NNTP';
  package URI::nntp;  # draft-gilman-news-url-01
  
  require URI::news;
  @ISA=qw(URI::news);
  
  1;
URI_NNTP

$fatpacked{"URI/pop.pm"} = <<'URI_POP';
  package URI::pop;   # RFC 2384
  
  require URI::_server;
  @ISA=qw(URI::_server);
  
  use strict;
  use URI::Escape qw(uri_unescape);
  
  sub default_port { 110 }
  
  #pop://<user>;auth=<auth>@<host>:<port>
  
  sub user
  {
      my $self = shift;
      my $old = $self->userinfo;
  
      if (@_) {
  	my $new_info = $old;
  	$new_info = "" unless defined $new_info;
  	$new_info =~ s/^[^;]*//;
  
  	my $new = shift;
  	if (!defined($new) && !length($new_info)) {
  	    $self->userinfo(undef);
  	} else {
  	    $new = "" unless defined $new;
  	    $new =~ s/%/%25/g;
  	    $new =~ s/;/%3B/g;
  	    $self->userinfo("$new$new_info");
  	}
      }
  
      return unless defined $old;
      $old =~ s/;.*//;
      return uri_unescape($old);
  }
  
  sub auth
  {
      my $self = shift;
      my $old = $self->userinfo;
  
      if (@_) {
  	my $new = $old;
  	$new = "" unless defined $new;
  	$new =~ s/(^[^;]*)//;
  	my $user = $1;
  	$new =~ s/;auth=[^;]*//i;
  
  	
  	my $auth = shift;
  	if (defined $auth) {
  	    $auth =~ s/%/%25/g;
  	    $auth =~ s/;/%3B/g;
  	    $new = ";AUTH=$auth$new";
  	}
  	$self->userinfo("$user$new");
  	
      }
  
      return unless defined $old;
      $old =~ s/^[^;]*//;
      return uri_unescape($1) if $old =~ /;auth=(.*)/i;
      return;
  }
  
  1;
URI_POP

$fatpacked{"URI/rlogin.pm"} = <<'URI_RLOGIN';
  package URI::rlogin;
  require URI::_login;
  @ISA = qw(URI::_login);
  
  sub default_port { 513 }
  
  1;
URI_RLOGIN

$fatpacked{"URI/rsync.pm"} = <<'URI_RSYNC';
  package URI::rsync;  # http://rsync.samba.org/
  
  # rsync://[USER@]HOST[:PORT]/SRC
  
  require URI::_server;
  require URI::_userpass;
  
  @ISA=qw(URI::_server URI::_userpass);
  
  sub default_port { 873 }
  
  1;
URI_RSYNC

$fatpacked{"URI/rtsp.pm"} = <<'URI_RTSP';
  package URI::rtsp;
  
  require URI::http;
  @ISA=qw(URI::http);
  
  sub default_port { 554 }
  
  1;
URI_RTSP

$fatpacked{"URI/rtspu.pm"} = <<'URI_RTSPU';
  package URI::rtspu;
  
  require URI::rtsp;
  @ISA=qw(URI::rtsp);
  
  sub default_port { 554 }
  
  1;
URI_RTSPU

$fatpacked{"URI/sip.pm"} = <<'URI_SIP';
  #
  # Written by Ryan Kereliuk <ryker@ryker.org>.  This file may be
  # distributed under the same terms as Perl itself.
  #
  # The RFC 3261 sip URI is <scheme>:<authority>;<params>?<query>.
  #
  
  package URI::sip;
  
  require URI::_server;
  require URI::_userpass;
  @ISA=qw(URI::_server URI::_userpass);
  
  use strict;
  use vars qw(@ISA $VERSION);
  use URI::Escape qw(uri_unescape);
  
  $VERSION = "0.10";
  
  sub default_port { 5060 }
  
  sub authority
  {
      my $self = shift;
      $$self =~ m,^($URI::scheme_re:)?([^;?]*)(.*)$,os or die;
      my $old = $2;
  
      if (@_) {
          my $auth = shift;
          $$self = defined($1) ? $1 : "";
          my $rest = $3;
          if (defined $auth) {
              $auth =~ s/([^$URI::uric])/ URI::Escape::escape_char($1)/ego;
              $$self .= "$auth";
          }
          $$self .= $rest;
      }
      $old;
  }
  
  sub params_form
  {
      my $self = shift;
      $$self =~ m,^((?:$URI::scheme_re:)?)(?:([^;?]*))?(;[^?]*)?(.*)$,os or die;
      my $paramstr = $3;
  
      if (@_) {
      	my @args = @_; 
          $$self = $1 . $2;
          my $rest = $4;
  	my @new;
  	for (my $i=0; $i < @args; $i += 2) {
  	    push(@new, "$args[$i]=$args[$i+1]");
  	}
  	$paramstr = join(";", @new);
  	$$self .= ";" . $paramstr . $rest;
      }
      $paramstr =~ s/^;//o;
      return split(/[;=]/, $paramstr);
  }
  
  sub params
  {
      my $self = shift;
      $$self =~ m,^((?:$URI::scheme_re:)?)(?:([^;?]*))?(;[^?]*)?(.*)$,os or die;
      my $paramstr = $3;
  
      if (@_) {
      	my $new = shift; 
          $$self = $1 . $2;
          my $rest = $4;
  	$$self .= $paramstr . $rest;
      }
      $paramstr =~ s/^;//o;
      return $paramstr;
  }
  
  # Inherited methods that make no sense for a SIP URI.
  sub path {}
  sub path_query {}
  sub path_segments {}
  sub abs { shift }
  sub rel { shift }
  sub query_keywords {}
  
  1;
URI_SIP

$fatpacked{"URI/sips.pm"} = <<'URI_SIPS';
  package URI::sips;
  require URI::sip;
  @ISA=qw(URI::sip);
  
  sub default_port { 5061 }
  
  sub secure { 1 }
  
  1;
URI_SIPS

$fatpacked{"URI/snews.pm"} = <<'URI_SNEWS';
  package URI::snews;  # draft-gilman-news-url-01
  
  require URI::news;
  @ISA=qw(URI::news);
  
  sub default_port { 563 }
  
  sub secure { 1 }
  
  1;
URI_SNEWS

$fatpacked{"URI/ssh.pm"} = <<'URI_SSH';
  package URI::ssh;
  require URI::_login;
  @ISA=qw(URI::_login);
  
  # ssh://[USER@]HOST[:PORT]/SRC
  
  sub default_port { 22 }
  
  sub secure { 1 }
  
  1;
URI_SSH

$fatpacked{"URI/telnet.pm"} = <<'URI_TELNET';
  package URI::telnet;
  require URI::_login;
  @ISA = qw(URI::_login);
  
  sub default_port { 23 }
  
  1;
URI_TELNET

$fatpacked{"URI/tn3270.pm"} = <<'URI_TN3270';
  package URI::tn3270;
  require URI::_login;
  @ISA = qw(URI::_login);
  
  sub default_port { 23 }
  
  1;
URI_TN3270

$fatpacked{"URI/urn.pm"} = <<'URI_URN';
  package URI::urn;  # RFC 2141
  
  require URI;
  @ISA=qw(URI);
  
  use strict;
  use Carp qw(carp);
  
  use vars qw(%implementor);
  
  sub _init {
      my $class = shift;
      my $self = $class->SUPER::_init(@_);
      my $nid = $self->nid;
  
      my $impclass = $implementor{$nid};
      return $impclass->_urn_init($self, $nid) if $impclass;
  
      $impclass = "URI::urn";
      if ($nid =~ /^[A-Za-z\d][A-Za-z\d\-]*\z/) {
  	my $id = $nid;
  	# make it a legal perl identifier
  	$id =~ s/-/_/g;
  	$id = "_$id" if $id =~ /^\d/;
  
  	$impclass = "URI::urn::$id";
  	no strict 'refs';
  	unless (@{"${impclass}::ISA"}) {
  	    # Try to load it
  	    eval "require $impclass";
  	    die $@ if $@ && $@ !~ /Can\'t locate.*in \@INC/;
  	    $impclass = "URI::urn" unless @{"${impclass}::ISA"};
  	}
      }
      else {
  	carp("Illegal namespace identifier '$nid' for URN '$self'") if $^W;
      }
      $implementor{$nid} = $impclass;
  
      return $impclass->_urn_init($self, $nid);
  }
  
  sub _urn_init {
      my($class, $self, $nid) = @_;
      bless $self, $class;
  }
  
  sub _nid {
      my $self = shift;
      my $opaque = $self->opaque;
      if (@_) {
  	my $v = $opaque;
  	my $new = shift;
  	$v =~ s/[^:]*/$new/;
  	$self->opaque($v);
  	# XXX possible rebless
      }
      $opaque =~ s/:.*//s;
      return $opaque;
  }
  
  sub nid {  # namespace identifier
      my $self = shift;
      my $nid = $self->_nid(@_);
      $nid = lc($nid) if defined($nid);
      return $nid;
  }
  
  sub nss {  # namespace specific string
      my $self = shift;
      my $opaque = $self->opaque;
      if (@_) {
  	my $v = $opaque;
  	my $new = shift;
  	if (defined $new) {
  	    $v =~ s/(:|\z).*/:$new/;
  	}
  	else {
  	    $v =~ s/:.*//s;
  	}
  	$self->opaque($v);
      }
      return undef unless $opaque =~ s/^[^:]*://;
      return $opaque;
  }
  
  sub canonical {
      my $self = shift;
      my $nid = $self->_nid;
      my $new = $self->SUPER::canonical;
      return $new if $nid !~ /[A-Z]/ || $nid =~ /%/;
      $new = $new->clone if $new == $self;
      $new->nid(lc($nid));
      return $new;
  }
  
  1;
URI_URN

$fatpacked{"URI/urn/isbn.pm"} = <<'URI_URN_ISBN';
  package URI::urn::isbn;  # RFC 3187
  
  require URI::urn;
  @ISA=qw(URI::urn);
  
  use strict;
  use Carp qw(carp);
  
  BEGIN {
      require Business::ISBN;
      
      local $^W = 0; # don't warn about dev versions, perl5.004 style
      warn "Using Business::ISBN version " . Business::ISBN->VERSION . 
          " which is deprecated.\nUpgrade to Business::ISBN version 2\n"
          if Business::ISBN->VERSION < 2;
      }
      
  sub _isbn {
      my $nss = shift;
      $nss = $nss->nss if ref($nss);
      my $isbn = Business::ISBN->new($nss);
      $isbn = undef if $isbn && !$isbn->is_valid;
      return $isbn;
  }
  
  sub _nss_isbn {
      my $self = shift;
      my $nss = $self->nss(@_);
      my $isbn = _isbn($nss);
      $isbn = $isbn->as_string if $isbn;
      return($nss, $isbn);
  }
  
  sub isbn {
      my $self = shift;
      my $isbn;
      (undef, $isbn) = $self->_nss_isbn(@_);
      return $isbn;
  }
  
  sub isbn_publisher_code {
      my $isbn = shift->_isbn || return undef;
      return $isbn->publisher_code;
  }
  
  BEGIN {
  my $group_method = do {
      local $^W = 0; # don't warn about dev versions, perl5.004 style
      Business::ISBN->VERSION >= 2 ? 'group_code' : 'country_code';
      };
  
  sub isbn_group_code {
      my $isbn = shift->_isbn || return undef;
      return $isbn->$group_method;
  }
  }
  
  sub isbn_country_code {
      my $name = (caller(0))[3]; $name =~ s/.*:://;
      carp "$name is DEPRECATED. Use isbn_group_code instead";
      
      no strict 'refs';
      &isbn_group_code;
  }
  
  BEGIN {
  my $isbn13_method = do {
      local $^W = 0; # don't warn about dev versions, perl5.004 style
      Business::ISBN->VERSION >= 2 ? 'as_isbn13' : 'as_ean';
      };
  
  sub isbn13 {
      my $isbn = shift->_isbn || return undef;
      
      # Business::ISBN 1.x didn't put hyphens in the EAN, and it was just a string
      # Business::ISBN 2.0 doesn't do EAN, but it does ISBN-13 objects
      #   and it uses the hyphens, so call as_string with an empty anon array
      # or, adjust the test and features to say that it comes out with hyphens.
      my $thingy = $isbn->$isbn13_method;
      return eval { $thingy->can( 'as_string' ) } ? $thingy->as_string([]) : $thingy;
  }
  }
  
  sub isbn_as_ean {
      my $name = (caller(0))[3]; $name =~ s/.*:://;
      carp "$name is DEPRECATED. Use isbn13 instead";
  
      no strict 'refs';
      &isbn13;
  }
  
  sub canonical {
      my $self = shift;
      my($nss, $isbn) = $self->_nss_isbn;
      my $new = $self->SUPER::canonical;
      return $new unless $nss && $isbn && $nss ne $isbn;
      $new = $new->clone if $new == $self;
      $new->nss($isbn);
      return $new;
  }
  
  1;
URI_URN_ISBN

$fatpacked{"URI/urn/oid.pm"} = <<'URI_URN_OID';
  package URI::urn::oid;  # RFC 2061
  
  require URI::urn;
  @ISA=qw(URI::urn);
  
  use strict;
  
  sub oid {
      my $self = shift;
      my $old = $self->nss;
      if (@_) {
  	$self->nss(join(".", @_));
      }
      return split(/\./, $old) if wantarray;
      return $old;
  }
  
  1;
URI_URN_OID

$fatpacked{"WWW/RobotRules.pm"} = <<'WWW_ROBOTRULES';
  package WWW::RobotRules;
  
  $VERSION = "5.832";
  sub Version { $VERSION; }
  
  use strict;
  use URI ();
  
  
  
  sub new {
      my($class, $ua) = @_;
  
      # This ugly hack is needed to ensure backwards compatibility.
      # The "WWW::RobotRules" class is now really abstract.
      $class = "WWW::RobotRules::InCore" if $class eq "WWW::RobotRules";
  
      my $self = bless { }, $class;
      $self->agent($ua);
      $self;
  }
  
  
  sub parse {
      my($self, $robot_txt_uri, $txt, $fresh_until) = @_;
      $robot_txt_uri = URI->new("$robot_txt_uri");
      my $netloc = $robot_txt_uri->host . ":" . $robot_txt_uri->port;
  
      $self->clear_rules($netloc);
      $self->fresh_until($netloc, $fresh_until || (time + 365*24*3600));
  
      my $ua;
      my $is_me = 0;		# 1 iff this record is for me
      my $is_anon = 0;		# 1 iff this record is for *
      my $seen_disallow = 0;      # watch for missing record separators
      my @me_disallowed = ();	# rules disallowed for me
      my @anon_disallowed = ();	# rules disallowed for *
  
      # blank lines are significant, so turn CRLF into LF to avoid generating
      # false ones
      $txt =~ s/\015\012/\012/g;
  
      # split at \012 (LF) or \015 (CR) (Mac text files have just CR for EOL)
      for(split(/[\012\015]/, $txt)) {
  
  	# Lines containing only a comment are discarded completely, and
          # therefore do not indicate a record boundary.
  	next if /^\s*\#/;
  
  	s/\s*\#.*//;        # remove comments at end-of-line
  
  	if (/^\s*$/) {	    # blank line
  	    last if $is_me; # That was our record. No need to read the rest.
  	    $is_anon = 0;
  	    $seen_disallow = 0;
  	}
          elsif (/^\s*User-Agent\s*:\s*(.*)/i) {
  	    $ua = $1;
  	    $ua =~ s/\s+$//;
  
  	    if ($seen_disallow) {
  		# treat as start of a new record
  		$seen_disallow = 0;
  		last if $is_me; # That was our record. No need to read the rest.
  		$is_anon = 0;
  	    }
  
  	    if ($is_me) {
  		# This record already had a User-agent that
  		# we matched, so just continue.
  	    }
  	    elsif ($ua eq '*') {
  		$is_anon = 1;
  	    }
  	    elsif($self->is_me($ua)) {
  		$is_me = 1;
  	    }
  	}
  	elsif (/^\s*Disallow\s*:\s*(.*)/i) {
  	    unless (defined $ua) {
  		warn "RobotRules <$robot_txt_uri>: Disallow without preceding User-agent\n" if $^W;
  		$is_anon = 1;  # assume that User-agent: * was intended
  	    }
  	    my $disallow = $1;
  	    $disallow =~ s/\s+$//;
  	    $seen_disallow = 1;
  	    if (length $disallow) {
  		my $ignore;
  		eval {
  		    my $u = URI->new_abs($disallow, $robot_txt_uri);
  		    $ignore++ if $u->scheme ne $robot_txt_uri->scheme;
  		    $ignore++ if lc($u->host) ne lc($robot_txt_uri->host);
  		    $ignore++ if $u->port ne $robot_txt_uri->port;
  		    $disallow = $u->path_query;
  		    $disallow = "/" unless length $disallow;
  		};
  		next if $@;
  		next if $ignore;
  	    }
  
  	    if ($is_me) {
  		push(@me_disallowed, $disallow);
  	    }
  	    elsif ($is_anon) {
  		push(@anon_disallowed, $disallow);
  	    }
  	}
          elsif (/\S\s*:/) {
               # ignore
          }
  	else {
  	    warn "RobotRules <$robot_txt_uri>: Malformed record: <$_>\n" if $^W;
  	}
      }
  
      if ($is_me) {
  	$self->push_rules($netloc, @me_disallowed);
      }
      else {
  	$self->push_rules($netloc, @anon_disallowed);
      }
  }
  
  
  #
  # Returns TRUE if the given name matches the
  # name of this robot
  #
  sub is_me {
      my($self, $ua_line) = @_;
      my $me = $self->agent;
  
      # See whether my short-name is a substring of the
      #  "User-Agent: ..." line that we were passed:
  
      if(index(lc($me), lc($ua_line)) >= 0) {
        return 1;
      }
      else {
        return '';
      }
  }
  
  
  sub allowed {
      my($self, $uri) = @_;
      $uri = URI->new("$uri");
  
      return 1 unless $uri->scheme eq 'http' or $uri->scheme eq 'https';
       # Robots.txt applies to only those schemes.
  
      my $netloc = $uri->host . ":" . $uri->port;
  
      my $fresh_until = $self->fresh_until($netloc);
      return -1 if !defined($fresh_until) || $fresh_until < time;
  
      my $str = $uri->path_query;
      my $rule;
      for $rule ($self->rules($netloc)) {
  	return 1 unless length $rule;
  	return 0 if index($str, $rule) == 0;
      }
      return 1;
  }
  
  
  # The following methods must be provided by the subclass.
  sub agent;
  sub visit;
  sub no_visits;
  sub last_visits;
  sub fresh_until;
  sub push_rules;
  sub clear_rules;
  sub rules;
  sub dump;
  
  
  
  package WWW::RobotRules::InCore;
  
  use vars qw(@ISA);
  @ISA = qw(WWW::RobotRules);
  
  
  
  sub agent {
      my ($self, $name) = @_;
      my $old = $self->{'ua'};
      if ($name) {
          # Strip it so that it's just the short name.
          # I.e., "FooBot"                                      => "FooBot"
          #       "FooBot/1.2"                                  => "FooBot"
          #       "FooBot/1.2 [http://foobot.int; foo@bot.int]" => "FooBot"
  
  	$name = $1 if $name =~ m/(\S+)/; # get first word
  	$name =~ s!/.*!!;  # get rid of version
  	unless ($old && $old eq $name) {
  	    delete $self->{'loc'}; # all old info is now stale
  	    $self->{'ua'} = $name;
  	}
      }
      $old;
  }
  
  
  sub visit {
      my($self, $netloc, $time) = @_;
      return unless $netloc;
      $time ||= time;
      $self->{'loc'}{$netloc}{'last'} = $time;
      my $count = \$self->{'loc'}{$netloc}{'count'};
      if (!defined $$count) {
  	$$count = 1;
      }
      else {
  	$$count++;
      }
  }
  
  
  sub no_visits {
      my ($self, $netloc) = @_;
      $self->{'loc'}{$netloc}{'count'};
  }
  
  
  sub last_visit {
      my ($self, $netloc) = @_;
      $self->{'loc'}{$netloc}{'last'};
  }
  
  
  sub fresh_until {
      my ($self, $netloc, $fresh_until) = @_;
      my $old = $self->{'loc'}{$netloc}{'fresh'};
      if (defined $fresh_until) {
  	$self->{'loc'}{$netloc}{'fresh'} = $fresh_until;
      }
      $old;
  }
  
  
  sub push_rules {
      my($self, $netloc, @rules) = @_;
      push (@{$self->{'loc'}{$netloc}{'rules'}}, @rules);
  }
  
  
  sub clear_rules {
      my($self, $netloc) = @_;
      delete $self->{'loc'}{$netloc}{'rules'};
  }
  
  
  sub rules {
      my($self, $netloc) = @_;
      if (defined $self->{'loc'}{$netloc}{'rules'}) {
  	return @{$self->{'loc'}{$netloc}{'rules'}};
      }
      else {
  	return ();
      }
  }
  
  
  sub dump
  {
      my $self = shift;
      for (keys %$self) {
  	next if $_ eq 'loc';
  	print "$_ = $self->{$_}\n";
      }
      for (keys %{$self->{'loc'}}) {
  	my @rules = $self->rules($_);
  	print "$_: ", join("; ", @rules), "\n";
      }
  }
  
  
  1;
  
  __END__
  
  
  # Bender: "Well, I don't have anything else
  #          planned for today.  Let's get drunk!"
  
  =head1 NAME
  
  WWW::RobotRules - database of robots.txt-derived permissions
  
  =head1 SYNOPSIS
  
   use WWW::RobotRules;
   my $rules = WWW::RobotRules->new('MOMspider/1.0');
  
   use LWP::Simple qw(get);
  
   {
     my $url = "http://some.place/robots.txt";
     my $robots_txt = get $url;
     $rules->parse($url, $robots_txt) if defined $robots_txt;
   }
  
   {
     my $url = "http://some.other.place/robots.txt";
     my $robots_txt = get $url;
     $rules->parse($url, $robots_txt) if defined $robots_txt;
   }
  
   # Now we can check if a URL is valid for those servers
   # whose "robots.txt" files we've gotten and parsed:
   if($rules->allowed($url)) {
       $c = get $url;
       ...
   }
  
  =head1 DESCRIPTION
  
  This module parses F</robots.txt> files as specified in
  "A Standard for Robot Exclusion", at
  <http://www.robotstxt.org/wc/norobots.html>
  Webmasters can use the F</robots.txt> file to forbid conforming
  robots from accessing parts of their web site.
  
  The parsed files are kept in a WWW::RobotRules object, and this object
  provides methods to check if access to a given URL is prohibited.  The
  same WWW::RobotRules object can be used for one or more parsed
  F</robots.txt> files on any number of hosts.
  
  The following methods are provided:
  
  =over 4
  
  =item $rules = WWW::RobotRules->new($robot_name)
  
  This is the constructor for WWW::RobotRules objects.  The first
  argument given to new() is the name of the robot.
  
  =item $rules->parse($robot_txt_url, $content, $fresh_until)
  
  The parse() method takes as arguments the URL that was used to
  retrieve the F</robots.txt> file, and the contents of the file.
  
  =item $rules->allowed($uri)
  
  Returns TRUE if this robot is allowed to retrieve this URL.
  
  =item $rules->agent([$name])
  
  Get/set the agent name. NOTE: Changing the agent name will clear the robots.txt
  rules and expire times out of the cache.
  
  =back
  
  =head1 ROBOTS.TXT
  
  The format and semantics of the "/robots.txt" file are as follows
  (this is an edited abstract of
  <http://www.robotstxt.org/wc/norobots.html>):
  
  The file consists of one or more records separated by one or more
  blank lines. Each record contains lines of the form
  
    <field-name>: <value>
  
  The field name is case insensitive.  Text after the '#' character on a
  line is ignored during parsing.  This is used for comments.  The
  following <field-names> can be used:
  
  =over 3
  
  =item User-Agent
  
  The value of this field is the name of the robot the record is
  describing access policy for.  If more than one I<User-Agent> field is
  present the record describes an identical access policy for more than
  one robot. At least one field needs to be present per record.  If the
  value is '*', the record describes the default access policy for any
  robot that has not not matched any of the other records.
  
  The I<User-Agent> fields must occur before the I<Disallow> fields.  If a
  record contains a I<User-Agent> field after a I<Disallow> field, that
  constitutes a malformed record.  This parser will assume that a blank
  line should have been placed before that I<User-Agent> field, and will
  break the record into two.  All the fields before the I<User-Agent> field
  will constitute a record, and the I<User-Agent> field will be the first
  field in a new record.
  
  =item Disallow
  
  The value of this field specifies a partial URL that is not to be
  visited. This can be a full path, or a partial path; any URL that
  starts with this value will not be retrieved
  
  =back
  
  Unrecognized records are ignored.
  
  =head1 ROBOTS.TXT EXAMPLES
  
  The following example "/robots.txt" file specifies that no robots
  should visit any URL starting with "/cyberworld/map/" or "/tmp/":
  
    User-agent: *
    Disallow: /cyberworld/map/ # This is an infinite virtual URL space
    Disallow: /tmp/ # these will soon disappear
  
  This example "/robots.txt" file specifies that no robots should visit
  any URL starting with "/cyberworld/map/", except the robot called
  "cybermapper":
  
    User-agent: *
    Disallow: /cyberworld/map/ # This is an infinite virtual URL space
  
    # Cybermapper knows where to go.
    User-agent: cybermapper
    Disallow:
  
  This example indicates that no robots should visit this site further:
  
    # go away
    User-agent: *
    Disallow: /
  
  This is an example of a malformed robots.txt file.
  
    # robots.txt for ancientcastle.example.com
    # I've locked myself away.
    User-agent: *
    Disallow: /
    # The castle is your home now, so you can go anywhere you like.
    User-agent: Belle
    Disallow: /west-wing/ # except the west wing!
    # It's good to be the Prince...
    User-agent: Beast
    Disallow:
  
  This file is missing the required blank lines between records.
  However, the intention is clear.
  
  =head1 SEE ALSO
  
  L<LWP::RobotUA>, L<WWW::RobotRules::AnyDBM_File>
WWW_ROBOTRULES

$fatpacked{"WWW/RobotRules/AnyDBM_File.pm"} = <<'WWW_ROBOTRULES_ANYDBM_FILE';
  package WWW::RobotRules::AnyDBM_File;
  
  require  WWW::RobotRules;
  @ISA = qw(WWW::RobotRules);
  $VERSION = "5.835";
  
  use Carp ();
  use AnyDBM_File;
  use Fcntl;
  use strict;
  
  =head1 NAME
  
  WWW::RobotRules::AnyDBM_File - Persistent RobotRules
  
  =head1 SYNOPSIS
  
   require WWW::RobotRules::AnyDBM_File;
   require LWP::RobotUA;
  
   # Create a robot useragent that uses a diskcaching RobotRules
   my $rules = WWW::RobotRules::AnyDBM_File->new( 'my-robot/1.0', 'cachefile' );
   my $ua = WWW::RobotUA->new( 'my-robot/1.0', 'me@foo.com', $rules );
  
   # Then just use $ua as usual
   $res = $ua->request($req);
  
  =head1 DESCRIPTION
  
  This is a subclass of I<WWW::RobotRules> that uses the AnyDBM_File
  package to implement persistent diskcaching of F<robots.txt> and host
  visit information.
  
  The constructor (the new() method) takes an extra argument specifying
  the name of the DBM file to use.  If the DBM file already exists, then
  you can specify undef as agent name as the name can be obtained from
  the DBM database.
  
  =cut
  
  sub new 
  { 
    my ($class, $ua, $file) = @_;
    Carp::croak('WWW::RobotRules::AnyDBM_File filename required') unless $file;
  
    my $self = bless { }, $class;
    $self->{'filename'} = $file;
    tie %{$self->{'dbm'}}, 'AnyDBM_File', $file, O_CREAT|O_RDWR, 0640
      or Carp::croak("Can't open $file: $!");
    
    if ($ua) {
        $self->agent($ua);
    }
    else {
        # Try to obtain name from DBM file
        $ua = $self->{'dbm'}{"|ua-name|"};
        Carp::croak("No agent name specified") unless $ua;
    }
  
    $self;
  }
  
  sub agent {
      my($self, $newname) = @_;
      my $old = $self->{'dbm'}{"|ua-name|"};
      if (defined $newname) {
  	$newname =~ s!/?\s*\d+.\d+\s*$!!;  # loose version
  	unless ($old && $old eq $newname) {
  	# Old info is now stale.
  	    my $file = $self->{'filename'};
  	    untie %{$self->{'dbm'}};
  	    tie %{$self->{'dbm'}}, 'AnyDBM_File', $file, O_TRUNC|O_RDWR, 0640;
  	    %{$self->{'dbm'}} = ();
  	    $self->{'dbm'}{"|ua-name|"} = $newname;
  	}
      }
      $old;
  }
  
  sub no_visits {
      my ($self, $netloc) = @_;
      my $t = $self->{'dbm'}{"$netloc|vis"};
      return 0 unless $t;
      (split(/;\s*/, $t))[0];
  }
  
  sub last_visit {
      my ($self, $netloc) = @_;
      my $t = $self->{'dbm'}{"$netloc|vis"};
      return undef unless $t;
      (split(/;\s*/, $t))[1];
  }
  
  sub fresh_until {
      my ($self, $netloc, $fresh) = @_;
      my $old = $self->{'dbm'}{"$netloc|exp"};
      if ($old) {
  	$old =~ s/;.*//;  # remove cleartext
      }
      if (defined $fresh) {
  	$fresh .= "; " . localtime($fresh);
  	$self->{'dbm'}{"$netloc|exp"} = $fresh;
      }
      $old;
  }
  
  sub visit {
      my($self, $netloc, $time) = @_;
      $time ||= time;
  
      my $count = 0;
      my $old = $self->{'dbm'}{"$netloc|vis"};
      if ($old) {
  	my $last;
  	($count,$last) = split(/;\s*/, $old);
  	$time = $last if $last > $time;
      }
      $count++;
      $self->{'dbm'}{"$netloc|vis"} = "$count; $time; " . localtime($time);
  }
  
  sub push_rules {
      my($self, $netloc, @rules) = @_;
      my $cnt = 1;
      $cnt++ while $self->{'dbm'}{"$netloc|r$cnt"};
  
      foreach (@rules) {
  	$self->{'dbm'}{"$netloc|r$cnt"} = $_;
  	$cnt++;
      }
  }
  
  sub clear_rules {
      my($self, $netloc) = @_;
      my $cnt = 1;
      while ($self->{'dbm'}{"$netloc|r$cnt"}) {
  	delete $self->{'dbm'}{"$netloc|r$cnt"};
  	$cnt++;
      }
  }
  
  sub rules {
      my($self, $netloc) = @_;
      my @rules = ();
      my $cnt = 1;
      while (1) {
  	my $rule = $self->{'dbm'}{"$netloc|r$cnt"};
  	last unless $rule;
  	push(@rules, $rule);
  	$cnt++;
      }
      @rules;
  }
  
  sub dump
  {
  }
  
  1;
  
  =head1 SEE ALSO
  
  L<WWW::RobotRules>, L<LWP::RobotUA>
  
  =head1 AUTHORS
  
  Hakan Ardo E<lt>hakan@munin.ub2.lu.se>, Gisle Aas E<lt>aas@sn.no>
  
  =cut
  
WWW_ROBOTRULES_ANYDBM_FILE

$fatpacked{"parent.pm"} = <<'PARENT';
  package parent;
  use strict;
  use vars qw($VERSION);
  $VERSION = '0.223';
  
  sub import {
      my $class = shift;
  
      my $inheritor = caller(0);
  
      if ( @_ and $_[0] eq '-norequire' ) {
          shift @_;
      } else {
          for ( my @filename = @_ ) {
              if ( $_ eq $inheritor ) {
                  warn "Class '$inheritor' tried to inherit from itself\n";
              };
  
              s{::|'}{/}g;
              require "$_.pm"; # dies if the file is not found
          }
      }
  
      {
          no strict 'refs';
          # This is more efficient than push for the new MRO
          # at least until the new MRO is fixed
          @{"$inheritor\::ISA"} = (@{"$inheritor\::ISA"} , @_);
      };
  };
  
  "All your base are belong to us"
  
  __END__
  
  =head1 NAME
  
  parent - Establish an ISA relationship with base classes at compile time
  
  =head1 SYNOPSIS
  
      package Baz;
      use parent qw(Foo Bar);
  
  =head1 DESCRIPTION
  
  Allows you to both load one or more modules, while setting up inheritance from
  those modules at the same time.  Mostly similar in effect to
  
      package Baz;
      BEGIN {
          require Foo;
          require Bar;
          push @ISA, qw(Foo Bar);
      }
  
  By default, every base class needs to live in a file of its own.
  If you want to have a subclass and its parent class in the same file, you
  can tell C<parent> not to load any modules by using the C<-norequire> switch:
  
    package Foo;
    sub exclaim { "I CAN HAS PERL" }
  
    package DoesNotLoadFooBar;
    use parent -norequire, 'Foo', 'Bar';
    # will not go looking for Foo.pm or Bar.pm
  
  This is equivalent to the following code:
  
    package Foo;
    sub exclaim { "I CAN HAS PERL" }
  
    package DoesNotLoadFooBar;
    push @DoesNotLoadFooBar::ISA, 'Foo', 'Bar';
  
  This is also helpful for the case where a package lives within
  a differently named file:
  
    package MyHash;
    use Tie::Hash;
    use parent -norequire, 'Tie::StdHash';
  
  This is equivalent to the following code:
  
    package MyHash;
    require Tie::Hash;
    push @ISA, 'Tie::StdHash';
  
  If you want to load a subclass from a file that C<require> would
  not consider an eligible filename (that is, it does not end in
  either C<.pm> or C<.pmc>), use the following code:
  
    package MySecondPlugin;
    require './plugins/custom.plugin'; # contains Plugin::Custom
    use parent -norequire, 'Plugin::Custom';
  
  =head1 DIAGNOSTICS
  
  =over 4
  
  =item Class 'Foo' tried to inherit from itself
  
  Attempting to inherit from yourself generates a warning.
  
      use Foo;
      use parent 'Foo';
  
  =back
  
  =head1 HISTORY
  
  This module was forked from L<base> to remove the cruft
  that had accumulated in it.
  
  =head1 CAVEATS
  
  =head1 SEE ALSO
  
  L<base>
  
  =head1 AUTHORS AND CONTRIBUTORS
  
  Rafal Garcia-Suarez, Bart Lateur, Max Maischein, Anno Siegel, Michael Schwern
  
  =head1 MAINTAINER
  
  Max Maischein C< corion@cpan.org >
  
  Copyright (c) 2007 Max Maischein C<< <corion@cpan.org> >>
  Based on the idea of C<base.pm>, which was introduced with Perl 5.004_04.
  
  =head1 LICENSE
  
  This module is released under the same terms as Perl itself.
  
  =cut
PARENT

s/^  //mg for values %fatpacked;

unshift @INC, sub {
  if (my $fat = $fatpacked{$_[1]}) {
    open my $fh, '<', \$fat;
    return $fh;
  }
  return
};

} # END OF FATPACK CODE
1;
